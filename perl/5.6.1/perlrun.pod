=encoding euc-jp

=head1 NAME

=begin original

perlrun - how to execute the Perl interpreter

=end original

perlrun - Perl インタプリタの起動方法

=head1 SYNOPSIS

B<perl>	S<[ B<-CsTuUWX> ]>
	S<[ B<-hv> ] [ B<-V>[:I<configvar>] ]>
	S<[ B<-cw> ] [ B<-d>[:I<debugger>] ] [ B<-D>[I<number/list>] ]>
	S<[ B<-pna> ] [ B<-F>I<pattern> ] [ B<-l>[I<octal>] ] [ B<-0>[I<octal>] ]>
	S<[ B<-I>I<dir> ] [ B<-m>[B<->]I<module> ] [ B<-M>[B<->]I<'module...'> ]>
	S<[ B<-P> ]>
	S<[ B<-S> ]>
	S<[ B<-x>[I<dir>] ]>
	S<[ B<-i>[I<extension>] ]>
	S<[ B<-e> I<'command'> ] [ B<--> ] [ I<programfile> ] [ I<argument> ]...>

=head1 DESCRIPTION

=begin original

The normal way to run a Perl program is by making it directly
executable, or else by passing the name of the source file as an
argument on the command line.  (An interactive Perl environment
is also possible--see L<perldebug> for details on how to do that.)
Upon startup, Perl looks for your program in one of the following
places:

=end original

Perl プログラムを実行する普通の方法は、直接実行できる形にするか、
コマンドラインの引数としてソースファイルの名前を渡すことです。
(対話的な Perl 環境もあります -- どのようにするかの詳細については
L<perldebug> を参照して下さい。)
実行にあたって、Perl は指定されたプログラムを以下に示す場所で
探します:

=over 4

=item 1.

=begin original

Specified line by line via B<-e> switches on the command line.

=end original

コマンドライン上で -e スイッチで指定された行。

=item 2.

=begin original

Contained in the file specified by the first filename on the command line.
(Note that systems supporting the #! notation invoke interpreters this
way. See L<Location of Perl>.)

=end original

コマンドライン上で最初のファイル名として示されたファイルの中。
(#! 記法をサポートしているシステムでは、このようにして
インタプリタを呼び出します。L<Location of Perl> を参照して下さい。)

=item 3.

=begin original

Passed in implicitly via standard input.  This works only if there are
no filename arguments--to pass arguments to a STDIN-read program you
must explicitly specify a "-" for the program name.

=end original

標準入力から暗黙に渡される。
ファイル名を示す引数が無い場合にのみうまくいきます。
STDIN から読み込むプログラムに引数を渡すには、
プログラム名として明示的に "-" を指定しなくてはなりません、

=back

=begin original

With methods 2 and 3, Perl starts parsing the input file from the
beginning, unless you've specified a B<-x> switch, in which case it
scans for the first line starting with #! and containing the word
"perl", and starts there instead.  This is useful for running a program
embedded in a larger message.  (In this case you would indicate the end
of the program using the C<__END__> token.)

=end original

2 番目、3 番目の方法では、B<-x> スイッチを指定した場合を除いて、
Perl は入力ファイルを最初から解析し始めます。　B<-x> スイッチを
指定した場合には、まず、最初に #! と "perl" という文字列を
含む行を探し、そこから解析を始めます。
これは、大きなテキストにプログラムを埋め込んで、実行するようなときに便利です。
(この場合、プログラムの終わりは、トークン C<__END__> を使って
示すとよいでしょう。)

=begin original

The #! line is always examined for switches as the line is being
parsed.  Thus, if you're on a machine that allows only one argument
with the #! line, or worse, doesn't even recognize the #! line, you
still can get consistent switch behavior regardless of how Perl was
invoked, even if B<-x> was used to find the beginning of the program.

=end original

#! を含む行のスイッチが必ず解析されるようになりました。
つまり、#! の行で引数が一つしか許されない、あるいは
もっと悪く、#! の行が認識されないといったシステムで運用している
場合にも、B<-x> でプログラムの開始位置を見つけた場合を
含め、どのように Perl が起動されたかによらず、一貫した
スイッチの動作を期待できるようになっています。

=begin original

Because historically some operating systems silently chopped off
kernel interpretation of the #! line after 32 characters, some
switches may be passed in on the command line, and some may not;
you could even get a "-" without its letter, if you're not careful.
You probably want to make sure that all your switches fall either
before or after that 32-character boundary.  Most switches don't
actually care if they're processed redundantly, but getting a "-"
instead of a complete switch could cause Perl to try to execute
standard input instead of your program.  And a partial B<-I> switch
could also cause odd results.

=end original

歴史的なオペレーティングシステムの中には
カーネルによる #! 行の解釈が、エラーなしに 32 文字で
打ち切られてしまうものがありますので、あるスイッチはコマンドラインに
渡され、あるスイッチは渡されないといったことが起こります。
注意しないと、文字が続かない "-" だけが渡されるといったことも
起こり得ます。
すべてのスイッチが、確実に 32 文字境界の前か後ろかのどちらかに
なるようにしたいことでしょう。
多くのスイッチは、余分に処理されても問題ありませんが、
完全なスイッチの代わりに "-" が入っていた場合には、
プログラムの代わりに、標準入力を Perl に
実行させることになってしまいます。
B<-I> スイッチが中途半端になった場合にもおかしな結果となり得ます。

=begin original

Some switches do care if they are processed twice, for instance
combinations of B<-l> and B<-0>.  Either put all the switches after
the 32-character boundary (if applicable), or replace the use of
B<-0>I<digits> by C<BEGIN{ $/ = "\0digits"; }>.

=end original

2 回実行されることに注意する必要のあるスイッチもあります。
例えば B<-l> と B<-0> の組み合わせです。
(可能なら) 両方のスイッチが 32 文字境界の後ろにいくようにするか、
B<-0>I<digits> を C<BEGIN{ $/ = "\0digits"; }> で置き換えてください。

=begin original

Parsing of the #! switches starts wherever "perl" is mentioned in the line.
The sequences "-*" and "- " are specifically ignored so that you could,
if you were so inclined, say

=end original

#! スイッチの解析は、行内で "perl" が示された位置から始まります。
とりわけ "-*" と "- " という文字の並びは無視されますので、

    #!/bin/sh -- # -*- perl -*- -p
    eval 'exec perl -wS $0 ${1+"$@"}'
        if $running_under_some_shell;

=begin original

to let Perl see the B<-p> switch.  

=end original

のように書けば、Perl に B<-p> スイッチを渡すことができます。

=begin original

A similar trick involves the B<env> program, if you have it.

=end original

似たようなトリックは(持っていれば) B<env> プログラムでも使えます。

    #!/usr/bin/env perl

=begin original

The examples above use a relative path to the perl interpreter,
getting whatever version is first in the user's path.  If you want
a specific version of Perl, say, perl5.005_57, you should place
that directly in the #! line's path.

=end original

上の例は Perl インタプリタに相対パスを使って、
ユーザーの PATH で最初にあったバージョンを使います。
もし特定のバージョンの Perl、例えば perl5.005_57 が使いたいなら、
#! 行のパスに直接書くべきです。

=begin original

If the #! line does not contain the word "perl", the program named after
the #! is executed instead of the Perl interpreter.  This is slightly
bizarre, but it helps people on machines that don't do #!, because they
can tell a program that their SHELL is F</usr/bin/perl>, and Perl will then
dispatch the program to the correct interpreter for them.

=end original

#! 行に "perl" という語が含まれていなければ、#! の後に指定された
プログラムが Perl インタプリタの代わりに実行されます。
これは少し変わっていますが、#! が行なえないマシンを使っている方には
有効でしょう。
プログラムに対して使っている SHELL が F</usr/bin/perl> だと言っておけば、
Perl が正しいインタプリタを起動してくれるからです。

=begin original

After locating your program, Perl compiles the entire program to an
internal form.  If there are any compilation errors, execution of the
program is not attempted.  (This is unlike the typical shell script,
which might run part-way through before finding a syntax error.)

=end original

プログラムの場所が特定できたなら、Perl はプログラム全体を内部形式に
コンパイルし始めます。
コンパイルエラーが見つかった時には、プログラムの実行は行なわれません。
(これは、構文エラーがある場合にも、途中まで実行される可能性のある、
典型的なシェルのスクリプトと異なる点です。)

=begin original

If the program is syntactically correct, it is executed.  If the program
runs off the end without hitting an exit() or die() operator, an implicit
C<exit(0)> is provided to indicate successful completion.

=end original

プログラムが構文的に正しければ、実行されることになります。
プログラムが、exit() 演算子にも die() 演算子にも当たらないで
最後まで到達すると、正常に完了したことを示すために、暗黙の
C<exit(0)> が行なわれます。

=head2 #! and quoting on non-Unix systems

(非 Unix システムでの #! とクォート)

=begin original

Unix's #! technique can be simulated on other systems:

=end original

Unix の #! のテクニックは他のシステムでもシミュレートされています。

=over 4

=item OS/2

=begin original

Put

    extproc perl -S -your_switches

as the first line in C<*.cmd> file (B<-S> due to a bug in cmd.exe's
`extproc' handling).

=end original

C<*.cmd> ファイルの最初の行に

    extproc perl -S -your_switches

と書いてください (B<-S> は cmd.exe の `extproc' の扱いの
バグを引き起こします)。

=item MS-DOS

=begin original

Create a batch file to run your program, and codify it in
C<ALTERNATIVE_SHEBANG> (see the F<dosish.h> file in the source
distribution for more information).

=end original

プログラムを実行するバッチファイルを作って、
C<ALTERNATIVE_SHEBANG> でコード化してください
(さらなる情報についてはソース配布パッケージの F<dosish.h> ファイルを
参照して下さい)。

=item Win95/NT

=begin original

The Win95/NT installation, when using the ActiveState installer for Perl,
will modify the Registry to associate the F<.pl> extension with the perl
interpreter.  If you install Perl by other means (including building from
the sources), you may have to modify the Registry yourself.  Note that
this means you can no longer tell the difference between an executable
Perl program and a Perl library file.

=end original

Win95/NT でのインストールにおいて、ActiveState の Perl 用インストーラーを
使った場合は、拡張子 F<.pl> を Perl インタプリタに関連付けるよう
レジストリを変更します。
他の方法で Perl をインストールした場合(ソースから構築した場合を含みます)、
レジストリを自分で変更する必要があります。
これは実行可能な Perl プログラムと Perl ライブラリファイルとの
違いがなくなってしまうことに注意してください。

=item Macintosh

=begin original

A Macintosh perl program will have the appropriate Creator and
Type, so that double-clicking them will invoke the perl application.

=end original

Macintosh perl プログラムは適切な Creator と Type を持っているので、
ダブルクリックすれば Perl アプリケーションを起動できます。

=item VMS

=begin original

Put

    $ perl -mysw 'f$env("procedure")' 'p1' 'p2' 'p3' 'p4' 'p5' 'p6' 'p7' 'p8' !
    $ exit++ + ++$status != 0 and $exit = $status = undef;

at the top of your program, where B<-mysw> are any command line switches you
want to pass to Perl.  You can now invoke the program directly, by saying
C<perl program>, or as a DCL procedure, by saying C<@program> (or implicitly
via F<DCL$PATH> by just using the name of the program).

=end original

プログラムの先頭に、

    $ perl -mysw 'f$env("procedure")' 'p1' 'p2' 'p3' 'p4' 'p5' 'p6' 'p7' 'p8' !
    $ exit++ + ++$status != 0 and $exit = $status = undef;

と書いてください。ここで B<-mysw> は Perl に渡したい
コマンドラインスイッチです。これで C<perl program> として直接
プログラムを起動できますし、
C<@program> として(あるいは F<DCL$PATH> 経由でプログラム名を使って)
DSL 手続きとして起動できます。

=begin original

This incantation is a bit much to remember, but Perl will display it for
you if you say C<perl "-V:startperl">.

=end original

この決まり文句は覚えるには少々長すぎますが、
C<perl "-V:startperl"> とすれば Perl がこれを表示してくれます。

=back

=begin original

Command-interpreters on non-Unix systems have rather different ideas
on quoting than Unix shells.  You'll need to learn the special
characters in your command-interpreter (C<*>, C<\> and C<"> are
common) and how to protect whitespace and these characters to run
one-liners (see B<-e> below).

=end original

非 Unix システムのコマンドインタプリタはクォートに関して
Unix シェルと異なった考え方をしています。
お使いのコマンドインタプリタのスペシャルキャラクタについて
(C<*>, C<\>, C<"> は一般的です)、そして
一行で起動するために(後述する B<-e> を参照して下さい)空白や
スペシャルキャラクタを保護する方法について学ぶ必要があるでしょう。

=begin original

On some systems, you may have to change single-quotes to double ones,
which you must I<not> do on Unix or Plan9 systems.  You might also
have to change a single % to a %%.

=end original

システムによってはシングルクォートをダブルクォートに変更する必要が
あるかもしれません。しかし Unix や Plan9 のシステムでは
I<してはいけません>。
また、単体の % を %% に変更する必要があるかもしれません。

=begin original

For example:

=end original

例えば:

    # Unix
    perl -e 'print "Hello world\n"'

    # MS-DOS, etc.
    perl -e "print \"Hello world\n\""

    # Macintosh
    print "Hello world\n"
     (then Run "Myscript" or Shift-Command-R)

    # VMS
    perl -e "print ""Hello world\n"""

=begin original

The problem is that none of this is reliable: it depends on the
command and it is entirely possible neither works.  If B<4DOS> were
the command shell, this would probably work better:

=end original

問題は、これらはどれも信頼性がないことです。
これはコマンドに依存し、どれも動かないかもしれません。
B<4DOS> がコマンドシェルなら、おそらくよりよく動きます:

    perl -e "print <Ctrl-x>"Hello world\n<Ctrl-x>""

=begin original

B<CMD.EXE> in Windows NT slipped a lot of standard Unix functionality in
when nobody was looking, but just try to find documentation for its
quoting rules.

=end original

Windows NT の B<CMD.EXE> は誰も見ていない間に多くの標準 Unix 機能が
入り込んでいますが、クォートのルールに関しては
ドキュメントを探してみてください。

=begin original

Under the Macintosh, it depends which environment you are using.  The MacPerl
shell, or MPW, is much like Unix shells in its support for several
quoting variants, except that it makes free use of the Macintosh's non-ASCII
characters as control characters.

=end original

Macintosh では、使っている環境に依存します。
MacPerl shell や MPW はクォート関係の対応に関して
かなり Unix シェルと似ています。
しかし、Macintosh の非 ASCII 文字をコントロール文字として
自由に使うことができます。

=begin original

There is no general solution to all of this.  It's just a mess.

=end original

この辺りのことに関する一般的な解決方法はありません。
まったくぐちゃぐちゃです。

=head2 Location of Perl

(Perl の位置)

=begin original

It may seem obvious to say, but Perl is useful only when users can
easily find it.  When possible, it's good for both F</usr/bin/perl>
and F</usr/local/bin/perl> to be symlinks to the actual binary.  If
that can't be done, system administrators are strongly encouraged
to put (symlinks to) perl and its accompanying utilities into a
directory typically found along a user's PATH, or in some other
obvious and convenient place.

=end original

当たり前のように聞こえるかもしれませんが、
Perl はユーザーが簡単に発見できる場合にのみ有用です。
可能なら、F</usr/bin/perl> と F</usr/local/bin/perl> の両方に
実際のバイナリへのシンボリックリンクを置くというのはよい考えです。
もしこれが無理なら、システム管理者は Perl と
付随するユーティリティ (へのシンボリックリンク) を、
典型的にユーザーの PATH で見付かるディレクトリか、
その他の明らかで便利な場所に置くべきです。

=begin original

In this documentation, C<#!/usr/bin/perl> on the first line of the program
will stand in for whatever method works on your system.  You are
advised to use a specific path if you care about a specific version.

=end original

このドキュメントでは、C<#!/usr/bin/perl> とプログラムの先頭に書けば
システムの全てのメソッドが実行できるものとしています。
特定のバージョンを使いたい場合は、特定のパスを使うか:

    #!/usr/local/bin/perl5.00554

=begin original

or if you just want to be running at least version, place a statement
like this at the top of your program:

=end original

あるいは単に最低限のバージョンを指定した場合は、
以下のような行をプログラムの先頭に置いてください:

    use 5.005_54;

=head2 Command Switches

(コマンドスイッチ)

=begin original

As with all standard commands, a single-character switch may be
clustered with the following switch, if any.

=end original

全ての標準コマンドと同様に、
1 文字のスイッチは、次に続くスイッチがあれば、それとつなげる
ことができます。

    #!/usr/bin/perl -spi.orig	# same as -s -p -i.orig

=begin original

Switches include:

=end original

スイッチ一覧:

=over 5

=item B<-0>[I<digits>]

=begin original

specifies the input record separator (C<$/>) as an octal number.  If there are
no digits, the null character is the separator.  Other switches may
precede or follow the digits.  For example, if you have a version of
B<find> which can print filenames terminated by the null character, you
can say this:

=end original

入力レコードセパレータ (C<$/>) を 8 進数で示します。
digits を指定しないと、ヌル文字がセパレータになります。
他のスイッチを前に置いてもかまいませんし、digits のあとに
つなげてもかまいません。
たとえば、ファイル名をヌル文字で区切って表示できる find があれば:

    find . -name '*.orig' -print0 | perl -n0e unlink

=begin original

The special value 00 will cause Perl to slurp files in paragraph mode.
The value 0777 will cause Perl to slurp files whole because there is no
legal character with that value.

=end original

00 という特別な値は、Perl にパラグラフモードで、ファイルを読ませます。
0777 という値は、該当する文字がないため、
Perl にファイル全体を読ませることになります。

=item B<-a>

=begin original

turns on autosplit mode when used with a B<-n> or B<-p>.  An implicit
split command to the @F array is done as the first thing inside the
implicit while loop produced by the B<-n> or B<-p>.

=end original

B<-n> や B<-p> といっしょに用いると、自動 split モードになります。
B<-n> や B<-p> で作られる暗黙のループ内の最初の文として、
配列 @F への暗黙の split コマンドが実行されます。

    perl -ane 'print pop(@F), "\n";'

=begin original

is equivalent to

=end original

は以下のものと等価です。

    while (<>) {
	@F = split(' ');
	print pop(@F), "\n";
    }

=begin original

An alternate delimiter may be specified using B<-F>.

=end original

B<-F> を使って区切文字を変更することができます。

=item B<-C>

=begin original

enables Perl to use the native wide character APIs on the target system.
The magic variable C<${^WIDE_SYSTEM_CALLS}> reflects the state of
this switch.  See L<perlvar/"${^WIDE_SYSTEM_CALLS}">.

=end original

Perl がターゲットシステムのワイド文字 API を使うように指示します。
マジック変数 C<${^WIDE_SYSTEM_CALLS}> にスイッチの状態が反映されます。
L<perlvar/"${^WIDE_SYSTEM_CALLS}"> を参照して下さい。

=begin original

This feature is currently only implemented on the Win32 platform.

=end original

この機能は現在のところ Win32 システムにのみ実装されています。

=item B<-c>

=begin original

causes Perl to check the syntax of the program and then exit without
executing it.  Actually, it I<will> execute C<BEGIN>, C<CHECK>, and
C<use> blocks, because these are considered as occurring outside the
execution of your program.  C<INIT> and C<END> blocks, however, will
be skipped.

=end original

Perl にスクリプトの構文のチェックを行なわせ、実行せずに
終了するようにします。
実際には、C<BEGIN>, C<CHECK>, C<use> ブロックは I<実行します>。
これらはプログラムの実行の外側にあるものと考えられるからです。
C<INIT> と C<END> ブロックはスキップされます。

=item B<-d>

=begin original

runs the program under the Perl debugger.  See L<perldebug>.

=end original

Perl デバッガの下でプログラムを実行します。
L<perldebug> を参照してください。

=item B<-d:>I<foo[=bar,baz]>

=begin original

runs the program under the control of a debugging, profiling, or
tracing module installed as Devel::foo. E.g., B<-d:DProf> executes
the program using the Devel::DProf profiler.  As with the B<-M>
flag, options may be passed to the Devel::foo package where they
will be received and interpreted by the Devel::foo::import routine.
The comma-separated list of options must follow a C<=> character.
See L<perldebug>.

=end original

Devel::foo としてインストールされる デバッグ・プロファイリング・
トレースモジュールの制御下でプログラムを実行します。
つまり、B<-d:DProf> は Devel::DProf プロファイラを使って
プログラムを実行します。
B<-M> フラグと共に使うと、オプションは
Devel::foo パッケージに渡され、Devel::foo::import ルーチンで
解釈されます。
オプションをコンマ区切りのリストにするときは C<=> の文字の
後に続けなければなりません。L<perldebug> を参照して下さい。

=item B<-D>I<letters>

=item B<-D>I<number>

=begin original

sets debugging flags.  To watch how it executes your program, use
B<-Dtls>.  (This works only if debugging is compiled into your
Perl.)  Another nice value is B<-Dx>, which lists your compiled
syntax tree.  And B<-Dr> displays compiled regular expressions. As an
alternative, specify a number instead of list of letters (e.g., B<-D14> is
equivalent to B<-Dtls>):

=end original

デバッグフラグを設定します。
スクリプトがどのように実行されるかを見るには、
B<-Dtls> を使ってください。
(これは、デバッグ機能を盛り込んで
コンパイルしたときにだけ働きます。)
この他に役に立つ値としては、コンパイルされた構文ツリーを表示する、
B<-Dx> があげられます。
B<-Dr> は、コンパイルした正規表現を表示します。
文字のリストの代わりに数字を指定することもできます
(たとえば、B<-D14> は B<-Dtls> と等価です):

=begin original

        1  p  Tokenizing and parsing
        2  s  Stack snapshots
        4  l  Context (loop) stack processing
        8  t  Trace execution
       16  o  Method and overloading resolution
       32  c  String/numeric conversions
       64  P  Print preprocessor command for -P, source file input state
      128  m  Memory allocation
      256  f  Format processing
      512  r  Regular expression parsing and execution
     1024  x  Syntax tree dump
     2048  u  Tainting checks
     4096  L  Memory leaks (needs -DLEAKTEST when compiling Perl)
     8192  H  Hash dump -- usurps values()
    16384  X  Scratchpad allocation
    32768  D  Cleaning up
    65536  S  Thread synchronization
   131072  T  Tokenising

=end original

        1  p  トークン化と構文解析
        2  s  スタックの表示
        4  l  コンテキスト(ループ)スタックの処理
        8  t  実行のトレース
       16  o  メソッドとオーバーロードの解決
       32  c  文字列/数値変換
       64  P  -P のためのプリプロセッサコマンドの表示、ソースファイル入力状態
      128  m  メモリ配置
      256  f  フォーマットの処理
      512  r  正規表現の解析と実効
     1024  x  構文トリーのダンプ
     2048  u  汚染チェック
     4096  L  メモリリーク (Perl のコンパイル時に -DLEAKTEST が指定されている必要がある)
     8192  H  ハッシュのダンプ -- values() の横取り
    16384  X  スクラッチパッドの配置
    32768  D  全消去
    65536  S  スレッド同期
   131072  T  トークン化

=begin original

All these flags require B<-DDEBUGGING> when you compile the Perl
executable.  See the F<INSTALL> file in the Perl source distribution 
for how to do this.  This flag is automatically set if you include B<-g>
option when C<Configure> asks you about optimizer/debugger flags.

=end original

これらの全てのフラグは Perl 実行ファイルをコンパイルするときに
B<-DDEBUGGING> が指定されている必要があります。
そうするためにどうすればいいかについては Perl のソース配布パッケージの
F<INSTALL> ファイルを参照して下さい。
このフラグは C<Configure> が最適化/デバッガフラグを尋ねたときに
B<-g> オプション込みで指定すれば自動的にセットされます。

=begin original

If you're just trying to get a print out of each line of Perl code
as it executes, the way that C<sh -x> provides for shell scripts,
you can't use Perl's B<-D> switch.  Instead do this 

=end original

シェルスクリプトにおける C<sh -x> のように、
単に今実行している Perl のコードを表示したい場合は、
Perl の B<-D> スイッチは使えません。代わりに以下のようにしてください:

  # Bourne shell syntax
  $ PERLDB_OPTS="NonStop=1 AutoTrace=1 frame=2" perl -dS program

  # csh syntax
  % (setenv PERLDB_OPTS "NonStop=1 AutoTrace=1 frame=2"; perl -dS program)

=begin original

See L<perldebug> for details and variations.

=end original

詳細とバリエーションについては L<perldebug> を参照して下さい。

=item B<-e> I<commandline>

=begin original

may be used to enter one line of program.  If B<-e> is given, Perl
will not look for a filename in the argument list.  Multiple B<-e>
commands may be given to build up a multi-line script.  Make sure
to use semicolons where you would in a normal program.

=end original

1 行のプログラムを指定するのに使用します。
B<-e> が指定されると Perl は引数のリストからはファイル名を探しません。
複数の -e コマンドで、複数行のスクリプトを構成することができます。
通常のプログラムでセミコロンを置くところには、セミコロンを使うことに
気を付けてください。

=item B<-F>I<pattern>

=begin original

specifies the pattern to split on if B<-a> is also in effect.  The
pattern may be surrounded by C<//>, C<"">, or C<''>, otherwise it will be
put in single quotes.

=end original

B<-a> も有効なときに、split を行なう正規表現を指定します。
パターンは C<//>, C<"">, C<''> で囲むか、
シングルクォートの中に書きます。

=item B<-h>

=begin original

prints a summary of the options.

=end original

オプションの一覧を表示します。

=item B<-i>[I<extension>]

=begin original

specifies that files processed by the C<E<lt>E<gt>> construct are to be
edited in-place.  It does this by renaming the input file, opening the
output file by the original name, and selecting that output file as the
default for print() statements.  The extension, if supplied, is used to
modify the name of the old file to make a backup copy, following these
rules:

=end original

C<E<lt>E<gt>> の構文で処理されたファイルを置き換えるための拡張子を
指定します。
これは、入力ファイルをリネームし、元の名前で出力ファイルを open し、
print() 文のデフォルトとしてその出力ファイルを select することで行ないます。
extension が指定されると、昔の内容のバックアップを行なう
ファイル名の拡張子として、元のファイル名に付け加えられます。

=begin original

If no extension is supplied, no backup is made and the current file is
overwritten.

=end original

extension が指定されないと、バックアップを作らず、
現在のファイルが上書きされます。

=begin original

If the extension doesn't contain a C<*>, then it is appended to the
end of the current filename as a suffix.  If the extension does
contain one or more C<*> characters, then each C<*> is replaced
with the current filename.  In Perl terms, you could think of this
as:

=end original

extension に C<*> が含まれていない場合、現在のファイル名の末尾に
接尾子として付け加えられます。
extension に一つ以上の C<*> の文字がある場合、
それぞれの C<*> は現在のファイル名で置き換えられます。
Perl 的に書くと、以下のようになります:

    ($backup = $extension) =~ s/\*/$file_name/g;

=begin original

This allows you to add a prefix to the backup file, instead of (or in
addition to) a suffix:

=end original

以下のようにすると、(接尾子の代わりに、あるいは接尾子に加えて)
バックアップファイルに接頭子をつけることができます。

    $ perl -pi 'orig_*' -e 's/bar/baz/' fileA	# backup to 'orig_fileA'

=begin original

Or even to place backup copies of the original files into another
directory (provided the directory already exists):

=end original

元のファイルのバックアップコピーを(既にある)他のディレクトリに作ることも
できます:

    $ perl -pi 'old/*.orig' -e 's/bar/baz/' fileA # backup to 'old/fileA.orig'

=begin original

These sets of one-liners are equivalent:

=end original

以下の一行スクリプトは全て等価です:

    $ perl -pi -e 's/bar/baz/' fileA		# overwrite current file
    $ perl -pi '*' -e 's/bar/baz/' fileA	# overwrite current file

    $ perl -pi '.orig' -e 's/bar/baz/' fileA	# backup to 'fileA.orig'
    $ perl -pi '*.orig' -e 's/bar/baz/' fileA	# backup to 'fileA.orig'

=begin original

From the shell, saying

=end original

シェルから以下のように起動すると:

    $ perl -p -i.orig -e "s/foo/bar/; ... "

=begin original

is the same as using the program:

=end original

プログラムで以下のようにするのと同じで:

    #!/usr/bin/perl -pi.orig
    s/foo/bar/;

=begin original

which is equivalent to

=end original

以下とほぼ等価です:

    #!/usr/bin/perl
    $extension = '.orig';
    LINE: while (<>) {
	if ($ARGV ne $oldargv) {
	    if ($extension !~ /\*/) {
		$backup = $ARGV . $extension;
	    }
	    else {
		($backup = $extension) =~ s/\*/$ARGV/g;
	    }
	    rename($ARGV, $backup);
	    open(ARGVOUT, ">$ARGV");
	    select(ARGVOUT);
	    $oldargv = $ARGV;
	}
	s/foo/bar/;
    }
    continue {
	print;	# this prints to original filename
    }
    select(STDOUT);

=begin original

except that the B<-i> form doesn't need to compare $ARGV to $oldargv to
know when the filename has changed.  It does, however, use ARGVOUT for
the selected filehandle.  Note that STDOUT is restored as the default
output filehandle after the loop.

=end original

違うのは、B<-i> の形式が、いつファイル名が変わったかを知るために、
$ARGV と $oldargv を比較する必要がないことです。
しかしながら、選択するファイルハンドルとして ARGVOUT は使用します。
ループのあとは、STDOUT がデフォルトのファイルハンドルとして再設定されます。

=begin original

As shown above, Perl creates the backup file whether or not any output
is actually changed.  So this is just a fancy way to copy files:

=end original

上述の通り、Perl はバックアップファイルを実際に出力が変更されたか
どうかに関わらず作成します。従って、以下はファイルをコピーする
変わった方法となります:

    $ perl -p -i '/some/file/path/*' -e 1 file1 file2 file3...
or
    $ perl -p -i '.orig' -e 1 file1 file2 file3...

=begin original

You can use C<eof> without parentheses to locate the end of each input
file, in case you want to append to each file, or reset line numbering
(see example in L<perlfunc/eof>).

=end original

個々のファイルの終わりに何かを付け加えたいときや、行番号を
リセットしたいような場合に、個々の入力ファイルの終わりを知るために、
括弧の無い C<eof> を使うことができます。
(L<perlfunc/eof> の例を参照してください。)

=begin original

If, for a given file, Perl is unable to create the backup file as
specified in the extension then it will skip that file and continue on
with the next one (if it exists).

=end original

与えられたファイルに対して、Perl が指定された拡張子でバックアップファイルを
作れない場合、そのファイルはスキップされて
(もしあれば)次のファイルに移って継続します。

=begin original

For a discussion of issues surrounding file permissions and B<-i>,
see L<perlfaq5/Why does Perl let me delete read-only files?  Why does -i clobber protected files?  Isn't this a bug in Perl?>.

=end original

ファイルのパーミッションと B<-i> に関する議論については、
L<perlfaq5/Why does Perl let me delete read-only files?  Why does -i clobber protected files?  Isn't this a bug in Perl?> を
参照して下さい。

=begin original

You cannot use B<-i> to create directories or to strip extensions from
files.

=end original

B<-i> は、ディレクトリを作ったり、ファイルの拡張子を取り除いたりは
できません。

=begin original

Perl does not expand C<~> in filenames, which is good, since some
folks use it for their backup files:

=end original

Perl は C<~> を展開しません。
これはバックアップファイルを以下のようにして作る人々のためには
よいことです。

    $ perl -pi~ -e 's/foo/bar/' file1 file2 file3...

=begin original

Finally, the B<-i> switch does not impede execution when no
files are given on the command line.  In this case, no backup is made
(the original file cannot, of course, be determined) and processing
proceeds from STDIN to STDOUT as might be expected.

=end original

最後に、B<-i> スイッチは、コマンドラインでファイルが指定されなくても
実行を妨げません。この場合、バックアップファイルは作成されず
(もちろん、元のファイルが決定できません)、
予想通り、STDIN から STDOUT に処理が行われます。

=item B<-I>I<directory>

=begin original

Directories specified by B<-I> are prepended to the search path for
modules (C<@INC>), and also tells the C preprocessor where to search for
include files.  The C preprocessor is invoked with B<-P>; by default it
searches /usr/include and /usr/lib/perl.

=end original

B<-I> で指定されたディレクトリはモジュールの検索パス(C<@INC>)に
加えられ、また C プリプロセッサにインクルードファイルを探す場所を示します。
C プリプロセッサは B<-P> で起動されます。
デフォルトでは /usr/include と /usr/lib/perl を探します。

=item B<-l>[I<octnum>]

=begin original

enables automatic line-ending processing.  It has two separate
effects.  First, it automatically chomps C<$/> (the input record
separator) when used with B<-n> or B<-p>.  Second, it assigns C<$\>
(the output record separator) to have the value of I<octnum> so
that any print statements will have that separator added back on.
If I<octnum> is omitted, sets C<$\> to the current value of
C<$/>.  For instance, to trim lines to 80 columns:

=end original

自動の行末処理を行なうようにします。
これには、2 つの独立した機能があります。
1 つには、B<-n> や B<-p> を使ったときに、
自動的にC<$/>(入力レコードセパレータ)を chomp します。
2 つめに octnum を C<$\>(出力レコードセパレータ) に代入し、
print 文でセパレータを追加できるようにします。
octnum を指定しなかった場合には、その時点の C<$/> の値を
C<$\> に設定します。
たとえば、行を 80 カラムに切り詰めるには以下のようにします:

    perl -lpe 'substr($_, 80) = ""'

=begin original

Note that the assignment C<$\ = $/> is done when the switch is processed,
so the input record separator can be different than the output record
separator if the B<-l> switch is followed by a B<-0> switch:

=end original

C<$\ = $/> という代入は、B<-l> スイッチが処理されるときに
実行されるときに行なわれますので、B<-l> スイッチの後に
B<-0> スイッチを置くようにすれば、入力レコードセパレータを、
出力レコードセパレータと違うようにもできます:

    gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

=begin original

This sets C<$\> to newline and then sets C<$/> to the null character.

=end original

これはまず、C<$\> に改行 (C<$/> のデフォルト値) を設定し、
それから C<$/> にヌル文字を設定します。

=item B<-m>[B<->]I<module>

=item B<-M>[B<->]I<module>

=item B<-M>[B<->]I<'module ...'>

=item B<-[mM]>[B<->]I<module=arg[,arg]...>

=begin original

B<-m>I<module> executes C<use> I<module> C<();> before executing your
program.

=end original

B<-m>I<module> はプログラムの実行前に C<use> I<module> C<();> を
実行します。

=begin original

B<-M>I<module> executes C<use> I<module> C<;> before executing your
program.  You can use quotes to add extra code after the module name,
e.g., C<'-Mmodule qw(foo bar)'>.

=end original

B<-M>I<module> はプログラムの実行前に C<use> I<module> C<;> を
実行します。モジュール名の後ろに追加のコードを加えるために
クォートを使うこともできます。つまり C<'-Mmodule qw(foo bar)'> などです。

=begin original

If the first character after the B<-M> or B<-m> is a dash (C<->)
then the 'use' is replaced with 'no'.

=end original

B<-M> または B<-m> の後の最初の文字がダッシュ(C<->)の場合、
'use' の代わりに 'no' が使われます。

=begin original

A little builtin syntactic sugar means you can also say
B<-mmodule=foo,bar> or B<-Mmodule=foo,bar> as a shortcut for
C<'-Mmodule qw(foo bar)'>.  This avoids the need to use quotes when
importing symbols.  The actual code generated by B<-Mmodule=foo,bar> is
C<use module split(/,/,q{foo,bar})>.  Note that the C<=> form
removes the distinction between B<-m> and B<-M>.

=end original

小さい組み込みの文法的シュガーとして、
C<'-Mmodule qw(foo bar)'> の代わりに
B<-mmodule=foo,bar> または B<-Mmodule=foo,bar> と書くことができます。
これで、インポートするシンボルにクォートを使わなくてもよいようになります。
B<-Mmodule=foo,bar> で生成される実際のコードは
C<use module split(/,/,q{foo,bar})> です。
C<=> の形は B<-m> と B<-M> の間の違いを取り除くことに注意してください。

=item B<-n>

=begin original

causes Perl to assume the following loop around your program, which
makes it iterate over filename arguments somewhat like B<sed -n> or
B<awk>:

=end original

以下のようなループが、実際のプログラムの回りにあるかのように
Perl に指示します。
B<sed -n> や B<awk> のようにファイル名引数上で繰り返しを
行なうことになります:

  LINE:
    while (<>) {
	...		# your program goes here
    }

=begin original

Note that the lines are not printed by default.  See B<-p> to have
lines printed.  If a file named by an argument cannot be opened for
some reason, Perl warns you about it and moves on to the next file.

=end original

デフォルトでは、各行が印字されることはありません。
各行の印字を行なうには B<-p> を参照してください。
引数で指定されたファイルがなんらかの理由でオープンできなかった場合、
Perl は警告を出して次のファイルに移ります。

=begin original

Here is an efficient way to delete all files older than a week:

=end original

以下にあげるのは、1 週間以上たったファイルを効率的に
削除するものです:

    find . -mtime +7 -print | perl -nle unlink

=begin original

This is faster than using the B<-exec> switch of B<find> because you don't
have to start a process on every filename found.  It does suffer from
the bug of mishandling newlines in pathnames, which you can fix if
you

=end original

これは、ファイル名が見つかるごとにプロセスを起動しなくて済みますので、
B<find> の B<-exec> スイッチを使うよりも速くなります。
これはパス名に改行コードがあるとうまく扱えないバグの影響を受けますので、
B<-O> の例に従うことで修正できます。

=begin original

C<BEGIN> and C<END> blocks may be used to capture control before or after
the implicit program loop, just as in B<awk>.

=end original

B<awk> と同じように、暗黙に実行されるプログラムループの前後に
実行されるコードを指定するために、C<BEGIN> ブロックと
C<END> ブロックを使うことができます。

=item B<-p>

=begin original

causes Perl to assume the following loop around your program, which
makes it iterate over filename arguments somewhat like B<sed>:

=end original

以下のようなループが、実際のプログラムの回りにあるかのように
Perl に指示します。
B<sed> のようにファイル名引数上で繰り返しを行なうことになります:


  LINE:
    while (<>) {
	...		# your program goes here
    } continue {
	print or die "-p destination: $!\n";
    }

=begin original

If a file named by an argument cannot be opened for some reason, Perl
warns you about it, and moves on to the next file.  Note that the
lines are printed automatically.  An error occurring during printing is
treated as fatal.  To suppress printing use the B<-n> switch.  A B<-p>
overrides a B<-n> switch.

=end original

引数で指定されたファイルが何らかの理由でオープンできない場合、
Perl は警告を出し、次のファイルに移ります。
各行は、自動的に印字されることになります。
印字中のエラーは致命的とみなされます。
印字を抑制するには、B<-n> スイッチを使ってください。
B<-p> は B<-n> スイッチを無効にします。

=begin original

C<BEGIN> and C<END> blocks may be used to capture control before or after
the implicit loop, just as in B<awk>.

=end original

B<awk> と同じように、暗黙に実行されるループの前後に
実行されるコードを指定するために、C<BEGIN> ブロックと
C<END> ブロックを使うことができます。

=item B<-P>

=begin original

causes your program to be run through the C preprocessor before
compilation by Perl.  Because both comments and B<cpp> directives begin
with the # character, you should avoid starting comments with any words
recognized by the C preprocessor such as C<"if">, C<"else">, or C<"define">.
Also, in some platforms the C preprocessor knows too much: it knows
about the C++ -style until-end-of-line comments starting with C<"//">.
This will cause problems with common Perl constructs like

=end original

Perl によるコンパイルを行なう前に、スクリプトを C プリプロセッサに
かけるようにします。
コメントも cpp のディレクティブも # で始まりますから、コメントの最初を
C プリプロセッサが認識してしまう C<"if">, C<"else">, C<"define">といった
単語で始めるべきではありません。
また、C プロセッサが知りすぎているプラットフォームもあります。
C++ スタイルの C<"//"> という「行末までのコメント」を知っている場合です。
この場合、以下のような良くある Perl の構造で問題が起こり得ます:

    s/foo//;

=begin original

because after -P this will became illegal code

=end original

-P の後だと以下のような不正なコードになってしまうからです。

    s/foo

=begin original

The workaround is to use some other quoting separator than C<"/">,
like for example C<"!">:

=end original

回避方法は、C<"/"> 以外のクォートセパレータを使うことです。
C<"!"> を使った例を示します:

    s!foo!!;

=item B<-s>

=begin original

enables rudimentary switch parsing for switches on the command
line after the program name but before any filename arguments (or before
an argument of B<-->).  This means you can have switches with two leading
dashes (B<--help>).  Any switch found there is removed from @ARGV and sets the
corresponding variable in the Perl program.  The following program
prints "1" if the program is invoked with a B<-xyz> switch, and "abc"
if it is invoked with B<-xyz=abc>.

=end original

コマンドライン上のプログラム名の後から、ファイル名引数
(または引数 B<-->) の前までのスイッチのための、原始的な解析を
行なえるようにします。
これは、二つのダッシュが前につくスイッチ(B<--help> など)も
使えることを示します。
ここで見つかったスイッチは、
@ARGV から取り除かれ、対応する Perl プログラムの変数に
設定されます。　以下のプログラムは、B<-xyz> というスイッチを
付けて実行された時にだけ、"1" と表示し、
B<-xyz=abc> と起動された時に "abc" と表示します。

    #!/usr/bin/perl -s
    if ($xyz) { print "$xyz\n" }

=begin original

Do note that B<--help> creates the variable ${-help}, which is not compliant
with C<strict refs>.

=end original

B<--help> は変数 ${-help} を作成するので、C<strict refs> を満たさない
ことに注意してください。

=item B<-S>

=begin original

makes Perl use the PATH environment variable to search for the
program (unless the name of the program contains directory separators).

=end original

Perl がプログラムを探すときに環境変数 PATH を参照するようにします
(プログラム名がディレクトリセパレータを含むときを除きます)。

=begin original

On some platforms, this also makes Perl append suffixes to the
filename while searching for it.  For example, on Win32 platforms,
the ".bat" and ".cmd" suffixes are appended if a lookup for the
original name fails, and if the name does not already end in one
of those suffixes.  If your Perl was compiled with DEBUGGING turned
on, using the -Dp switch to Perl shows how the search progresses.

=end original

プラットフォームによっては、Perl はファイルを探すときに拡張子を
追加します。
例えば Win32 プラットフォームでは、
元々のファイル名で検索が失敗した場合、".bat" と ".cmd" の拡張子が
追加されます。但し既にそのような拡張子がついていない場合だけです。
Perl が DEBUGGING を有効にしてコンパイルされていた場合、
-Dp スイッチを使うことでどのように検索が行われているかを
表示させることができます。

=begin original

Typically this is used to emulate #! startup on platforms that
don't support #!.  This example works on many platforms that
have a shell compatible with Bourne shell:

=end original

これは、#! をサポートしていないプラットフォームで、#! に
よる実行をエミュレートするために使います。
この例は Bourne shell 互換のシェルを持つ多くのプラットフォームで動きます:

    #!/usr/bin/perl
    eval 'exec /usr/bin/perl -wS $0 ${1+"$@"}'
	    if $running_under_some_shell;

=begin original

The system ignores the first line and feeds the program to F</bin/sh>,
which proceeds to try to execute the Perl program as a shell script.
The shell executes the second line as a normal shell command, and thus
starts up the Perl interpreter.  On some systems $0 doesn't always
contain the full pathname, so the B<-S> tells Perl to search for the
program if necessary.  After Perl locates the program, it parses the
lines and ignores them because the variable $running_under_some_shell
is never true.  If the program will be interpreted by csh, you will need
to replace C<${1+"$@"}> with C<$*>, even though that doesn't understand
embedded spaces (and such) in the argument list.  To start up sh rather
than csh, some systems may have to replace the #! line with a line
containing just a colon, which will be politely ignored by Perl.  Other
systems can't control that, and need a totally devious construct that
will work under any of B<csh>, B<sh>, or Perl, such as the following:

=end original

システムは、最初の行を無視し、プログラムを F</bin/sh> に渡し、
F</bin/sh> は Perl プログラムをシェルプログラムとして実行しようとします。
シェルは 2 行目を通常のシェルコマンドとして実行し、Perl インタプリタを
起動することになります。
$0 にフルパス名が入っているとは限らないシステムも
ありますので、-S が Perl に必要に応じてプログラムを探すように指示します。
Perl がプログラムを見つけると、これらの行の解析を始めますが、
$running_under_some_shell が真になることがないため、
無視することになります。
プログラムが csh で解釈される場合には、
たとえファイル名内に埋め込まれたスペースなどを扱うことができなくても
C<${1+"$@"}> を C<$*> で置き換える必要があるかもしれません。
csh ではなく、sh を起動するように、いくつかのシステムでは、#! の行を
Perl も無視することになっている、コロンだけの行で置き換える必要が
あるかもしれません。
そういった制御が効かないシステムでは、B<csh> でも B<sh> でも
Perl でも使える、回りくどい方法を使うことが必要です:

	eval '(exit $?0)' && eval 'exec perl -wS $0 ${1+"$@"}'
	& eval 'exec /usr/bin/perl -wS $0 $argv:q'
		if $running_under_some_shell;

=begin original

If the filename supplied contains directory separators (i.e., is an
absolute or relative pathname), and if that file is not found,
platforms that append file extensions will do so and try to look
for the file with those extensions added, one by one.

=end original

ファイル名にディレクトリセパレータが含まれていた場合
(つまり絶対パスまたは相対パスだった場合)、そしてそのファイルが
なかった場合、ファイル拡張子を追加するプラットフォームでは
ひとつずつ拡張子を追加して、ファイルを探します。

=begin original

On DOS-like platforms, if the program does not contain directory
separators, it will first be searched for in the current directory
before being searched for on the PATH.  On Unix platforms, the
program will be searched for strictly on the PATH.

=end original

DOS 風のプラットフォームでは、プログラムにディレクトリセパレータが
含まれていなかった場合、PATH を探す前に最初にカレントディレクトリを
探します。
Unix プラットフォームでは、プログラムは厳密に PATH からのみ
探されます。

=item B<-T>

=begin original

forces "taint" checks to be turned on so you can test them.  Ordinarily
these checks are done only when running setuid or setgid.  It's a
good idea to turn them on explicitly for programs that run on behalf
of someone else whom you might not necessarily trust, such as CGI
programs or any internet servers you might write in Perl.  See
L<perlsec> for details.  For security reasons, this option must be
seen by Perl quite early; usually this means it must appear early
on the command line or in the #! line for systems which support
that construct.

=end original

「汚染」チェックをオンにして、テストできるようにします。
通常、このチェックは setuid や setgid のスクリプトを実行するときにだけ、
行なわれます。
CGI プログラムやインターネットサーバーを Perl で書くときのように、
信用できるとは限らない人が動かすようなプログラムでは
これを明示的に有効にするのはいい考えです。
詳細については L<perlsec> を参照してください。
セキュリティ上の理由から、このオプションは Perl にかなり
早く渡さなければ成りません。
これは通常コマンドラインの最初の方につけるか、
#! 構造に対応するシステムではここに書くかです。

=item B<-u>

=begin original

This obsolete switch causes Perl to dump core after compiling your
program.  You can then in theory take this core dump and turn it
into an executable file by using the B<undump> program (not supplied).
This speeds startup at the expense of some disk space (which you
can minimize by stripping the executable).  (Still, a "hello world"
executable comes out to about 200K on my machine.)  If you want to
execute a portion of your program before dumping, use the dump()
operator instead.  Note: availability of B<undump> is platform
specific and may not be available for a specific port of Perl.

=end original

この古いスイッチはプログラムのコンパイル後、
コアダンプを行なうようにします。
理論的には、このコアダンプを持ってきて(Perl の配布では提供されていませんが)
B<undump> プログラムを使って、実行ファイルに変換することができます。
これは多少ディスク容量を食いますが (実行ファイルを sprit することで
少しは減ります)、実行開始を速くすることができます。
(減らしても、"hello world" の実行ファイルは、私のマシンで 200K 程に
なります。)
ダンプする前に部分的にプログラムを実行しておきたい場合には、
このスイッチの代わりに dump() 演算子を使ってください。
注意:B<undump> が実行できるのは特定の環境下ですし、
これが使えない移植バージョンの Perl もあるでしょう。

=begin original

This switch has been superseded in favor of the new Perl code
generator backends to the compiler.  See L<B> and L<B::Bytecode>
for details.

=end original

このスイッチはコンパイラのバックエンドとなる新しい Perl コード
ジェネレータの機能に置き換えられています。
詳細については L<B> と L<B::Bytecode> を参照して下さい。

=item B<-U>

=begin original

allows Perl to do unsafe operations.  Currently the only "unsafe"
operations are the unlinking of directories while running as superuser,
and running setuid programs with fatal taint checks turned into
warnings.  Note that the B<-w> switch (or the C<$^W> variable) must
be used along with this option to actually I<generate> the
taint-check warnings.

=end original

Perl に安全でない操作を許可します。
現在のところ、「安全でない」操作には、
スーパーユーザとして実行中にディレクトリを削除することと、
致命的な汚染チェックを警告に替えて、
setuid プログラムを実行することです。
B<-w> スイッチ(あるいは C<$^W> 変数)は
汚染チェックの警告が実際に I<生成される> ために
このオプションと共に使われなければなりません。

=item B<-v>

=begin original

prints the version and patchlevel of your perl executable.

=end original

Perl 実行ファイルのバージョンとパッチレベルを表示します。

=item B<-V>

=begin original

prints summary of the major perl configuration values and the current
values of @INC.

=end original

Perl の主な設定値と @INC の現在の値を表示します。

=item B<-V:>I<name>

=begin original

Prints to STDOUT the value of the named configuration variable.
For example, 

=end original

指定された設定変数の値を STDOUT に表示します。例えば:

    $ perl -V:man.dir

=begin original

will provide strong clues about what your MANPATH variable should
be set to in order to access the Perl documentation.

=end original

は MANPATH 環境変数が Perl のドキュメントにアクセスするときに
どのようにセットされるべきかについて強力な手がかりを与えます。

=item B<-w>

=begin original

prints warnings about dubious constructs, such as variable names
that are mentioned only once and scalar variables that are used
before being set, redefined subroutines, references to undefined
filehandles or filehandles opened read-only that you are attempting
to write on, values used as a number that doesn't look like numbers,
using an array as though it were a scalar, if your subroutines
recurse more than 100 deep, and innumerable other things.

=end original

1 度しか使われない変数名、設定される前に使われている変数、
サブルーティンの再定義、未定義のファイルハンドルの参照や、
read-only でオープンしたファイルハンドルへの書き込み、
数値に見えない値を数値として使った場合、配列を
スカラであるかのように使った場合、
100 段階以上のサブルーティンの再帰、
その他たくさんの疑わしい事に警告を出します。

=begin original

This switch really just enables the internal C<^$W> variable.  You
can disable or promote into fatal errors specific warnings using
C<__WARN__> hooks, as described in L<perlvar> and L<perlfunc/warn>.
See also L<perldiag> and L<perltrap>.  A new, fine-grained warning
facility is also available if you want to manipulate entire classes
of warnings; see L<warnings> or L<perllexwarn>.

=end original

このスイッチは実際には内部の C<$^W> 変数を有効にするだけです。
C<__WARN__> フックを使って特定の警告を無効にしたり
致命的エラーにしたりできます。
これについては L<perlvar> と L<perlfunc/warn> を参照して下さい。
L<perldiag> と L<perltrap> も参照して下さい。
もし警告のクラス全体を操作したいなら、新しく粒度の細かい
警告機能もあります。L<warnings> や L<perllexwarn> を参照して下さい。

=item B<-W>

=begin original

Enables all warnings regardless of C<no warnings> or C<$^W>.
See L<perllexwarn>.

=end original

C<no warnings> や C<$^W> の設定に関わらず全ての警告を有効にします。
L<perllexwarn> を参照して下さい。

=item B<-X>

=begin original

Disables all warnings regardless of C<use warnings> or C<$^W>.
See L<perllexwarn>.

=end original

C<use warnings> や C<$^W> の設定に関わらず全ての警告を無効にします。
L<perllexwarn> を参照して下さい。

=item B<-x> I<directory>

=begin original

tells Perl that the program is embedded in a larger chunk of unrelated
ASCII text, such as in a mail message.  Leading garbage will be
discarded until the first line that starts with #! and contains the
string "perl".  Any meaningful switches on that line will be applied.
If a directory name is specified, Perl will switch to that directory
before running the program.  The B<-x> switch controls only the
disposal of leading garbage.  The program must be terminated with
C<__END__> if there is trailing garbage to be ignored (the program
can process any or all of the trailing garbage via the DATA filehandle
if desired).

=end original

メールのような大きな無関係のASCII テキストのかたまりの中に
プログラムが埋め込まれている事を Perl につたえます。
最初の #! で始まり、"perl" という文字列を含む行までの、
先行するゴミは捨てられます。
その行にある意味を持つスイッチは適用されます。
directory が指定されると、Perl はプログラムの実行前に、
そのディレクトリに移ります。
C<-x> スイッチは先行するゴミの処分を制御するだけです。
プログラムの後に無視すべきゴミがある場合には、
C<__END__> でプログラムを終了する必要があります (その、後に続く
ゴミの一部または全部は、必要に応じて DATA ファイルハンドルを通して、
そのプログラムで処理する事ができます)。

=back

=head1 ENVIRONMENT

(環境変数)

=over 12

=item HOME

=begin original

Used if chdir has no argument.

=end original

chdir の引数がないときに使われます。

=item LOGDIR

=begin original

Used if chdir has no argument and HOME is not set.

=end original

chdir の引数がなく、HOME がセットされていないときに使われます。

=item PATH

=begin original

Used in executing subprocesses, and in finding the program if B<-S> is
used.

=end original

サブプロセスを実行するときと、B<-S> が指定されたときにプログラムを
探すのに使われます。

=item PERL5LIB

=begin original

A colon-separated list of directories in which to look for Perl library
files before looking in the standard library and the current
directory.  Any architecture-specific directories under the specified
locations are automatically included if they exist.  If PERL5LIB is not
defined, PERLLIB is used.

=end original

Perl のライブラリファイルを探すときに標準ライブラリディレクトリと
カレントディレクトリを探す前に探すディレクトリを
コロン区切りで並べたものです。
特定の場所におけるアーキテクチャ依存のディレクトリは
もしあれば自動的に追加されます。
PERL5LIB が定義されていなければ、PERLLIB が使われます。

=begin original

When running taint checks (either because the program was running setuid
or setgid, or the B<-T> switch was used), neither variable is used.
The program should instead say:

=end original

(プログラムが setuid または setgid で実行されているか、
B<-T> スイッチが指定されて)汚染チェック付きで動作している場合、
どちらの環境変数も使われません。
代わりにプログラム中で以下のようにするべきです:

    use lib "/my/directory";

=item PERL5OPT

=begin original

Command-line options (switches).  Switches in this variable are taken
as if they were on every Perl command line.  Only the B<-[DIMUdmw]>
switches are allowed.  When running taint checks (because the program
was running setuid or setgid, or the B<-T> switch was used), this
variable is ignored.  If PERL5OPT begins with B<-T>, tainting will be
enabled, and any subsequent options ignored.

=end original

コマンドラインオプション(スイッチ)です。
この変数のスイッチは全ての Perl コマンドラインで指定されたかのように
扱われます。
B<-[DIMUdmw]> オプションのみが有効です。
(プログラムが setuid または setgid で実行されているか、
B<-T> スイッチが指定されて)汚染チェック付きで動作している場合、
この変数は無視されます。
PERL5OPT が B<-T> で始まっている場合、
汚染チェックが有効となり、残りのオプションは無視されます。

=item PERLLIB

=begin original

A colon-separated list of directories in which to look for Perl library
files before looking in the standard library and the current directory.
If PERL5LIB is defined, PERLLIB is not used.

=end original

Perl ライブラリを探すのに標準ライブラリとカレントディレクトリの前に
検索するディレクトリをコロン区切りで並べたものです。
PERL5LIB が定義されていると、PERLLIB は使われません。

=item PERL5DB

=begin original

The command used to load the debugger code.  The default is:

=end original

デバッガコードを読み込むのに使われるコマンドです。
デフォルトは以下の通り:

	BEGIN { require 'perl5db.pl' }

=item PERL5SHELL (specific to the Win32 port)

=begin original

May be set to an alternative shell that perl must use internally for
executing "backtick" commands or system().  Default is C<cmd.exe /x/c>
on WindowsNT and C<command.com /c> on Windows95.  The value is considered
to be space-separated.  Precede any character that needs to be protected
(like a space or backslash) with a backslash.

=end original

"バッククォート" コマンドや system() を実行するために
Perl が内部的に使わなければならない代替シェルを指定します。
デフォルトは WindowsNT では C<cmd.exe /x/c>、Windows95 では
C<command.com /c> です。
値はスペース区切りと考えられます。
(空白やバックスラッシュのような) 保護する必要がある文字の前には
バックスラッシュがつけられます。

=begin original

Note that Perl doesn't use COMSPEC for this purpose because
COMSPEC has a high degree of variability among users, leading to
portability concerns.  Besides, perl can use a shell that may not be
fit for interactive use, and setting COMSPEC to such a shell may
interfere with the proper functioning of other programs (which usually
look in COMSPEC to find a shell fit for interactive use).

=end original

COMSPEC の値はユーザーによってかなり様々で、移植性の問題を引き起こすので、
Perl はこの目的に COMSPEC は使わないことに注意してください。
さらに、Perl は対話的な用途には向かないシェルも利用できますが、
COMSPEC にそのようなシェルを指定すると他のプログラム
(普通は対話的な用途に適したシェルを探すのに COMSPEC を使います)の適切な利用を
邪魔するかもしれません。

=item PERL_DEBUG_MSTATS

=begin original

Relevant only if perl is compiled with the malloc included with the perl
distribution (that is, if C<perl -V:d_mymalloc> is 'define').
If set, this causes memory statistics to be dumped after execution.  If set
to an integer greater than one, also causes memory statistics to be dumped
after compilation.

=end original

Perl が Perl 配布パッケージに含まれる malloc ルーチンを使って
コンパイルされている場合(C<perl -V:d_mymalloc> が 'define' の場合)にのみ
有効です。
設定されると、実行後にメモリ状況が表示されます。
1 を超える数値が設定されると、コンパイル後にも
メモリ状況を表示します。

=item PERL_DESTRUCT_LEVEL

=begin original

Relevant only if your perl executable was built with B<-DDEBUGGING>,
this controls the behavior of global destruction of objects and other
references.

=end original

Perl の実行ファイルが B<-DDEBUGGING> 付きで構築された場合にのみ有効です。
このオプションはオブジェクトやその他のリファレンスのグローバルな
デストラクタの振る舞いを制御します。

=item PERL_ROOT (specific to the VMS port)

=begin original

A translation concealed rooted logical name that contains perl and the
logical device for the @INC path on VMS only.  Other logical names that
affect perl on VMS include PERLSHR, PERL_ENV_TABLES, and 
SYS$TIMEZONE_DIFFERENTIAL but are optional and discussed further in 
L<perlvms> and in F<README.vms> in the Perl source distribution.

=end original

Perl と VMS 専用の @INC のための論理デバイスを含む、
変換が隠されたルートとなる論理名です。
VMS の Perl に影響を与えるその他の論理名としては
PERLSHR, PERL_ENV_TABLES, SYS$TIMEZONE_DIFFERENTIAL がありますが、
これらはオプションです。詳細については
Perl ソース配布パッケージの L<perlvms> と F<README.vms> で
議論されています。

=item SYS$LOGIN (specific to the VMS port)

=begin original

Used if chdir has no argument and HOME and LOGDIR are not set.

=end original

chdir の引数がなく、HOME と LOGDIR がセットされていないときに使われます。

=back

=begin original

Perl also has environment variables that control how Perl handles data
specific to particular natural languages.  See L<perllocale>.

=end original

特定の自然言語に特有のデータを Perl がどのように扱うかを
制御する環境変数もあります。L<perllocale> を参照して下さい。

=begin original

Apart from these, Perl uses no other environment variables, except
to make them available to the program being executed, and to child
processes.  However, programs running setuid would do well to execute
the following lines before doing anything else, just to keep people
honest:

=end original

これらの他には、
実行されているプログラムあるいはチャイルドプロセスがが有効にしない限り、
Perl は環境変数を使いません。
しかし、setuid で動作するプログラムは何かをする前に、
単に人々に変な気を起こさせないために
以下のコードを入れておくのがよいです。

    $ENV{PATH}  = '/bin:/usr/bin';    # or whatever you need
    $ENV{SHELL} = '/bin/sh' if exists $ENV{SHELL};
    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp>
Update: Kentaro Shirakata <argrath@ub32.org>
License: GPL or Artistic

=end meta
