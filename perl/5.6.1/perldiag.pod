
=encoding euc-jp

=head1 NAME

=begin original

perldiag - various Perl diagnostics

=end original

perldiag - さまざまな Perl 診断メッセージ

=head1 DESCRIPTION

=begin original

These messages are classified as follows (listed in increasing order of
desperation):

=end original

これらのメッセージは以下のように分類されます (重要度が増す順に
並べてあります):

=begin original

    (W) A warning (optional).
    (D) A deprecation (optional).
    (S) A severe warning (default).
    (F) A fatal error (trappable).
    (P) An internal error you should never see (trappable).
    (X) A very fatal error (nontrappable).
    (A) An alien error message (not generated by Perl).

=end original

    (W) 警告 (オプション)
    (D) 非推奨 (オプション)
    (S) 重大な警告 (デフォルト)
    (F) 致命的エラー (トラップ可能)
    (P) 起こるはずのない内部エラー (トラップ可能)
    (X) 重大致命的エラー (トラップ不可能)
    (A) 外部エラーメッセージ (Perl 以外で生成されたもの)

=begin original

The majority of messages from the first three classifications above
(W, D & S) can be controlled using the C<warnings> pragma. 

=end original

上記のうち、最初の三つ (W, D, S) に分類されるメッセージの大部分は
C<warings> プラグマで制御できます。

=begin original

If a message can be controlled by the C<warnings> pragma, its warning
category is included with the classification letter in the description
below.

=end original

メッセージが C<warnings> プラグマで制御できる場合、
警告カテゴリは以下の説明で分類文字と共に記されています。

=begin original

Optional warnings are enabled by using the C<warnings> pragma or the B<-w>
and B<-W> switches. Warnings may be captured by setting C<$SIG{__WARN__}>
to a reference to a routine that will be called on each warning instead
of printing it.  See L<perlvar>.

=end original

C<warnings> プラグマか B<-w> と B<-W> のオプションを使うと追加の警告が
有効になります。
警告は、表示する変わりに警告が出るたびに呼び出されるサブルーチンへの
リファレンスを C<$SIG{__WARN__}> にセットすることで捕捉できます。
L<perlvar> を参照してください。

=begin original

Default warnings are always enabled unless they are explicitly disabled
with the C<warnings> pragma or the B<-X> switch.

=end original

デフォルトでは C<warnings> プラグマか B<-X> オプションで明示的に
無効にされない限り、警告は常に有効です。

=begin original

Trappable errors may be trapped using the eval operator.  See
L<perlfunc/eval>.  In almost all cases, warnings may be selectively
disabled or promoted to fatal errors using the C<warnings> pragma.
See L<warnings>.

=end original

トラップ可能なエラーは評価演算子を使ってトラップできます。
L<perlfunc/eval> を参照してください。
ほとんど全ての場合、警告は C<warnings> プラグマを使うことで
選択的に無効にしたり致命的エラーに昇格させたりできます。
L<warnings> を参照してください。

=begin original

The messages are in alphabetical order, without regard to upper or
lower-case.  Some of these messages are generic.  Spots that vary are
denoted with a %s or other printf-style escape.  These escapes are
ignored by the alphabetical order, as are all characters other than
letters.  To look up your message, just ignore anything that is not a
letter.

=end original

メッセージは大文字小文字を無視してアルファベット順に並んでいます。
これらの中には一般的なものもあります。
変化する部分は %s またはその他の printf スタイルの表記をしています。
これらの表記や、その他の英文字以外の文字は並び順に関しては
無視されています。
メッセージを探すには、英文字以外は無視してください。

=over 4

=item accept() on closed socket %s

=begin original

(W closed) You tried to do an accept on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/accept>.

=end original

(W closed) クローズされたソケットに accept を行なおうとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか。
L<perlfunc/accept> を参照してください。

=item Allocation too large: %lx

=begin original

(X) You can't allocate more than 64K on an MS-DOS machine.

=end original

(X) MS-DOS マシンでは、64K を越えるメモリアロケートをおこなえません。

=item '!' allowed only after types %s

=begin original

(F) The '!' is allowed in pack() and unpack() only after certain types.
See L<perlfunc/pack>.

=end original

(F) pack() や unpack() での '!' は特定のタイプの後にのみ
つけることができます。
L<perlfunc/pack> を参照してください。

=item Ambiguous call resolved as CORE::%s(), qualify as such or use &

=begin original

(W ambiguous) A subroutine you have declared has the same name as a Perl
keyword, and you have used the name without qualification for calling
one or the other.  Perl decided to call the builtin because the
subroutine is not imported.

=end original

(W ambiguous) 定義したサブルーチンの名前が Perl のキーワードと同じで、
どちらかを呼び出すために修飾なしで名前を使っています。
Perl は、サブルーチンがインポートされたものではないので、
組み込みのものを呼び出すことにしました。

=begin original

To force interpretation as a subroutine call, either put an ampersand
before the subroutine name, or qualify the name with its package.
Alternatively, you can import the subroutine (or pretend that it's
imported with the C<use subs> pragma).

=end original

サブルーチン呼び出しとして解釈することを強制させるためには、
サブルーチン名の前にアンパサンドをつけるか、名前をパッケージ名で
修飾してください。
他の方法として、サブルーチンをインポートする(あるいは C<use subs>
プラグマを使ってインポートされたふりをする)方法もあります。

=begin original

To silently interpret it as the Perl operator, use the C<CORE::> prefix
on the operator (e.g. C<CORE::log($x)>) or by declaring the subroutine
to be an object method (see L<perlsub/"Subroutine Attributes"> or
L<attributes>).

=end original

警告なしに Perl 演算子として解釈させるためには、(C<CORE::log($x)> のように)
演算子に C<CORE::> 接頭辞をつけるか、サブルーチンをオブジェクト
メソッド(L<perlsub/"Subroutine Attributes"> や L<attributes> を
参照してください)として定義してください。

=item Ambiguous use of %s resolved as %s

=begin original

(W ambiguous)(S) You said something that may not be interpreted the way
you thought.  Normally it's pretty easy to disambiguate it by supplying
a missing quote, operator, parenthesis pair or declaration.

=end original

(W ambiguous)(S) 何か、あなたが考えているようには解釈できないものが
ありました。
普通は、不足しているクォート、演算子、かっこ、宣言を追加することで
かなり簡単にあいまいさを解消できます。

=item '|' and '<' may not both be specified on command line

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and found that STDIN was a pipe, and that you also tried to
redirect STDIN using '<'.  Only one STDIN stream to a customer, please.

=end original

(F) VMS 特有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、STDIN がパイプで
あることを発見しましたが、さらに '<' を使って STDIN をリダイレクトしようと
しました。
STDIN ストリームは一つだけにしてください。
お願いします。

=item '|' and '>' may not both be specified on command line

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and thinks you tried to redirect stdout both to a file and
into a pipe to another command.  You need to choose one or the other,
though nothing's stopping you from piping into a program or Perl script
which 'splits' output into two streams, such as

=end original

(F) VMS 特有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、STDOUT を
ファイルと他のコマンドへのパイプと両方にリダイレクトしようとしていると
判断しました。
どちらかを選ぶ必要がありますが、以下のように出力を二つのストリームに
「分割」するプログラムや Perl スクリプトにパイプすることを止めるものは
何もありません。

    open(OUT,">$ARGV[0]") or die "Can't write to $ARGV[0]: $!";
    while (<STDIN>) {
        print;
        print OUT;
    }
    close OUT;

=item Applying %s to %s will act on scalar(%s)

=begin original

(W misc) The pattern match (//), substitution (s///), and
transliteration (tr///) operators work on scalar values.  If you apply
one of them to an array or a hash, it will convert the array or hash to
a scalar value -- the length of an array, or the population info of a
hash -- and then work on that scalar value.  This is probably not what
you meant to do.  See L<perlfunc/grep> and L<perlfunc/map> for
alternatives.

=end original

(W misc) パターンマッチ (//), 置換 (s///), 文字置換
(tr///) 演算子はスカラ値に対して動作します。
これらを配列やハッシュに適用すると、配列やハッシュをスカラ値 --
配列の長さかハッシュの大きさの情報 -- に変換し、そのスカラ値に対して
動作します。
これはおそらくしたいこととは違うでしょう。
代替案については L<perlfunc/grep> と L<perlfunc/map> を参照してください。

=item Args must match #! line

=begin original

(F) The setuid emulator requires that the arguments Perl was invoked
with match the arguments specified on the #! line.  Since some systems
impose a one-argument limit on the #! line, try combining switches;
for example, turn C<-w -U> into C<-wU>.

=end original

(F) setuid エミュレータでは、Perl を起動したときの引数と、
#! の行で指定された引数はマッチすることが要求されます。
#! 行の 1 引数制限があるシステムがあるので、
組み合わせスイッチを試してみてください;
例えば、C<-w -U> を C<-wU> にしてください。

=item Arg too short for msgsnd

=begin original

(F) msgsnd() requires a string at least as long as sizeof(long).

=end original

(F) msgsnd() に渡す文字列は、少なくとも sizeof(long) の
長さが必要です。

=item %s argument is not a HASH or ARRAY element

=begin original

(F) The argument to exists() must be a hash or array element, such as:

=end original

(F) exists() の引数は、
以下のようなハッシュの要素でなければなりません。

    $foo{$bar}
    $ref->{"susie"}[12]

=item %s argument is not a HASH or ARRAY element or slice

=begin original

(F) The argument to delete() must be either a hash or array element,
such as:

=end original

(F) delete() の引数は以下のようにハッシュか配列の要素であるか:

    $foo{$bar}
    $ref->{"susie"}[12]

=begin original

or a hash or array slice, such as:

=end original

あるいは以下のようにハッシュか配列のスライスでなければなりません:

    @foo[$bar, $baz, $xyzzy]
    @{$ref->[12]}{"susie", "queue"}

=item %s argument is not a subroutine name

=begin original

(F) The argument to exists() for C<exists &sub> must be a subroutine
name, and not a subroutine call.  C<exists &sub()> will generate this
error.

=end original

(F) C<exists &sub> の形の exists() の引数はサブルーチン呼び出しではなく、
サブルーチン名でなければなりません。
C<exists &sub()> とするとこのエラーが生成されます。

=item Argument "%s" isn't numeric%s

=begin original

(W numeric) The indicated string was fed as an argument to an operator
that expected a numeric value instead.  If you're fortunate the message
will identify which operator was so unfortunate.

=end original

(W numeric) ここに示した文字列は、数値が必要な演算子の引数として、
与えられました。
運がよければ、このメッセージによって、どの演算子が
問題となったかがわかります。

=item Array @%s missing the @ in argument %d of %s()

=begin original

(D deprecated) Really old Perl let you omit the @ on array names in some
spots.  This is now heavily deprecated.

=end original

(D deprecated) 本当に古い Perl では、場所によっては、配列名の @ を
省略できました。
この省略は、止めてください。

=item assertion botched: %s

=begin original

(P) The malloc package that comes with Perl had an internal failure.

=end original

(P) Perl に付属の malloc ルーティンが内部エラーを起こしました。

=item Assertion failed: file "%s"

=begin original

(P) A general assertion failed.  The file in question must be examined.

=end original

(P) 一般的なアサーションが失敗しました。
問題の file を調べる必要があります。

=item Assignment to both a list and a scalar

=begin original

(F) If you assign to a conditional operator, the 2nd and 3rd arguments
must either both be scalars or both be lists.  Otherwise Perl won't
know which context to supply to the right side.

=end original

(F) 条件演算子へ代入を行なう場合には、2 つめの引数と、3 つめの引数は、
ともにスカラか、ともにリストでなければなりません。
そうでないと、Perl は右辺のコンテキストを決めることができません。

=item Negative offset to vec in lvalue context

=begin original

(F) When vec is called in an lvalue context, the second argument must be
greater than or equal to zero.

=end original

(F) 左辺値コンテキストで vec が呼び出されたとき、
二つ目の引数は 0 以上でなければなりません。

=item Attempt to free non-arena SV: 0x%lx

=begin original

(P internal) All SV objects are supposed to be allocated from arenas
that will be garbage collected on exit.  An SV was discovered to be
outside any of those arenas.

=end original

(P internal) すべての SV オブジェクトは、exit 時にガーベジコレクションが
行なわれるアリーナに割り当てるようになっています。
ある SV が、そういったアリーナに入っていないことが、見つかりました。

=item Attempt to free nonexistent shared string

=begin original

(P internal) Perl maintains a reference counted internal table of
strings to optimize the storage and access of hash keys and other
strings.  This indicates someone tried to decrement the reference count
of a string that can no longer be found in the table.

=end original

(P internal) Perl はストレージおよびハッシュキーとその他の
文字列へのアクセスを最適化するために、文字列の参照数テーブルを
管理しています。
これは誰かがもうテーブルにない文字列の参照カウントを減らそうと
したことを示します。

=item Attempt to free temp prematurely

=begin original

(W debugging) Mortalized values are supposed to be freed by the
free_tmps() routine.  This indicates that something else is freeing the
SV before the free_tmps() routine gets a chance, which means that the
free_tmps() routine will be freeing an unreferenced scalar when it does
try to free it.

=end original

(W debugging) 消滅する値は、free_tmps() ルーティンで解放されるように
なっています。
このメッセージは、free_tmps() ルーティンの前に何ものかが、SV を
解放しようとしていることを示していて、これは、free_tmps() が
解放しようとしたときには、どこからも参照されていないスカラを
解放することになるということです。

=item Attempt to free unreferenced glob pointers

=begin original

(P internal) The reference counts got screwed up on symbol aliases.

=end original

(P internal) シンボルのエイリアスについて、参照カウントの値がおかしな
状態になりました。

=item Attempt to free unreferenced scalar

=begin original

(W internal) Perl went to decrement the reference count of a scalar to
see if it would go to 0, and discovered that it had already gone to 0
earlier, and should have been freed, and in fact, probably was freed.
This could indicate that SvREFCNT_dec() was called too many times, or
that SvREFCNT_inc() was called too few times, or that the SV was
mortalized when it shouldn't have been, or that memory has been
corrupted.

=end original

(W) Perl がスカラの参照カウントをデクリメントしようとして、0 に
なるかを見たところ、既に 0 になっていることがわかりました。
これは、既に解放されているべきものであり、実際は、おそらく、
解放されたものでしょう。
これは、SvREFCNT_dec() が必要以上に呼ばれたか、SvREFCNT_inc() が必要な
ときに呼ばれなかったか、SV が消滅すべきで無いときに消滅してしまったか、
メモリ異常になったことが考えられます。

=item Attempt to join self

=begin original

(F) You tried to join a thread from within itself, which is an
impossible task.  You may be joining the wrong thread, or you may need
to move the join() to some other thread.

=end original

(F) スレッドをそれ自身の中から join しようとしました。
これは不可能な動作です。
間違ったスレッドに join しようとしているか、
あるいは join() を他のスレッドに移動させる必要があります。

=item Attempt to pack pointer to temporary value

=begin original

(W pack) You tried to pass a temporary value (like the result of a
function, or a computed expression) to the "p" pack() template.  This
means the result contains a pointer to a location that could become
invalid anytime, even before the end of the current statement.  Use
literals or global values as arguments to the "p" pack() template to
avoid this warning.

=end original

(W pack) (関数の結果や計算された式といった)一時的な値を pack() の
"p" テンプレートに渡そうとしました。
これは、たとえ現在の文の終了前でも、不正な値となり得ます。
この警告を避けるためには、pack テンプレート "p" の引数として、
リテラルかグローバルな値を使ってください。

=item Attempt to use reference as lvalue in substr

=begin original

(W substr) You supplied a reference as the first argument to substr()
used as an lvalue, which is pretty strange.  Perhaps you forgot to
dereference it first.  See L<perlfunc/substr>.

=end original

(W substr) 左辺値として使われる substr() の 1 番目の引数としてリファレンスを
渡しました; これはやや奇妙なことです。
おそらくはまずデリファレンスするのを忘れたのでしょう。
L<perlfunc/substr> を参照してください。

=item Bad arg length for %s, is %d, should be %d

=begin original

(F) You passed a buffer of the wrong size to one of msgctl(), semctl()
or shmctl().  In C parlance, the correct sizes are, respectively,
S<sizeof(struct msqid_ds *)>, S<sizeof(struct semid_ds *)>, and
S<sizeof(struct shmid_ds *)>.

=end original

(F) msgctl()、semctl()、shmctl() のいずれかに、間違ったサイズのバッファを
渡してしまいました。
C の言い方で書くと、正しいサイズはそれぞれ、sizeof(struct msqid_ds *)、
sizeof(struct semid_ds *)、sizeof(struct shmid_ds *) です。

=item Bad evalled substitution pattern

=begin original

(F) You've used the /e switch to evaluate the replacement for a
substitution, but perl found a syntax error in the code to evaluate,
most likely an unexpected right brace '}'.

=end original

(F)置換のための置き換え文字列を評価するために C</e> オプションを指定して
いますが、評価するコードに文法エラーがありました;
最もありそうなことは、予期しない位置に右中かっこ '}' があったことです。

=item Bad filehandle: %s

=begin original

(F) A symbol was passed to something wanting a filehandle, but the
symbol has no filehandle associated with it.  Perhaps you didn't do an
open(), or did it in another package.

=end original

(F) ファイルハンドルが必要なものに、シンボルを渡しましたが、
そのシンボルは、それに伴うファイルハンドルがありません。
おそらく、open() を忘れたか、別のパッケージで open() したかでしょう。

=item Bad free() ignored

=begin original

(S malloc) An internal routine called free() on something that had never
been malloc()ed in the first place. Mandatory, but can be disabled by
setting environment variable C<PERL_BADFREE> to 0.

=end original

(S malloc) まず、malloc() されていないものに対して、内部ルーティンが
free() を呼びました。
強制ですが、環境変数 C<PERL_BADFREE> を 0 にすることで無効化できます。

=begin original

This message can be seen quite often with DB_File on systems with "hard"
dynamic linking, like C<AIX> and C<OS/2>. It is a bug of C<Berkeley DB>
which is left unnoticed if C<DB> uses I<forgiving> system malloc().

=end original

このメッセージ は、C<AIX> や C<OS/2> のような、「ハード」動的リンクを
行うシステムで DB_File を使うとしばしば表示されます。
これは C<DB> がシステムの malloc() を許していることに気が付かない
C<Berkeley DB> のバグです。

=item Bad hash

=begin original

(P) One of the internal hash routines was passed a null HV pointer.

=end original

(P) 内部ハッシュルーティンで、ヌル HV ポインタを渡されたものがありました。

=item Bad index while coercing array into hash

=begin original

(F) The index looked up in the hash found as the 0'th element of a
pseudo-hash is not legal.  Index values must be at 1 or greater.
See L<perlref>.

=end original

(F) 擬似ハッシュの 0 番目の要素として見つかったハッシュの中の
インデックス検索は不正です。
インデックスの値は 1 以上でなければなりません。
L<perlref> を参照してください。

=item Badly placed ()'s

=begin original

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item Bad name after %s::

=begin original

(F) You started to name a symbol by using a package prefix, and then
didn't finish the symbol.  In particular, you can't interpolate outside
of quotes, so

=end original

(F) パッケージプレフィクスでシンボル名を書き始めましたが、
そのシンボルが終了しませんでした。
特に、クォートの外で、変数展開はできませんから、

    $var = 'myvar';
    $sym = mypack::$var;

=begin original

is not the same as

=end original

は、以下と同じではありません。

    $var = 'myvar';
    $sym = "mypack::$var";

=item Bad realloc() ignored

=begin original

(S malloc) An internal routine called realloc() on something that had
never been malloc()ed in the first place. Mandatory, but can be disabled
by setting environment variable C<PERL_BADFREE> to 1.

=end original

(S malloc) 内部ルーチンが、最初に malloc() されていない何かに対して
realloc() を呼び出しました。
必須ですが、環境変数 C<PERL_BADFREE> に 1 をセットすることで無効化できます。

=item Bad symbol for array

=begin original

(P) An internal request asked to add an array entry to something that
wasn't a symbol table entry.

=end original

(P) シンボルテーブルエントリではないものに、配列エントリを登録するような
内部要求があがりました。

=item Bad symbol for filehandle

=begin original

(P) An internal request asked to add a filehandle entry to something
that wasn't a symbol table entry.

=end original

(P) シンボルテーブルエントリではないものに、ファイルハンドルエントリを
登録するような内部要求があがりました。

=item Bad symbol for hash

=begin original

(P) An internal request asked to add a hash entry to something that
wasn't a symbol table entry.

=end original

(P) シンボルテーブルエントリではないものに、ハッシュエントリを
登録するような内部要求があがった。

=item Bareword found in conditional

=begin original

(W bareword) The compiler found a bareword where it expected a
conditional, which often indicates that an || or && was parsed as part
of the last argument of the previous construct, for example:

=end original

(W bareword) コンパイラが、条件が想定される位置に裸の単語を発見しました。
これはしばしば、|| や && が直前の構造の最後の引数の一部として
パースされたことを意味します; 例えば:

    open FOO || die;

=begin original

It may also indicate a misspelled constant that has been interpreted as
a bareword:

=end original

これはまた、裸の単語として解釈されるような定数をタイプミスしたことを
示している場合もあります:

    use constant TYPO => 1;
    if (TYOP) { print "foo" }

=begin original

The C<strict> pragma is useful in avoiding such errors.

=end original

C<strict> プラグマはこのようなエラーを防ぐのに便利です。

=item Bareword "%s" not allowed while "strict subs" in use

=begin original

(F) With "strict subs" in use, a bareword is only allowed as a
subroutine identifier, in curly brackets or to the left of the "=>"
symbol.  Perhaps you need to predeclare a subroutine?

=end original

"strict subs" が有効の場合、裸の単語はサブルーチンの識別子、
中かっこの中、シンボル "=>" の左側でのみ許されます。
おそらくサブルーチンを先行宣言する必要があるのでは?

=item Bareword "%s" refers to nonexistent package

=begin original

(W bareword) You used a qualified bareword of the form C<Foo::>, but the
compiler saw no other uses of that namespace before that point.  Perhaps
you need to predeclare a package?

=end original

(W bareword) C<Foo::> の形で修飾された裸の単語が使われていますが、
コンパイラはこの場所以外でこの名前空間が使われている場所を
発見できませんでした。
おそらくパッケージを専攻宣言する必要があるのでは?

=item BEGIN failed--compilation aborted

=begin original

(F) An untrapped exception was raised while executing a BEGIN
subroutine.  Compilation stops immediately and the interpreter is
exited.

=end original

(F) BEGIN サブルーティンの実行中にトラップ不可能な例外が発生しました。
コンパイルは即座に停止し、インタプリタは中止します。

=item BEGIN not safe after errors--compilation aborted

=begin original

(F) Perl found a C<BEGIN {}> subroutine (or a C<use> directive, which
implies a C<BEGIN {}>) after one or more compilation errors had already
occurred.  Since the intended environment for the C<BEGIN {}> could not
be guaranteed (due to the errors), and since subsequent code likely
depends on its correct operation, Perl just gave up.

=end original

(F) Perl は既にコンパイルエラーが発生した後に C<BEGIN {}> サブルーチン
(または C<use> 指示子(これは C<BEGIN {}> を暗示します))を
発見しました。
C<BEGIN {}> が意図した環境は(エラーのために)保証されず、
引き続くコードは正しい処理に依存していると考えられるので、
Perl は単に諦めました。

=item \1 better written as $1

=begin original

(W syntax) Outside of patterns, backreferences live on as variables.
The use of backslashes is grandfathered on the right-hand side of a
substitution, but stylistically it's better to use the variable form
because other Perl programmers will expect it, and it works better if
there are more than 9 backreferences.

=end original

(W syntax) パターンの外では、後方参照は変数の形で存在します。
後方参照の利用は、置換の右側の部分で扱われますが、スタイル的には、
他の Perl プログラマが期待し、9 個以上の後方参照があるときにも
うまく動作する、変数形式を使う方が良いでしょう。

=item Binary number > 0b11111111111111111111111111111111 non-portable

=begin original

(W portable) The binary number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=end original

(W portable) 指定された 2 進数が 2**32-1 (4294967295) を越えるので、
システム間での移植性がありません。
移植性に関するさらなる考察については L<perlport> を参照してください。

=item bind() on closed socket %s

=begin original

(W closed) You tried to do a bind on a closed socket.  Did you forget to
check the return value of your socket() call?  See L<perlfunc/bind>.

=end original

(W closed) クローズされたソケットに bind を行なおうとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか。
L<perlfunc/bind> を参照してください。

=item Bit vector size > 32 non-portable

=begin original

(W portable) Using bit vector sizes larger than 32 is non-portable.

=end original

(W portable) 32 を越えるサイズのビットベクタは移植性がありません。

=item Bizarre copy of %s in %s

=begin original

(P) Perl detected an attempt to copy an internal value that is not
copyable.

=end original

(P) コピーできない内部の値をコピーしようとしました。

=item B<-P> not allowed for setuid/setgid script

=begin original

(F) The script would have to be opened by the C preprocessor by name,
which provides a race condition that breaks security.

=end original

(F) C プリプロセッサがスクリプトをオープンするときには、
名前でオープンしなければいけませんが、これは、安全性を損なう競合条件を
もたらします。

=item Buffer overflow in prime_env_iter: %s

=begin original

(W internal) A warning peculiar to VMS.  While Perl was preparing to
iterate over %ENV, it encountered a logical name or symbol definition
which was too long, so it was truncated to the string shown.

=end original

(W) VMS 特有の警告です。
Perl が %ENV を反復する準備中、長すぎる論理名かシンボル定義に
遭遇したので、文字列は表示したように切り詰められました。

=item Callback called exit

=begin original

(F) A subroutine invoked from an external package via call_sv()
exited by calling exit.

=end original

(F) 外部パッケージから call_sv() で起動されたサブルーティンが exit を
呼んで終了しました。

=item %s() called too early to check prototype

=begin original

(W prototype) You've called a function that has a prototype before the
parser saw a definition or declaration for it, and Perl could not check
that the call conforms to the prototype.  You need to either add an
early prototype declaration for the subroutine in question, or move the
subroutine definition ahead of the call to get proper prototype
checking.  Alternatively, if you are certain that you're calling the
function correctly, you may put an ampersand before the name to avoid
the warning.  See L<perlsub>.

=end original

(W prototype) 以前にパーサが宣言または定義されているのを見た、
プロトタイプ付きの関数を呼び出しましたが、Perl は呼び出しがプロトタイプに
従っているかどうかをチェックできませんでした。
問題になっているサブルーチンのプロトタイプ宣言を最初の方に追加するか、
適切なプロトタイプチェックを行うためにサブルーチン定義を呼び出しの前に
移動させる必要があります。
または、関数を正しく呼び出していることが確かな場合は、名前の前に
アンパサンドを付けることで警告を回避できます。
L<perlsub> を参照してください。

=item / cannot take a count

=begin original

(F) You had an unpack template indicating a counted-length string, but
you have also specified an explicit size for the string.  See
L<perlfunc/pack>.

=end original

(F) unpack のテンプレートとしてカウント長文字列を示していますが、
文字列の長さも明示的に指定しています。
L<perlfunc/pack> を参照してください。

=item Can't bless non-reference value

=begin original

(F) Only hard references may be blessed.  This is how Perl "enforces"
encapsulation of objects.  See L<perlobj>.

=end original

(F) ハードリファレンスのみが bless できます。
これによって、Perl はオブジェクトのカプセル化を「強制」します。
L<perlobj> を参照してください。

=item Can't call method "%s" in empty package "%s"

=begin original

(F) You called a method correctly, and it correctly indicated a package
functioning as a class, but that package doesn't have ANYTHING defined
in it, let alone methods.  See L<perlobj>.

=end original

(F) 正しくメソッドを呼び出し、それは、クラスとして機能するパッケージを
正しく示していますが、そのパッケージには、何も定義されておらず、
メソッドだけになっています。
L<perlobj> を参照してください。

=item Can't call method "%s" on an undefined value

=begin original

(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an undefined value.  Something
like this will reproduce the error:

=end original

(F) メソッド呼び出しの文法が使われていますが、
オブジェクトリファレンスかパッケージ名であるべきところが未定義値です。
以下のように書くとエラーが再現します:

    $BADREF = undef;
    process $BADREF 1,2,3;
    $BADREF->process(1,2,3);

=item Can't call method "%s" on unblessed reference

=begin original

(F) A method call must know in what package it's supposed to run.  It
ordinarily finds this out from the object reference you supply, but you
didn't supply an object reference in this case.  A reference isn't an
object reference until it has been blessed.  See L<perlobj>.

=end original

(F) メソッド呼び出しは、自分が呼び出されたパッケージがどれであるかを
知る必要があります。　普通は、渡したオブジェクトリファレンスから
その情報を受け取りますが、この場合にはオブジェクトリファレンスが
渡されませんでした。
リファレンスは、bless されて始めて、オブジェクトリファレンスとなります。
L<perlobj> を参照してください。

=item Can't call method "%s" without a package or object reference

=begin original

(F) You used the syntax of a method call, but the slot filled by the
object reference or package name contains an expression that returns a
defined value which is neither an object reference nor a package name.
Something like this will reproduce the error:

=end original

(F) メソッド呼び出しの構文を用いましたが、オブジェクトリファレンス、
もしくはパッケージ名が書かれるべき場所に、オブジェクトリファレンスも
パッケージ名も返さない定義された式が書かれています。
(おそらく、何も書いてないかもしれません。)
以下のようなものは、エラーとなります:

    $BADREF = 42;
    process $BADREF 1,2,3;
    $BADREF->process(1,2,3);

=item Can't chdir to %s

=begin original

(F) You called C<perl -x/foo/bar>, but C</foo/bar> is not a directory
that you can chdir to, possibly because it doesn't exist.

=end original

(F) C<perl -x/foo/bar> のようにして起動したましたが、
C</foo/bar> にchdir することができません。
おそらく、存在しないのではないでしょうか。

=item Can't check filesystem of script "%s" for nosuid

=begin original

(P) For some reason you can't check the filesystem of the script for
nosuid.

=end original

(P) なぜかスクリプトが nosuid かどうかをファイルシステムから
調べることができません。

=item Can't coerce array into hash

=begin original

(F) You used an array where a hash was expected, but the array has no
information on how to map from keys to array indices.  You can do that
only with arrays that have a hash reference at index 0.

=end original

(F) ハッシュが想定される場所で配列を使っていますが、
この配列にはキーから添え字に変換するための情報がありません。
このようなことは添え字 0 にハッシュリファレンスがある配列でのみ可能です。

=item Can't coerce %s to integer in %s

=begin original

(F) Certain types of SVs, in particular real symbol table entries
(typeglobs), can't be forced to stop being what they are.  So you can't
say things like:

=end original

(F) ある種の SV、特に本物のシンボルテーブルエントリ (型グロブ) は、
1 つの型に留めておくことができません。
したがって、以下のようにすることはできません:

    *foo += 1;

=begin original

You CAN say

=end original

以下のようにはできますが:

    $foo = *foo;
    $foo += 1;

=begin original

but then $foo no longer contains a glob.

=end original

$foo にはもはやグロブは残っていません。

=item Can't coerce %s to number in %s

=begin original

(F) Certain types of SVs, in particular real symbol table entries
(typeglobs), can't be forced to stop being what they are.

=end original

(F) ある種の SV、特に本物のシンボルテーブルエントリ (型グロブ) は、
1 つの型に留めておくことができません。

=item Can't coerce %s to string in %s

=begin original

(F) Certain types of SVs, in particular real symbol table entries
(typeglobs), can't be forced to stop being what they are.

=end original

(F) ある種の SV、特に本物のシンボルテーブルエントリ (型グロブ) は、
1 つの型に留めておくことができません。

=item Can't create pipe mailbox

=begin original

(P) An error peculiar to VMS.  The process is suffering from exhausted
quotas or other plumbing problems.

=end original

(F) VMS 特有のエラーです。
プロセスはクォータを使い切ったか、その他の設備問題の影響を受けました。

=item Can't declare class for non-scalar %s in "%s"

=begin original

(S) Currently, only scalar variables can declared with a specific class
qualifier in a "my" or "our" declaration.  The semantics may be extended
for other types of variables in future.

=end original

(S) 現在のところ、スカラ変数のみが "my" や "our" 定義の中で特定の
クラス修飾子と共に定義できます。
この動作は将来には他の種類の変数に拡張されるでしょう。

=item Can't declare %s in "%s"

=begin original

(F) Only scalar, array, and hash variables may be declared as "my" or
"our" variables.  They must have ordinary identifiers as names.

=end original

(F) スカラ変数、配列変数、ハッシュ変数だけが、"my" や "our" 変数として
宣言できます。
これらは、名前として通常の識別子を持たなければなりません。

=item Can't do inplace edit: %s is not a regular file

=begin original

(S inplace) You tried to use the B<-i> switch on a special file, such as
a file in /dev, or a FIFO.  The file was ignored.

=end original

(S inplace) /dev や FIFO のような、特殊ファイルに対して、B<-i> スイッチを
使おうとしました。
そのファイルは、無視されました。

=item Can't do inplace edit on %s: %s

=begin original

(S inplace) The creation of the new file failed for the indicated
reason.

=end original

(S inplace) 表示された理由により、新しいファイルの生成に失敗しました。

=item Can't do inplace edit without backup

=begin original

(F) You're on a system such as MS-DOS that gets confused if you try
reading from a deleted (but still opened) file.  You have to say
C<-i.bak>, or some such.

=end original

(F) 削除した (が、まだオープンされている) ファイルを読もうとすると
おかしくなる MS-DOS のようなシステムで実行しています。
C<-i.bak> のようにバックアップを指定してください。

=item Can't do inplace edit: %s would not be unique

=begin original

(S inplace) Your filesystem does not support filenames longer than 14
characters and Perl was unable to create a unique filename during
inplace editing with the B<-i> switch.  The file was ignored.

=end original

(S inplace) ファイルシステムが 14 文字より長いファイル名に対応しておらず、
Perl は B<-i> オプションによるその場編集の間のユニークなファイル名の
作成ができませんでした。
このファイルは無視されます。

=item Can't do {n,m} with n > m before << HERE in regex m/%s/

=begin original

(F) Minima must be less than or equal to maxima. If you really want your
regexp to match something 0 times, just put {0}. The << HERE shows in the
regular expression about where the problem was discovered. See L<perlre>.

=end original

(F) 最小値は最大値以下でなければなりません。
もし、本当に正規表現が 0 回繰り返したものにマッチさせたいなら、単に
{0} としてください。
<< HERE で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Can't do setegid!

=begin original

(P) The setegid() call failed for some reason in the setuid emulator of
suidperl.

=end original

(P) suidperl の setuid エミュレータで何らかの理由により、
setegid() 呼び出しが失敗しました。

=item Can't do seteuid!

=begin original

(P) The setuid emulator of suidperl failed for some reason.

=end original

(P) suidperl の setuid エミュレータが何らかの理由によって失敗しました。

=item Can't do setuid

=begin original

(F) This typically means that ordinary perl tried to exec suidperl to do
setuid emulation, but couldn't exec it.  It looks for a name of the form
sperl5.000 in the same directory that the perl executable resides under
the name perl5.000, typically /usr/local/bin on Unix machines.  If the
file is there, check the execute permissions.  If it isn't, ask your
sysadmin why he and/or she removed it.

=end original

(F) このエラーは、通常、普通の perl が setuid エミュレーションのために
suidperl を実行しようとしましたが、実行できなかったことを意味します。
特に UNIX マシンの /usr/local/bin などでは、perl の実行ファイルが、
perl5.000 という名前のときには、同じディレクトリで sperl5.000 という形式の
名前を探します。
もし、ファイルが存在していれば、実行パーミッションをチェックしてください。
許可されていないようであれば、システム管理者の方に、わけを
尋ねてみてください。

=item Can't do waitpid with flags

=begin original

(F) This machine doesn't have either waitpid() or wait4(), so only
waitpid() without flags is emulated.

=end original

(F) このマシンには、waitpid() も wait4() もありませんので、
フラグの無い waitpid() のみがエミュレート可能です。

=item Can't emulate -%s on #! line

=begin original

(F) The #! line specifies a switch that doesn't make sense at this
point.  For example, it'd be kind of silly to put a B<-x> on the #!
line.

=end original

(F) #! 行にその時点で意味をなさないスイッチが指定されました。
たとえば、#! 行に B<-x> をおいても意味がありません。

=item Can't exec "%s": %s

=begin original

(W exec) An system(), exec(), or piped open call could not execute the
named program for the indicated reason.  Typical reasons include: the
permissions were wrong on the file, the file wasn't found in
C<$ENV{PATH}>, the executable in question was compiled for another
architecture, or the #! line in a script points to an interpreter that
can't be run for similar reasons.  (Or maybe your system doesn't support
#! at all.)

=end original

(W exec) 提示した理由によって、system() や exec() やパイプオープン
呼び出しの指定されたプログラムが実行できませんでした。
考えられる理由には: ファイルのパーミッションが間違っている、
ファイルが C<$ENV{PATH}> の中にない、問題の実行ファイルが
このマシン用ではない、スクリプトの #! 行が同じような理由で実行できない
インタプリタを指している、というようなものがあります。
(あるいは、このシステムで、#! がサポートされていません。)

=item Can't exec %s

=begin original

(F) Perl was trying to execute the indicated program for you because
that's what the #! line said.  If that's not what you wanted, you may
need to mention "perl" on the #! line somewhere.

=end original

(F) #! 行に書かれた内容にしたがって、Perl は示されたプログラムを
実行しようとしました。
そうしたくないのであれば、#! 行のどこかに、"perl" と書いておいてください。

=item Can't execute %s

=begin original

(F) You used the B<-S> switch, but the copies of the script to execute
found in the PATH did not have correct permissions.

=end original

(F) B<-S> スイッチを使いましたが、PATH に見つかった実行するスクリプトが
正しいパーミッションではありませんでした。

=item Can't find an opnumber for "%s"

=begin original

(F) A string of a form C<CORE::word> was given to prototype(), but there
is no builtin with the name C<word>.

=end original

(F) C<CORE::word> の形の文字列が prototype() に与えられましたが、
名前 C<word> は組み込みではありません。

=item Can't find label %s

=begin original

(F) You said to goto a label that isn't mentioned anywhere that it's
possible for us to go to.  See L<perlfunc/goto>.

=end original

(F) どこにも見つからないラベルへ goto を行なおうとしました。
L<perlfunc/goto> を参照してください。

=item Can't find %s on PATH

=begin original

(F) You used the B<-S> switch, but the script to execute could not be
found in the PATH.

=end original

B<-S> オプションを使いましたが、実行するスクリプトは PATH に
見つかりませんでした。

=item Can't find %s on PATH, '.' not in PATH

=begin original

(F) You used the B<-S> switch, but the script to execute could not be
found in the PATH, or at least not with the correct permissions.  The
script exists in the current directory, but PATH prohibits running it.

=end original

(F) B<-S> オプションが使われましたが、 PATH に実行するスクリプトが
見つかりません。あるいは少なくとも適切なパーミッションがありません。
スクリプトはカレントディレクトリにはありますが、PATH に
カレントディレクトリは含まれていません。

=item Can't find string terminator %s anywhere before EOF

=begin original

(F) Perl strings can stretch over multiple lines.  This message means
that the closing delimiter was omitted.  Because bracketed quotes count
nesting levels, the following is missing its final parenthesis:

=end original

(F) Perl の文字列は、複数行に渡ることができます。このメッセージは、
文字列を終わる区切り文字が見つからなかったことを意味します。
括弧類の区切り文字では、ネストを数えるので、以下では、最後の括弧が
無いと言われます:

    print q(The character '(' starts a side comment.);

=begin original

If you're getting this error from a here-document, you may have included
unseen whitespace before or after your closing tag. A good programmer's
editor will have a way to help you find these characters.

=end original

このエラーがヒアドキュメントで起きた場合、閉じタグの前か後に
見えない空白を含んでいるかもしれません。
よいプログラマ用エディタには、このような文字を探す助けになる方法が
あります。

=item Can't find %s property definition %s 

=begin original

(F) You may have tried to use C<\p> which means a Unicode property for
example \p{Lu} is all uppercase letters.  Escape the C<\p>, either
C<\\p> (just the C<\p>) or by C<\Q\p> (the rest of the string, until
possible C<\E>).

=end original

(F) 例えば \p{Lu} が全て大文字、のように、Unicode プロパティを意味する
C<\p> を使おうとしました。
C<\\p> (単に C<\p>) または C<\Q\p> (C<\E> までの残りの文字列) を使って
C<\p> をエスケープしてください。

=item Can't fork

=begin original

(F) A fatal error occurred while trying to fork while opening a
pipeline.

=end original

(F) パイプラインをオープンしようとして、fork を行なおうとして、
致命的エラーが発生しました。

=item Can't get filespec - stale stat buffer?

=begin original

(S) A warning peculiar to VMS.  This arises because of the difference
between access checks under VMS and under the Unix model Perl assumes.
Under VMS, access checks are done by filename, rather than by bits in
the stat buffer, so that ACLs and other protections can be taken into
account.  Unfortunately, Perl assumes that the stat buffer contains all
the necessary information, and passes it, instead of the filespec, to
the access checking routine.  It will try to retrieve the filespec using
the device name and FID present in the stat buffer, but this works only
if you haven't made a subsequent call to the CRTL stat() routine,
because the device name is overwritten with each call.  If this warning
appears, the name lookup failed, and the access checking routine gave up
and returned FALSE, just to be conservative.  (Note: The access checking
routine knows about the Perl C<stat> operator and file tests, so you
shouldn't ever see this warning in response to a Perl command; it arises
only if some internal code takes stat buffers lightly.)

=end original

(S) VMS 特有の警告です。
これは VMS と、Perl が仮定している Unix モデルでは、アクセスチェックに違いが
あることによって起こります。
VMS では、アクセスチェックは stat バッファのビットではなくファイル名によって
行われるので、ACL やその他の保護が考慮されます。
残念ながら、Perl は stat バッファに全ての必要な情報が含まれていると仮定して、
アクセスチェックルーチンにはファイルスペックではなくこれを渡します。
stat バッファにあるデバイス名と FID を使ってファイルスペックを
取得しようとしますが、これは引き続いて CRTL stat() ルーチンを呼び出さない
場合にのみ動作します; なぜならデバイス名は呼出し毎に上書きされるからです。
この警告が出ると、名前の検索が失敗し、アクセスチェックルーチンは諦めて、
安全のためだけに FALSE を返します。
(注意: アクセスチェックルーチンは Perl の C<stat> 演算子とファイル
テストについて知っているので、Perl コマンドの結果としてこの警告を見ることは
ないはずです; これは内部コートが stat バッファを軽率に扱った場合にのみ
発生します。)

=item Can't get pipe mailbox device name

=begin original

(P) An error peculiar to VMS.  After creating a mailbox to act as a
pipe, Perl can't retrieve its name for later use.

=end original

(F) VMS 特有のエラーです。
パイプとして働くメールボックスの作成後、後で使うための名前を
Perl が取得できませんでした。

=item Can't get SYSGEN parameter value for MAXBUF

=begin original

(P) An error peculiar to VMS.  Perl asked $GETSYI how big you want your
mailbox buffers to be, and didn't get an answer.

=end original

(F) VMS 特有のエラーです。
メールボックスバッファをどれくらいとるべきかを $GETSYI に
問い合わせましたが、答えが得られませんでした。

=item Can't "goto" into the middle of a foreach loop

=begin original

(F) A "goto" statement was executed to jump into the middle of a foreach
loop.  You can't get there from here.  See L<perlfunc/goto>.

=end original

(F) "goto" 文で foreach ループの中に飛び込もうとしました。
ここからそこへは行けません。
L<perlfunc/goto> を参照してください。

=item Can't "goto" out of a pseudo block

=begin original

(F) A "goto" statement was executed to jump out of what might look like
a block, except that it isn't a proper block.  This usually occurs if
you tried to jump out of a sort() block or subroutine, which is a no-no.
See L<perlfunc/goto>.

=end original

(F) "goto" 文でブロックのように見えるけれども、適切な
ブロックではないところから飛び出そうとしました。
これは普通 sort() ブロックやサブルーチンから飛び出そうとしたときに
起きますが、それはできません。
L<perlfunc/goto> を参照してください。

=item Can't goto subroutine from an eval-string

=begin original

(F) The "goto subroutine" call can't be used to jump out of an eval
"string".  (You can use it to jump out of an eval {BLOCK}, but you
probably don't want to.)

=end original

(F) "goto subroutine" 呼び出しは eval "string" から飛び出すことは
できません。
(eval {BLOCK} から飛び出すことはできますが、多分そうしたくはないでしょう。)

=item Can't goto subroutine outside a subroutine

=begin original

(F) The deeply magical "goto subroutine" call can only replace one
subroutine call for another.  It can't manufacture one out of whole
cloth.  In general you should be calling it out of only an AUTOLOAD
routine anyway.  See L<perlfunc/goto>.

=end original

(F) 結構マジカルな "goto subroutine" の呼び出しは、あるサブルーティン
呼び出しを別のもので置き換えるだけです。
反物の状態から作り上げることはできません。
一般に、これを行なうのは、AUTOLOAD ルーティンから抜け出すときだけに
しておくべきです。
L<perlfunc/goto> の項を参照してください。

=item Can't ignore signal CHLD, forcing to default

=begin original

(W signal) Perl has detected that it is being run with the SIGCHLD
signal (sometimes known as SIGCLD) disabled.  Since disabling this
signal will interfere with proper determination of exit status of child
processes, Perl has reset the signal to its default value.  This
situation typically indicates that the parent program under which Perl
may be running (e.g. cron) is being very careless.

=end original

(W signal) Perl は、SIGCHLD (SIGCLD としても知られます) シグナルが
無効化された状態で実行されていることを検出しました。
このシグナルが無効化されると子プロセスの終了ステータスを適切に
決定できなくなるので、Perl はシグナルをデフォルト値にリセットしました。
この状況は典型的には Perl が動作している親プログラム(cron など)が
とても不注意であることを示しています。

=item Can't "last" outside a loop block

=begin original

(F) A "last" statement was executed to break out of the current block,
except that there's this itty bitty problem called there isn't a current
block.  Note that an "if" or "else" block doesn't count as a "loopish"
block, as doesn't a block given to sort(), map() or grep().  You can
usually double the curlies to get the same effect though, because the
inner curlies will be considered a block that loops once.  See
L<perlfunc/last>.

=end original

(F) 現在のブロックから脱出するために、"last" 文を実行しましたが、
残念なことにブロックの中ではありませんでした。
"if" や "else" のブロックは、sort(), map(), grep() のブロックが違うのと
同様「ループ風」ブロックではないので、注意してください。
ただし、中括弧を二重にすれば、内側の中括弧が、1 度だけループするブロックと
みなされますから、同じ効果が得られます。
L<perlfunc/last> を参照してください。

=item Can't localize lexical variable %s

=begin original

(F) You used local on a variable name that was previously declared as a
lexical variable using "my".  This is not allowed.  If you want to
localize a package variable of the same name, qualify it with the
package name.

=end original

(F) 以前に "my" を使ってレキシカル変数として宣言された変数名に対して
local を使いました。
これは認められていません。
同じ名前のパッケージ変数をローカル化したい場合は、
パッケージ名で修飾してください。

=item Can't localize pseudo-hash element

=begin original

(F) You said something like C<< local $ar->{'key'} >>, where $ar is a
reference to a pseudo-hash.  That hasn't been implemented yet, but you
can get a similar effect by localizing the corresponding array element
directly -- C<< local $ar->[$ar->[0]{'key'}] >>.

=end original

(F) $ar が擬似ハッシュへのリファレンスのとき、C<< local $ar->{'key'} >> の
ようなことをしました。
これはまだ実装されていませんが、対応する配列要素を直接ローカル化することで
似たような効果が得られます -- C<< local $ar->[$ar->[0]{'key'}] >>。

=item Can't localize through a reference

=begin original

(F) You said something like C<local $$ref>, which Perl can't currently
handle, because when it goes to restore the old value of whatever $ref
pointed to after the scope of the local() is finished, it can't be sure
that $ref will still be a reference.  

=end original

(F) C<local $$ref> のようなことをしましたが、Perl は現在のところこれを
扱えません; なぜなら、local() のスコープが終了した後、$ref が
指しているものの古い値を戻すとき、$ref がまだリファレンスかどうかが
わからないからです。

=item Can't locate %s

=begin original

(F) You said to C<do> (or C<require>, or C<use>) a file that couldn't be
found. Perl looks for the file in all the locations mentioned in @INC,
unless the file name included the full path to the file.  Perhaps you
need to set the PERL5LIB or PERL5OPT environment variable to say where
the extra library is, or maybe the script needs to add the library name
to @INC.  Or maybe you just misspelled the name of the file.  See
L<perlfunc/require> and L<lib>.

=end original

(F) ファイルを C<do> (または、C<require>、C<use>) するように
指示されましたが、見つかりませんでした。
Perl は、フルパスで指定されていない場合ファイルを @INC で示される
全ての場所を検索します。
おそらく、追加ライブラリの場所を示すために、
PERL5LIB または PERL5OPT の環境変数を指定する必要があるか、
スクリプトの中で @INC にライブラリ名を追加する必要があります。
ファイル名のスペルミスの可能性もあります。
L<perlfunc/require> と L<lib> を参照してください。

=item Can't locate auto/%s.al in @INC

=begin original

(F) A function (or method) was called in a package which allows
autoload, but there is no function to autoload.  Most probable causes
are a misprint in a function/method name or a failure to C<AutoSplit>
the file, say, by doing C<make install>.

=end original

(F) 関数(またはメソッド)がオートロードを許可しているパッケージで
呼び出されましたが、オートロードする関数がありませんでした。
最も可能性のある原因は関数/メソッド名の誤記か、C<make install> と
することによるファイルの C<AutoSplit> の失敗です。

=item Can't locate object method "%s" via package "%s"

=begin original

(F) You called a method correctly, and it correctly indicated a package
functioning as a class, but that package doesn't define that particular
method, nor does any of its base classes.  See L<perlobj>.

=end original

(F) 正しくメソッドを呼び出し、それは、クラスとして機能するパッケージを
正しく示していますが、そのパッケージにも、基底クラスにも、
該当のメソッドが定義されていません。
L<perlobj> を参照してください。

=item (perhaps you forgot to load "%s"?)

=begin original

(F) This is an educated guess made in conjunction with the message
"Can't locate object method \"%s\" via package \"%s\"".  It often means
that a method requires a package that has not been loaded.

=end original

(F) これは "Can't locate object method \"%s\" via package \"%s\"" の
メッセージと共に出る教育的な推測です。
これはしばしばメソッドがまだロードされていないパッケージを
要求していることを意味します。

=item Can't locate package %s for @%s::ISA

=begin original

(W syntax) The @ISA array contained the name of another package that
doesn't seem to exist.

=end original

(W syntax) 配列 @ISA に別のパッケージ名が記されていますが、
存在していないようです。

=item Can't make list assignment to \%ENV on this system

=begin original

(F) List assignment to %ENV is not supported on some systems, notably
VMS.

=end original

(F) %ENV へのリスト代入はいくつかのシステム、特に VMS では
対応していません。

=item Can't modify %s in %s

=begin original

(F) You aren't allowed to assign to the item indicated, or otherwise try
to change it, such as with an auto-increment.

=end original

(F) 指定されたものは、代入、インクリメントなど、変更が許されていません。

=item Can't modify nonexistent substring

=begin original

(P) The internal routine that does assignment to a substr() was handed
a NULL.

=end original

(P) substr() への代入を行なう内部ルーティンに NULL が渡されました。

=item Can't modify non-lvalue subroutine call

=begin original

(F) Subroutines meant to be used in lvalue context should be declared as
such, see L<perlsub/"Lvalue subroutines">.

=end original

(F) 左辺値コンテキストとして使うサブルーチンは、そのように
宣言しなければなりません;
L<perlsub/"Lvalue subroutines"> を参照してください。

=item Can't msgrcv to read-only var

=begin original

(F) The target of a msgrcv must be modifiable to be used as a receive
buffer.

=end original

(F) msgrcv で使用する変数は、受信バッファとして使用しますので、
変更可能なものでなければなりません。

=item Can't "next" outside a loop block

=begin original

(F) A "next" statement was executed to reiterate the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map() or
grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that loops
once.  See L<perlfunc/next>.

=end original

(F) 現在のブロックの繰り返しを進めるために、"next" 文を実行しましたが、
ブロックの中ではありませんでした。
"if" や "else" のブロックは、sort(), map(), grep() のブロックが違うのと
同様「ループ風」ブロックではないので、注意してください。
ただし、中括弧を二重にすれば、内側の中括弧が、1 度だけループするブロックと
みなされますから、同じ効果が得られます。
L<perlfunc/next> を参照してください。

=item Can't open %s: %s

=begin original

(S inplace) The implicit opening of a file through use of the C<< <> >>
filehandle, either implicitly under the C<-n> or C<-p> command-line
switches, or explicitly, failed for the indicated reason.  Usually this
is because you don't have read permission for a file which you named on
the command line.

=end original

(S inplace) C<< <> >> ファイルハンドルによる暗黙的なファイルオープンまたは
C<-n> か C<-p> コマンドラインスイッチによる暗黙的な、あるいは
明示的なファイルオープンが表示した理由によって失敗しました。
通常、これはコマンドラインで指定したファイルの読み込み権限が無いときに起こります。

=item Can't open bidirectional pipe

=begin original

(W pipe) You tried to say C<open(CMD, "|cmd|")>, which is not supported.
You can try any of several modules in the Perl library to do this, such
as IPC::Open2.  Alternately, direct the pipe's output to a file using
">", and then read it in under a different file handle.

=end original

(W pipe) サポートされていない C<open(CMD, "|cmd|")> を行なおうとしました。
これを行なうためには、Perl ライブラリの IPC::Open2 のようないくつかの
モジュールを使うことができます。
別の方法として、パイプされたものを ">" を使っていったんファイルに出力し、
あとで別のファイルハンドルで読み込みを行なうことも考えられます。

=item Can't open error file %s as stderr

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '2>' or '2>>' on
the command line for writing.

=end original

(F) VMSに固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインで書き込みのために '2>' や '2>>' の後に指定された
ファイルを開けませんでした。

=item Can't open input file %s as stdin

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '<' on the
command line for reading.

=end original

(F) VMSに固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインで読み込みのために '<' の後に指定された
ファイルを開けませんでした。

=item Can't open output file %s as stdout

=begin original

(F) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the file specified after '>' or '>>' on
the command line for writing.

=end original

(F) VMSに固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインで書き込みのために '>' や '>>' の後に指定された
ファイルを開けませんでした。

=item Can't open output pipe (name: %s)

=begin original

(P) An error peculiar to VMS.  Perl does its own command line
redirection, and couldn't open the pipe into which to send data destined
for stdout.

=end original

(P) VMSに固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
標準出力としてデータを送るパイプを開けませんでした。

=item Can't open perl script "%s": %s

=begin original

(F) The script you specified can't be opened for the indicated reason.

=end original

(F) 指定したスクリプトが、表示した理由によってオープンできませんでした。

=item Can't read CRTL environ

=begin original

(S) A warning peculiar to VMS.  Perl tried to read an element of %ENV
from the CRTL's internal environment array and discovered the array was
missing.  You need to figure out where your CRTL misplaced its environ
or define F<PERL_ENV_TABLES> (see L<perlvms>) so that environ is not
searched.

=end original

(S) VMSに固有の警告です。
Perl は %ENV の要素を CRTL の内部環境配列から読み込もうとしましたが、
配列がないことを発見しました。
CRTL が環境をどこに間違えて置いたかを探し出すか、F<PERL_ENV_TABLE> を
定義して(L<perlvms> を参照してください)環境を検索しないようにする
必要があります。

=item Can't redefine active sort subroutine %s

=begin original

(F) Perl optimizes the internal handling of sort subroutines and keeps
pointers into them.  You tried to redefine one such sort subroutine when
it was currently active, which is not allowed.  If you really want to do
this, you should write C<sort { &func } @x> instead of C<sort func @x>.

=end original

(F) Perl はソートサブルーチンの内部操作を最適化して、
そこへのポインタを保持しています。
そのようなソートサブルーチンを現在アクティブな状態の時に
再定義しようとしましたが、それはできません。
本当にそのようなことがしたい場合は、
C<sort func @x> ではなく C<sort { &func } @x> と書くべきです。

=item Can't "redo" outside a loop block

=begin original

(F) A "redo" statement was executed to restart the current block, but
there isn't a current block.  Note that an "if" or "else" block doesn't
count as a "loopish" block, as doesn't a block given to sort(), map()
or grep().  You can usually double the curlies to get the same effect
though, because the inner curlies will be considered a block that
loops once.  See L<perlfunc/redo>.

=end original

(F) 現在のブロックの繰り返しをもう一度行なうために、
"redo" 文を実行しましたが、ブロックの中ではありませんでした。
"if" や "else" のブロックは、sort(), map(), grep() のブロックが違うのと
同様「ループ風」ブロックではないので、注意してください。
ただし、中括弧を二重にすれば、内側の中括弧が、1 度だけループする
ブロックとみなされますから、同じ効果が得られます。
L<perlfunc/redo> を参照してください。

=item Can't remove %s: %s, skipping file 

=begin original

(S inplace) You requested an inplace edit without creating a backup
file.  Perl was unable to remove the original file to replace it with
the modified file.  The file was left unmodified.

=end original

(S inplace) バックアップを作成せずにその場編集することを要求しました。
Perl は変更したファイルで置き換えるために元のファイルを削除することが
できませんでした。
ファイルは変更されずに残されます。

=item Can't rename %s to %s: %s, skipping file

=begin original

(S inplace) The rename done by the B<-i> switch failed for some reason,
probably because you don't have write permission to the directory.

=end original

(S inplace) B<-i> スイッチで行なわれた rename が何らかの理由によって、
うまく行きませんでした。
ディレクトリに書き込み権がないことも考えられます。

=item Can't reopen input pipe (name: %s) in binary mode

=begin original

(P) An error peculiar to VMS.  Perl thought stdin was a pipe, and tried
to reopen it to accept binary data.  Alas, it failed.

=end original

(P) VMS に固有のエラーです。
Perl は標準入力がパイプであると考えて、バイナリデータを受け入れるために
再オープンしようとしました。
悲しいかな、それは失敗しました。

=item Can't resolve method `%s' overloading `%s' in package `%s'

=begin original

(F|P) Error resolving overloading specified by a method name (as opposed
to a subroutine reference): no such method callable via the package. If
method name is C<???>, this is an internal error.

=end original

(F|P) (サブルーチンのリファレンスではなく)メソッド名で指定された
オーバーロードの解決でのエラー: そのようなメソッドはパッケージ経由で
呼び出せません。
もしメソッド名が C<???> なら、内部エラーです。

=item Can't reswap uid and euid

=begin original

(P) The setreuid() call failed for some reason in the setuid emulator of
suidperl.

=end original

(P) suidperl の setuid エミュレータで何らかの理由により、
setreuid() 呼び出しが失敗しました。

=item Can't return %s from lvalue subroutine

=begin original

(F) Perl detected an attempt to return illegal lvalues (such as
temporary or readonly values) from a subroutine used as an lvalue.  This
is not allowed.

=end original

(F) Perl が、左辺値として使われるサブルーチンから(一時的や
読み込み専用のような)不正な左辺値が返されようとしているのを
検出しました。
これはできません。

=item Can't return %s to lvalue scalar context

=begin original

(F) You tried to return a complete array or hash from an lvalue subroutine,
but you called the subroutine in a way that made Perl think you meant
to return only one value. You probably meant to write parentheses around
the call to the subroutine, which tell Perl that the call should be in
list context.

=end original

(F) 左辺値サブルーチンから配列やハッシュ全体を返そうとしましたが、
一つだけの値を返そうとしていると Perl が考えるような方法でサブルーチンを
呼び出しました。
おそらく、Perl にこの呼び出しがリストコンテキストであると伝えるために、
サブルーチン呼び出しの周りにかっこを書いているのでしょう。

=item Can't return outside a subroutine

=begin original

(F) The return statement was executed in mainline code, that is, where
there was no subroutine call to return out of.  See L<perlsub>.

=end original

(F) return 文が、return で抜けるべきサブルーティンがない、
"main" コードで実行されました。
L<perlsub> を参照してください。

=item Can't stat script "%s"

=begin original

(P) For some reason you can't fstat() the script even though you have it
open already.  Bizarre.

=end original

(P) 何らかの理由で、例え既にオープンしていたとしても、fstat() が
行なえません。困ったもんだ。

=item Can't swap uid and euid

=begin original

(P) The setreuid() call failed for some reason in the setuid emulator of
suidperl.

=end original

(P) suidperl の setuid エミュレータで何らかの理由により、
setreuid() 呼び出しが失敗しました。

=item Can't take log of %g

=begin original

(F) For ordinary real numbers, you can't take the logarithm of a
negative number or zero. There's a Math::Complex package that comes
standard with Perl, though, if you really want to do that for the
negative numbers.

=end original

(F) 実数に対しては、負数や 0 に対する対数を取ることはできません。
しかし、もし本当に負数に対してそのようなことをしたいのなら、
Perl 標準になっている Math::Complex パッケージがあります。

=item Can't take sqrt of %g

=begin original

(F) For ordinary real numbers, you can't take the square root of a
negative number.  There's a Math::Complex package that comes standard
with Perl, though, if you really want to do that.

=end original

(F) 通常の実数では、負数の平方根をとることはできません。
しかし、本当にその計算を行ないたいのであれば、Math::Complex パッケージが
Perl に標準で用意されています。

=item Can't undef active subroutine

=begin original

(F) You can't undefine a routine that's currently running.  You can,
however, redefine it while it's running, and you can even undef the
redefined subroutine while the old routine is running.  Go figure.

=end original

(F) 実行中のルーティンを未定義にすることはできません。
しかし、実行中に再定義することはでき、古いルーティンを実行中に、
再定義したサブルーティンを undef することさえできます。
驚きです。

=item Can't unshift

=begin original

(F) You tried to unshift an "unreal" array that can't be unshifted, such
as the main Perl stack.

=end original

(F) Perl のメインスタックのように、unshift することのできない
「実在しない」配列に対して、unshift を行なおうとしました。

=item Can't upgrade that kind of scalar

=begin original

(P) The internal sv_upgrade routine adds "members" to an SV, making it
into a more specialized kind of SV.  The top several SV types are so
specialized, however, that they cannot be interconverted.  This message
indicates that such a conversion was attempted.

=end original

(P) 内部の sv_upgrade ルーティンは、SV に「メンバ」を加えて、
より特別な種類の SV にします。　しかし、上位のいくつかの SV 型は、
特殊化され過ぎて、内部変換することができません。
このメッセージは、そのような変更を行なおうとしたことを示しています。

=item Can't upgrade to undef

=begin original

(P) The undefined SV is the bottom of the totem pole, in the scheme of
upgradability.  Upgrading to undef indicates an error in the code
calling sv_upgrade.

=end original

(P) 未定義 SV は、upgrade の仕組みにおいて、階層構造の最下位に
位置するものです。
undef への upgrade は、sv_upgrade を呼ぶコードのエラーを示します。

=item Can't use an undefined value as %s reference

=begin original

(F) A value used as either a hard reference or a symbolic reference must
be a defined value.  This helps to delurk some insidious errors.

=end original

(F) ハードリファレンスやシンボリックリファレンスとして使用する値は、
定義済みの値でなければなりません。
潜伏中のエラーを引きずり出す助けとなります。

=item Can't use bareword ("%s") as %s ref while "strict refs" in use

=begin original

(F) Only hard references are allowed by "strict refs".  Symbolic
references are disallowed.  See L<perlref>.

=end original

(F) "strict refs" では、ハードリファレンスだけが許されます。
シンボリックリファレンスは、許されていません。
L<perlref> を参照してください。

=item Can't use %! because Errno.pm is not available

=begin original

(F) The first time the %! hash is used, perl automatically loads the
Errno.pm module. The Errno module is expected to tie the %! hash to
provide symbolic names for C<$!> errno values.

=end original

(F) 最初に %! ハッシュが使われるときに、
perl は自動的に Errno.pm モジュールを読み込みます。
Errno モジュールは C<$!> errno 値のシンボリック名を提供するために
%! ハッシュと tie されることになります。

=item Can't use %s for loop variable

=begin original

(F) Only a simple scalar variable may be used as a loop variable on a
foreach.

=end original

(F) 単純スカラ変数だけが、foreach のループ変数として
使用することができます。

=item Can't use global %s in "my"

=begin original

(F) You tried to declare a magical variable as a lexical variable.  This
is not allowed, because the magic can be tied to only one location
(namely the global variable) and it would be incredibly confusing to
have variables in your program that looked like magical variables but
weren't.

=end original

(F) マジカル変数を、字句スコープ変数として宣言しようとしました。
これが許されていないのは、マジック変数は 1 か所だけにおくことができる
 (つまりグローバル変数) からであり、マジカル変数に見えながら、
そうでないものがプログラム中に現われると混乱の元となるためです。

=item Can't use "my %s" in sort comparison

=begin original

(F) The global variables $a and $b are reserved for sort comparisons.
You mentioned $a or $b in the same line as the <=> or cmp operator,
and the variable had earlier been declared as a lexical variable.
Either qualify the sort variable with the package name, or rename the
lexical variable.

=end original

(F) グローバル変数 $a と $b はソート比較のために予約されています。
$a か $b を <=> か cmp 演算子と同じ行に記述しましたが、その変数は
その前にレキシカル変数として宣言されています。
ソート変数をパッケージ名で修飾するか、レキシカル変数の名前を
変更してください。

=item Can't use %s ref as %s ref

=begin original

(F) You've mixed up your reference types.  You have to dereference a
reference of the type needed.  You can use the ref() function to
test the type of the reference, if need be.

=end original

(F) リファレンス型を混同しています。
必要な型のリファレンスを被参照しなければなりません。
必要ならば、リファレンスの型を調べるのに、ref() 関数を使うことができます。

=item Can't use string ("%s") as %s ref while "strict refs" in use

=begin original

(F) Only hard references are allowed by "strict refs".  Symbolic
references are disallowed.  See L<perlref>.

=end original

(F) "strict refs" によって、ハードリファレンスのみが許可されます。
シンボリックリファレンスは許可されません。
L<perlref> を参照してください。

=item Can't use subscript on %s

=begin original

(F) The compiler tried to interpret a bracketed expression as a
subscript.  But to the left of the brackets was an expression that
didn't look like an array reference, or anything else subscriptable.

=end original

(F) コンパイラが大かっこで囲われた式を添字として解釈しようとしました。
しかし、大かっこの左側はハッシュか配列のリファレンスやその他の
添字化できるもののようには見えない式です。

=item Can't use \%c to mean $%c in expression

=begin original

(W syntax) In an ordinary expression, backslash is a unary operator that
creates a reference to its argument.  The use of backslash to indicate a
backreference to a matched substring is valid only as part of a regular
expression pattern.  Trying to do this in ordinary Perl code produces a
value that prints out looking like SCALAR(0xdecaf).  Use the $1 form
instead.

=end original

(W syntax) 通常の式では、バックスラッシュは引数へのリファレンスを作る
単項演算子です。
マッチした部分文字列への後方参照を示すためのバックスラッシュの使用は
正規表現パターンの一部の場合にのみ有効です。
通常の Perl コードの中でこれをしようとすると、SCALAR(0xdecaf) のように
表示される値を生成します。
代わりに $1 の形を使ってください。

=item Can't weaken a nonreference

=begin original

(F) You attempted to weaken something that was not a reference.  Only
references can be weakened.

=end original

(F) リファレンスではない何かを弱めようとしました。
リファレンスだけが弱めることができます。

=item Can't x= to read-only value

=begin original

(F) You tried to repeat a constant value (often the undefined value)
with an assignment operator, which implies modifying the value itself.
Perhaps you need to copy the value to a temporary, and repeat that.

=end original

(F) 定数値 (未定義値であることが多い) を、自らを書き換えることを意味する、
代入演算子で繰り返しを行なおうとしました。
テンポラリ変数に値を移してから、繰り返すと良いでしょう。

=item chmod() mode argument is missing initial 0

=begin original

(W chmod) A novice will sometimes say

=end original

(W chmod) 初心者は以下のように書くことがあります:

    chmod 777, $filename

=begin original

not realizing that 777 will be interpreted as a decimal number,
equivalent to 01411.  Octal constants are introduced with a leading 0 in
Perl, as in C.

=end original

というふうに、777 が 01411 に等しい 10 進数であることに気付かないで
使うことがあります。
Perl では、8 進数の定数は、C と同じように、先頭に 0 を付けて表わします。

=item close() on unopened filehandle %s

=begin original

(W unopened) You tried to close a filehandle that was never opened.

=end original

(W unopened) オープンされていないファイルハンドルをクローズしようとしました。

=item %s: Command not found

=begin original

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item Compilation failed in require

=begin original

(F) Perl could not compile a file specified in a C<require> statement.
Perl uses this generic message when none of the errors that it
encountered were severe enough to halt compilation immediately.

=end original

(F) Perl は C<require> 文で指定されたファイルをコンパイルできませんでした。
Perl は、コンパイルを直ちに停止させるほど厳しいエラーに遭遇しなかった
ときに、この一般的なメッセージを使います。

=item Complex regular subexpression recursion limit (%d) exceeded

=begin original

(W regexp) The regular expression engine uses recursion in complex
situations where back-tracking is required.  Recursion depth is limited
to 32766, or perhaps less in architectures where the stack cannot grow
arbitrarily.  ("Simple" and "medium" situations are handled without
recursion and are not subject to a limit.)  Try shortening the string
under examination; looping in Perl code (e.g. with C<while>) rather than
in the regular expression engine; or rewriting the regular expression so
that it is simpler or backtracks less.  (See L<perlfaq2> for information
on I<Mastering Regular Expressions>.)

=end original

(W regexp) 正規表現エンジンはバックトラックが要求される複雑な状況では
再帰を使用します。
再帰の深さは 32766、またはスタックを任意に増やせないアーキテクチャでは
おそらくもっと小さい値に制限されています。
(「単純な」または「中くらいの」状況では再帰なしで扱われるので、制限は
ありません。)
調べる文字列を短くしてみてください; 正規表現エンジンではなく
(C<while> などの) Perl コードを使ってループするか、
あるいは正規表現をより単純にしたり、バックトラックが少なくなるように
書き換えてください。
(I<Mastering Regular Expressions> の情報については L<perlfaq2> を
参照してください。)

=item connect() on closed socket %s

=begin original

(W closed) You tried to do a connect on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/connect>.

=end original

(W closed) クローズされたソケットに connent を行なおうとしました。
socket() の呼び出し時に、返却値のチェックを忘れたたのではありませんか。
L<perlfunc/connect> を参照してください。

=item Constant(%s)%s: %s

=begin original

(F) The parser found inconsistencies either while attempting to define
an overloaded constant, or when trying to find the character name
specified in the C<\N{...}> escape.  Perhaps you forgot to load the
corresponding C<overload> or C<charnames> pragma?  See L<charnames> and
L<overload>.

=end original

(F) パーサは、オーバーロードされた定数を定義しようとしたときか、
C<\N{...}> エスケープで指定された文字名を探そうとしたときに
非一貫性を発見しました。
おそらく対応する C<overload> か C<charnames> のプラグマの読み込みを
忘れたのでは?
L<charnames> と L<overload> を参照してください。

=item Constant is not %s reference

=begin original

(F) A constant value (perhaps declared using the C<use constant> pragma)
is being dereferenced, but it amounts to the wrong type of reference.
The message indicates the type of reference that was expected. This
usually indicates a syntax error in dereferencing the constant value.
See L<perlsub/"Constant Functions"> and L<constant>.

=end original

(F) (おそらく C<use constant> プラグマを使って宣言した) 定数値が
デリファレンスされましたが、間違った型のリファレンスになりました。
このメッセージは想定されたリファレンスの型を示しています。
これは普通定数値をデリファレンスするときの文法エラーを示しています。
L<perlsub/"Constant Functions"> と L<constant> を参照してください。

=item Constant subroutine %s redefined

=begin original

(S|W redefine) You redefined a subroutine which had previously been
eligible for inlining.  See L<perlsub/"Constant Functions"> for
commentary and workarounds.

=end original

(S|W redefine) 以前にインライン化できる形であったサブルーチンを
再定義しました。
コメントと回避策については L<perlsub/"Constant Functions"> を
参照してください。

=item Constant subroutine %s undefined

=begin original

(W misc) You undefined a subroutine which had previously been eligible
for inlining.  See L<perlsub/"Constant Functions"> for commentary and
workarounds.

=end original

(W misc)以前にインライン化できる形であったサブルーチンを
未定義化しました。
コメントと回避策については L<perlsub/"Constant Functions"> を
参照してください。

=item Copy method did not return a reference

=begin original

(F) The method which overloads "=" is buggy. See 
L<overload/Copy Constructor>.

=end original

(F) "=" をオーバーロードしたメソッドはバグっています。
L<overload/Copy Constructor> を参照してください。

=item CORE::%s is not a keyword

=begin original

(F) The CORE:: namespace is reserved for Perl keywords.

=end original

(F) CORE:: 名前空間は Perl キーワードとして予約されています。

=item corrupted regexp pointers

=begin original

(P) The regular expression engine got confused by what the regular
expression compiler gave it.

=end original

(P) 正規表現コンパイラが渡したもので、正規表現エンジンが
処理できなくなりました。

=item corrupted regexp program

=begin original

(P) The regular expression engine got passed a regexp program without a
valid magic number.

=end original

(P) 正規表現エンジンが、有効なマジックナンバーを持たない
regexp プログラムを渡しました。

=item Corrupt malloc ptr 0x%lx at 0x%lx

=begin original

(P) The malloc package that comes with Perl had an internal failure.

=end original

(P) Perl に付属の malloc ルーティンが内部エラーを起こしました。

=item C<-p> destination: %s

=begin original

(F) An error occurred during the implicit output invoked by the C<-p>
command-line switch.  (This output goes to STDOUT unless you've
redirected it with select().)

=end original

(F) C<-p> コマンドラインオプションで起動された
暗黙の出力中にエラーが発生しました。
(この出力は select() でリダイレクトしていない限り STDOUT に出力されます。)

=item C<-T> and C<-B> not implemented on filehandles

=begin original

(F) Perl can't peek at the stdio buffer of filehandles when it doesn't
know about your kind of stdio.  You'll have to use a filename instead.

=end original

(F) Perl が、お使いの stdio のことをよく知らないとき、
ファイルハンドルの stdio バッファを覗くことはできません。
代わりにファイル名を使わなければなりません。

=item Deep recursion on subroutine "%s"

=begin original

(W recursion) This subroutine has called itself (directly or indirectly)
100 times more than it has returned.  This probably indicates an
infinite recursion, unless you're writing strange benchmark programs, in
which case it indicates something else.

=end original

(W recursion) このサブルーティンは、(直接、間接に) 自分自身の呼び出しを、
return より 100 回多く行ないました。
変わったベンチマークプログラムを書いているのでなければ、無限再帰の
可能性があります。
ベンチマークを書いている場合には、別のことを示しています。

=item defined(@array) is deprecated

=begin original

(D deprecated) defined() is not usually useful on arrays because it
checks for an undefined I<scalar> value.  If you want to see if the
array is empty, just use C<if (@array) { # not empty }> for example.  

=end original

(D deprecated) defined() は未定義の I<スカラ> 値を調べるので、配列に
使っても普通は無意味です。
配列が空かどうかを調べたい場合は、例えば単に 
C<if (@array) { # not empty }> としてください。

=item defined(%hash) is deprecated

=begin original

(D deprecated) defined() is not usually useful on hashes because it
checks for an undefined I<scalar> value.  If you want to see if the hash
is empty, just use C<if (%hash) { # not empty }> for example.  

=end original

(D deprecated) defined() は未定義の I<スカラ> 値を調べるので、ハッシュに
使っても普通は無意味です。
ハッシュが空かどうかを調べたい場合は、例えば単に 
C<if (%hash) { # not empty }> としてください。

=item Delimiter for here document is too long

=begin original

(F) In a here document construct like C<<<FOO>, the label C<FOO> is too
long for Perl to handle.  You have to be seriously twisted to write code
that triggers this error.

=end original

(F) C<<<FOO> のようなヒアドキュメント構造で、ラベル C<FOO> が
Perl が扱うには長すぎました。
このエラーを起こすようなコードを書くには相当ひねくれている必要があります。

=item Did not produce a valid header

=begin original

See Server error.

=end original

"Server error" を参照してください。

=item %s did not return a true value

=begin original

(F) A required (or used) file must return a true value to indicate that
it compiled correctly and ran its initialization code correctly.  It's
traditional to end such a file with a "1;", though any true value would
do.  See L<perlfunc/require>.

=end original

(F) require (や use) されたファイルは、正常にコンパイルされ、
初期化コードを正しく実行したことを示すために、真を返さなければなりません。
こういったファイルは、"1;" で終わるようにするのが習慣ですが、
真となる値であれば、何でもかまいません。
L<perlfunc/require> を参照してください。

=item (Did you mean &%s instead?)

=begin original

(W) You probably referred to an imported subroutine &FOO as $FOO or some
such.

=end original

おそらく import したサブルーチン &FOO を $FOO として
参照したようなことでしょう。

=item (Did you mean "local" instead of "our"?)

=begin original

(W misc) Remember that "our" does not localize the declared global
variable.  You have declared it again in the same lexical scope, which
seems superfluous.

=end original

(W misc) "our" 宣言されたグローバル変数を local 化しないことを
忘れないで下さい。
これをもう一度同じレキシカルスコープで宣言していますが、
不必要でしょう。

=item (Did you mean $ or @ instead of %?)

=begin original

(W) You probably said %hash{$key} when you meant $hash{$key} or
@hash{@keys}.  On the other hand, maybe you just meant %hash and got
carried away.

=end original

(W) おそらく $hash{$key} か @hash{@keys} としたいときに %hash{$key} と
したのでしょう。
あるいは、単に %hash としたくてやりすぎたのでしょう。

=item Died

=begin original

(F) You passed die() an empty string (the equivalent of C<die "">) or
you called it with no args and both C<$@> and C<$_> were empty.

=end original

(F) die() に空文字列を渡した(C<die ""> と等価です)か、引数なしで
呼び出して、C<$@> と C<$_> が空でした。

=item Document contains no data

=begin original

See Server error.

=end original

"Server error" を参照してください。

=item Don't know how to handle magic of type '%s'

=begin original

(P) The internal handling of magical variables has been cursed.

=end original

(P) マジック変数の内部処理がおかしくなっています。

=item do_study: out of memory

=begin original

(P) This should have been caught by safemalloc() instead.

=end original

(P) これは、本来 safemalloc() で引っ掛かるはずのものです。

=item (Do you need to predeclare %s?)

=begin original

(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  It often means a subroutine or module
name is being referenced that hasn't been declared yet.  This may be
because of ordering problems in your file, or because of a missing
"sub", "package", "require", or "use" statement.  If you're referencing
something that isn't defined yet, you don't actually have to define the
subroutine or package before the current location.  You can use an empty
"sub foo;" or "package FOO;" to enter a "forward" declaration.

=end original

(S) これは "%s found where operator expected" メッセージと共に
表示される教育的な推測です。
これはしばしばサブルーチンやモジュール名がまだ宣言される前に参照されている
ことを意味します。
これはファイル内部での順番のためであったり、"sub", "package", "require",
"use" 文がないためであったりします。
もしまだ定義されていないものを参照したい場合、現在位置より前に実際に
サブルーチンやパッケージを定義する必要はありません。
空の "sub foo;" や "package FOO;" を「前方」宣言として使えます。

=item Duplicate free() ignored

=begin original

(S malloc) An internal routine called free() on something that had
already been freed.

=end original

(S malloc) 既に解放されているものに対して、内部ルーティンが free() を
行なおうとしました。

=item elseif should be elsif

=begin original

(S) There is no keyword "elseif" in Perl because Larry thinks it's ugly.
Your code will be interpreted as an attempt to call a method named
"elseif" for the class returned by the following block.  This is
unlikely to be what you want.

=end original

(S) Larry は "elseif" というのは醜いと考えたので、Perl にはこのキーワードは
ありません。
このコードは引き続くブロックによって返されたクラスの "elseif" メソッドを
呼び出そうとしていると解釈されます。
これは望んでいることではないはずです。

=item entering effective %s failed

=begin original

(F) While under the C<use filetest> pragma, switching the real and
effective uids or gids failed.

=end original

(F) C<use filetest> プラグマを使っている間に、
実と実効の UID や GID の切り替えに失敗しました。

=item Error converting file specification %s

=begin original

(F) An error peculiar to VMS.  Because Perl may have to deal with file
specifications in either VMS or Unix syntax, it converts them to a
single form when it must operate on them directly.  Either you've passed
an invalid file specification to Perl, or you've found a case the
conversion routines don't handle.  Drat.

=end original

(F) VMS に固有のエラーです。
Perl はファイル仕様を VMS 式か Unix 式かどちらかで扱わなければならないので、
直接操作しなければならない場合は変換します。
不正なファイル仕様を Perl に渡したか、変換ルーチンが扱えないパターンを
発見したかです。
ちぇっ。

=item %s: Eval-group in insecure regular expression

=begin original

(F) Perl detected tainted data when trying to compile a regular
expression that contains the C<(?{ ... })> zero-width assertion, which
is unsafe.  See L<perlre/(?{ code })>, and L<perlsec>.

=end original

C<(?{ ... })> ゼロ幅アサーションを含む正規表現をコンパイルしようと
したときに、Perl は汚染されたデータを検出しました;
これは安全ではありません。
L<perlre/(?{ code })> と L<perlsec> を参照してください。

=item %s: Eval-group not allowed at run time

=begin original

(F) Perl tried to compile a regular expression containing the
C<(?{ ... })> zero-width assertion at run time, as it would when the
pattern contains interpolated values.  Since that is a security risk, it
is not allowed.  If you insist, you may still do this by explicitly
building the pattern from an interpolated string at run time and using
that in an eval().  See L<perlre/(?{ code })>.

=end original

(F) Perl が実行時に、変数展開された値を含んでいて、
C<(?{ ... })> ゼロ幅アサーションを含む正規表現をコンパイルしようとしました。
これはセキュリティ上の危険があるので、許可されていません。
どうしても実行したい場合は、実行時に変数展開された文字列から
パターンを作成して、それを eval() の中で使うことで実行できます。
L<perlre/(?{ code })> を参照してください。

=item %s: Eval-group not allowed, use re 'eval'

=begin original

(F) A regular expression contained the C<(?{ ... })> zero-width
assertion, but that construct is only allowed when the C<use re 'eval'>
pragma is in effect.  See L<perlre/(?{ code })>.

=end original

(F) 正規表現に C<(?{ ... })> ゼロ幅アサーションを含んでいますが、
この構造は C<use re 'eval'> プラグマが有効の場合にのみ許可されます。
L<perlre/(?{ code })> を参照してください。

=item Excessively long <> operator

=begin original

(F) The contents of a <> operator may not exceed the maximum size of a
Perl identifier.  If you're just trying to glob a long list of
filenames, try using the glob() operator, or put the filenames into a
variable and glob that.

=end original

(F) <> 演算子の内容は Perl 識別子の最大サイズを越えることはできません。
単にファイル名の長いリストをグロブしようとしただけなら、glob() 演算子を
使うか、ファイル名を変数に入れて、それをグロブしてください。

=item Execution of %s aborted due to compilation errors

=begin original

(F) The final summary message when a Perl compilation fails.

=end original

(F) Perl のコンパイルが失敗したときの、最後のまとめメッセージです。

=item Exiting eval via %s

=begin original

(W exiting) You are exiting an eval by unconventional means, such as a
goto, or a loop control statement.

=end original

(W exiting) goto やループ制御文など、おかしな方法で eval を抜けました。

=item Exiting format via %s

=begin original

(W exiting) You are exiting an eval by unconventional means, such as a
goto, or a loop control statement.

=end original

(W exiting) goto やループ制御文といった、異例な形で eval を終了しました。

=item Exiting pseudo-block via %s

=begin original

(W exiting) You are exiting a rather special block construct (like a
sort block or subroutine) by unconventional means, such as a goto, or a
loop control statement.  See L<perlfunc/sort>.

=end original

(W exiting) (ソートブロックやサブルーチンのような) 特別なブロック構造を、
goto やループ制御文といった異例な方法で終了しました。
L<perlfunc/sort> を参照してください。

=item Exiting subroutine via %s

=begin original

(W exiting) You are exiting a subroutine by unconventional means, such
as a goto, or a loop control statement.

=end original

(W exiting) goto やループ制御文など、おかしな方法でサブルーティンを
抜けました。

=item Exiting substitution via %s

=begin original

(W exiting) You are exiting a substitution by unconventional means, such
as a return, a goto, or a loop control statement.

=end original

(W exit) return や goto やループ制御文など、おかしな方法で置換を
抜けました。

=item Explicit blessing to '' (assuming package main)

=begin original

(W misc) You are blessing a reference to a zero length string.  This has
the effect of blessing the reference into the package main.  This is
usually not what you want.  Consider providing a default target package,
e.g. bless($ref, $p || 'MyPackage');

=end original

(W misc) リファレンスを長さゼロの文字列に bless しました。
これはリファレンスをパッケージ main に bless する効果があります。
これは普通あなたが望んでいることではありません。
(bless($ref, $p || 'MyPackage'); のように) デフォルトターゲット
パッケージを提供することを考慮してください;

=item %s: Expression syntax

=begin original

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item %s failed--call queue aborted

=begin original

(F) An untrapped exception was raised while executing a CHECK, INIT, or
END subroutine.  Processing of the remainder of the queue of such
routines has been prematurely ended.

=end original

(F) CHECK, INIT, END サブルーチンを実行中にトラップされていない例外が
発生しました。
このようなルーチンのキューの残りの処理は途中で終了しました。

=item false [] range "%s" in regexp

=begin original

(W regexp) A character class range must start and end at a literal
character, not another character class like C<\d> or C<[:alpha:]>.  The
"-" in your false range is interpreted as a literal "-".  Consider
quoting the "-",  "\-".  See L<perlre>.

=end original

(W regexp) 文字クラス範囲の先頭とと末尾は、C<\d> や C<[:alpha:]> のような
他の文字クラスではなく、リテラル文字でなければなりません。
間違った範囲の "-" はリテラルの "-" と解釈されます。
"-" を "\-" とクォートすることを考慮してください。
L<perlre> を参照してください。

=item Fatal VMS error at %s, line %d

=begin original

(P) An error peculiar to VMS.  Something untoward happened in a VMS
system service or RTL routine; Perl's exit status should provide more
details.  The filename in "at %s" and the line number in "line %d" tell
you which section of the Perl source code is distressed.

=end original

(P) VMS に固有のエラーです。
何か都合の悪いことが VMS システムサービスか RTL ルーチンで起こりました;
Perl の終了コードに詳細が示されています。
"at %s" のファイル名と "line %d" の行番号は、問題の起こった
Perl ソースコードの位置を示しています。

=item fcntl is not implemented

=begin original

(F) Your machine apparently doesn't implement fcntl().  What is this, a
PDP-11 or something?

=end original

(F) このマシンでは、fcntl() が実装されていないように見えます。
PDP-11 か何かでしょうか。

=item Filehandle %s opened only for input

=begin original

(W io) You tried to write on a read-only filehandle.  If you intended it
to be a read-write filehandle, you needed to open it with "+<" or "+>"
or "+>>" instead of with "<" or nothing.  If you intended only to write
the file, use ">" or ">>".  See L<perlfunc/open>.

=end original

(W io) リードオンリーのファイルハンドルに対して、書込みを行なおうとしました。
読み書き両用ファイルハンドルにしたいのであれば、"<" を付けたり、
何も付けなかったりするのではなく、"+<" や "+>" や "+>>" を付けて
open する必要があります。
ライトオンリーであれば、">" や ">>" を使ってください。
L<perlfunc/open> の項を参照してください。

=item Filehandle %s opened only for output

=begin original

(W io) You tried to read from a filehandle opened only for writing.  If
you intended it to be a read/write filehandle, you needed to open it
with "+<" or "+>" or "+>>" instead of with "<" or nothing.  If you
intended only to read from the file, use "<".  See L<perlfunc/open>.

=end original

(W io) 書き込み専用のファイルハンドルから読み込もうとしました。
読み書きできるファイルハンドルにしたい場合は、
ファイルのオープン時に "<" や何もなしではなく、
"+<" か "+>" か "+>>" をつける必要があります。
読み込み専用にしたい場合は、"<" を使ってください。
L<perlfunc/open> を参照してください。

=item Final $ should be \$ or $name

=begin original

(F) You must now decide whether the final $ in a string was meant to be
a literal dollar sign, or was meant to introduce a variable name that
happens to be missing.  So you have to put either the backslash or the
name.

=end original

(F) 文字列の最後の $ が、リテラルのドル記号なのか、変数名を入れようとして
忘れたのかを、はっきりさせなければなりません。
バックスラッシュを付けるか、名前を入れてください。

=item Final @ should be \@ or @name

=begin original

(F) You must now decide whether the final @ in a string was meant to be
a literal "at" sign, or was meant to introduce a variable name that
happens to be missing.  So you have to put either the backslash or the
name.

=end original

(F) 文字列の最後の @ が、リテラルのアットマークなのか、変数名を
入れようとして忘れたのかを、はっきりさせなければなりません。
バックスラッシュを付けるか、名前を入れてください。

=item flock() on closed filehandle %s

=begin original

(W closed) The filehandle you're attempting to flock() got itself closed
some time before now.  Check your logic flow.  flock() operates on
filehandles.  Are you attempting to call flock() on a dirhandle by the
same name?

=end original

(W closed) flock() しようとしたファイルハンドルはその前に既に
閉じられています。
論理フローをチェックしてください。
flock() はファイルハンドルを操作します。
同じ名前のディレクトリハンドルに flock() しようとしていませんか?

=item Quantifier follows nothing before << HERE in regex m/%s/

=begin original

(F) You started a regular expression with a quantifier. Backslash it if you
meant it literally. The << HERE shows in the regular expression about where the
problem was discovered. See L<perlre>.

=end original

(F) 正規表現を量指定子で開始しています。
もしそれをリテラルに使いたいなら、バックスラッシュでクォートしてください。
<< HERE で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Format not terminated

=begin original

(F) A format must be terminated by a line with a solitary dot.  Perl got
to the end of your file without finding such a line.

=end original

(F) フォーマットは、単独のドットだけからなる行で終わらなければなりません。
そのような行が見つからないまま、スクリプトの最後に行き当たってしまいました。

=item Format %s redefined

=begin original

(W redefine) You redefined a format.  To suppress this warning, say

=end original

(W redefine) フォーマットを再定義しました。
この警告を止めるには以下のようにしてください。

    {
	no warnings;
	eval "format NAME =...";
    }

=item Found = in conditional, should be ==

=begin original

(W syntax) You said

=end original

(W) 以下のようにしています:

    if ($foo = 123)

=begin original

when you meant

=end original

以下のようにするべきところでしょう:

    if ($foo == 123)

=begin original

(or something like that).

=end original

(あるいは似たようなこと)。

=item %s found where operator expected

=begin original

(S) The Perl lexer knows whether to expect a term or an operator.  If it
sees what it knows to be a term when it was expecting to see an
operator, it gives you this warning.  Usually it indicates that an
operator or delimiter was omitted, such as a semicolon.

=end original

(S) Perl の字句解析部は、次に項が来るか、演算子が来るかを知っています。
次に演算子が来ると思っているときに、項であるとわかるものが現れると、
この警告が出ることになります。
通常、演算子かセミコロンのような区切り文字が省略されたことをしめします。

=item gdbm store returned %d, errno %d, key "%s"

=begin original

(S) A warning from the GDBM_File extension that a store failed.

=end original

(S) GDBM_File 拡張モジュールが、値の設定に失敗したという警告です。

=item gethostent not implemented

=begin original

(F) Your C library apparently doesn't implement gethostent(), probably
because if it did, it'd feel morally obligated to return every hostname
on the Internet.

=end original

(F) C ライブラリに gethostent() が実装されていないようです。
おそらく、実装すると Internet 上のすべてのホスト名を
返さなければいけないと思っているのでしょう。

=item get%sname() on closed socket %s

=begin original

(W closed) You tried to get a socket or peer socket name on a closed
socket.  Did you forget to check the return value of your socket() call?

=end original

(W closed) 閉じたソケットに対してソケットやピアソケット名を取得しようと
しました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか?

=item getpwnam returned invalid UIC %#o for user "%s"

=begin original

(S) A warning peculiar to VMS.  The call to C<sys$getuai> underlying the
C<getpwnam> operator returned an invalid UIC.

=end original

(S) VMS に固有の警告です。
C<getpwnam> 演算子の基礎となる C<sys$getuai> 呼び出しで
不正な UIC が返されました。

=item getsockopt() on closed socket %s

=begin original

(W closed) You tried to get a socket option on a closed socket.  Did you
forget to check the return value of your socket() call?  See
L<perlfunc/getsockopt>.

=end original

(W clockd) クローズされたソケットのソケットオプションを取得しようとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか。
L<perlfunc/getsockopt> を参照してください。

=item Global symbol "%s" requires explicit package name

=begin original

(F) You've said "use strict vars", which indicates that all variables
must either be lexically scoped (using "my"), declared beforehand using
"our", or explicitly qualified to say which package the global variable
is in (using "::").

=end original

(F) "use strict vars" が指定されていますので、すべての変数は、
("my" を使った) 字句スコープの変数か、"our" を使って事前に宣言するか、
グローバル変数がどのパッケージのものかを ("::" を使って)、明示的に
修飾しなくてはなりません。

=item glob failed (%s)

=begin original

(W glob) Something went wrong with the external program(s) used for
C<glob> and C<< <*.c> >>.  Usually, this means that you supplied a
C<glob> pattern that caused the external program to fail and exit with a
nonzero status.  If the message indicates that the abnormal exit
resulted in a coredump, this may also mean that your csh (C shell) is
broken.  If so, you should change all of the csh-related variables in
config.sh:  If you have tcsh, make the variables refer to it as if it
were csh (e.g.  C<full_csh='/usr/bin/tcsh'>); otherwise, make them all
empty (except that C<d_csh> should be C<'undef'>) so that Perl will
think csh is missing.  In either case, after editing config.sh, run
C<./Configure -S> and rebuild Perl.

=end original

(W glob) C<glob> や C<< <*.c> >> のために使われる外部プログラムに何か問題が
発生しました。
通常、これは外部プログラムが失敗して非 0 のステータスで終了するような
C<glob> パターンが渡されたことを意味します。
このメッセージがコアダンプを引きおこした異常終了を示している場合、
csh (C シェル) が壊れていることを意味しているかもしれません。
もしそうなら、config.sh の全ての csh 関連の変数を変更するべきです:
もし tcsh があるなら、(C<full_csh='/usr/bin/tcsh'> のように) tcsh を
参照するように変数を設定します;
さもなければ、関連する全ての変数を空にする(例外として C<d_csh> は
C<'undef'> に設定するべきです)ことで、Perl は csh がないものと考えます。
どちらの場合でも、config.sh を修正した後、C<./Configure -S> を実行して
Perl を再ビルドしてください。

=item Glob not terminated

=begin original

(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".

=end original

(F) 項が必要とされるところで、開き山括弧が見つけたため、
対応する閉じ山括弧を探しましたが、見つかりませんでした。
可能性としては、必要な括弧を省いてしまい、本当は、「小なり記号」を
表したかった場合が考えられます。

=item Got an error from DosAllocMem

=begin original

(P) An error peculiar to OS/2.  Most probably you're using an obsolete
version of Perl, and this should not happen anyway.

=end original

(P) OS/2 に固有のエラーです。
もっともありそうなのは廃止されたバージョンの Perl を使っていることで、
どちらにしてもこのエラーは起きないはずです。

=item goto must have label

=begin original

(F) Unlike with "next" or "last", you're not allowed to goto an
unspecified destination.  See L<perlfunc/goto>.

=end original

(F) "next" や "last" とは違って、goto には必ず、飛び先を
指定しなくてはなりません。
L<perlfunc/goto> を参照してください。

=item %s had compilation errors

=begin original

(F) The final summary message when a C<perl -c> fails.

=end original

(F) C<perl -c> が失敗したときの最終まとめメッセージです。

=item Had to create %s unexpectedly

=begin original

(S internal) A routine asked for a symbol from a symbol table that ought
to have existed already, but for some reason it didn't, and had to be
created on an emergency basis to prevent a core dump.

=end original

(S internal) あるルーティンが、既に存在しているはずのシンボルを、
シンボルテーブルで探しましたが、何らかの理由で存在せず、
コアダンプを避けるために、緊急に生成しました。

=item Hash %%s missing the % in argument %d of %s()

=begin original

(D deprecated) Really old Perl let you omit the % on hash names in some
spots.  This is now heavily deprecated.

=end original

(D deprecated) 本当に古い Perl では、ハッシュ名の % を省略できる場所が
ありました。
省略はしないようにしてください。

=item %s has too many errors

=begin original

(F) The parser has given up trying to parse the program after 10 errors.
Further error messages would likely be uninformative.

=end original

(F) 構文解析部が、プログラム中に 10 個のエラーを見つけたため、
それ以上の解析を諦めました。
それ以上のエラーメッセージは、おそらく意味がないでしょう。

=item Hexadecimal number > 0xffffffff non-portable

=begin original

(W portable) The hexadecimal number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=end original

(W portable) 指定した 16 進数が 2**32-1 (4294967295) より大きいので、
システム間で移植性がありません。
移植性に関するさらなる考察については L<perlport> を参照してください。

=item Identifier too long

=begin original

(F) Perl limits identifiers (names for variables, functions, etc.) to
about 250 characters for simple names, and somewhat more for compound
names (like C<$A::B>).  You've exceeded Perl's limits.  Future versions
of Perl are likely to eliminate these arbitrary limitations.

=end original

(F) Perl は識別子(変数名や関数名など)について、単純な名前については
およそ 250 文字に、(C<$A::B> のような)複合名についてはもう少し長い長さに
制限しています。
この Perl の制限を越えました。
将来のバージョンの Perl ではこれらの恣意的な制限はなくなるでしょう。

=item Illegal binary digit %s

=begin original

(F) You used a digit other than 0 or 1 in a binary number.

=end original

(F) 2 進数として 0 と 1 以外の数値を使っています。

=item Illegal binary digit %s ignored

=begin original

(W digit) You may have tried to use a digit other than 0 or 1 in a
binary number.  Interpretation of the binary number stopped before the
offending digit.

=end original

(W digit) 2 進数として 0 と 1 以外の数値を使おうとしたのでしょう。
2 進数の解釈は問題のある数値の手前で停止しました。

=item Illegal character %s (carriage return)

=begin original

(F) Perl normally treats carriage returns in the program text as it
would any other whitespace, which means you should never see this error
when Perl was built using standard options.  For some reason, your
version of Perl appears to have been built without this support.  Talk
to your Perl administrator.

=end original

(F) Perl は普通プログラムテキスト中の復帰文字をその他の空白と同様に
扱いますので、Perl を標準のオプションでビルドした場合はこのエラーを
見ることは決してないはずです。
どういうわけか、お使いの Perl はこの機能なしでビルドされているようです。
Perl の管理者に問い合わせてください。

=item Illegal division by zero

=begin original

(F) You tried to divide a number by 0.  Either something was wrong in
your logic, or you need to put a conditional in to guard against
meaningless input.

=end original

(F) ゼロで割り算をしようとしました。
ロジックの誤りか、意味の無い入力を防ぐために、条件を付けることが
必要かのどちらかでしょう。

=item Illegal hexadecimal digit %s ignored

=begin original

(W digit) You may have tried to use a character other than 0 - 9 or
A - F, a - f in a hexadecimal number.  Interpretation of the hexadecimal
number stopped before the illegal character.

=end original

(W digit) 16 進数として 0 - 9, A - F, a - f 以外の文字を使おうとしました。
16 進数の解釈は不正な文字の手前で停止しました。

=item Illegal modulus zero

=begin original

(F) You tried to divide a number by 0 to get the remainder.  Most
numbers don't take to this kindly.

=end original

(F) 余りを求めるのに、ゼロで割り算をしようとしました。
これは、ほとんどの数体系で受け入れられません。

=item Illegal number of bits in vec

=begin original

(F) The number of bits in vec() (the third argument) must be a power of
two from 1 to 32 (or 64, if your platform supports that).

=end original

(F) vec() のビット数 (第三引数) は 1 から 32 (プラットフォームが
対応している場合は 64) までの、2 のべき乗でなければなりません。

=item Illegal octal digit %s

=begin original

(F) You used an 8 or 9 in a octal number.

=end original

(F) 8 進数で 8 か 9 を使いました。

=item Illegal octal digit %s ignored

=begin original

(W digit) You may have tried to use an 8 or 9 in a octal number.
Interpretation of the octal number stopped before the 8 or 9.

=end original

(W digit) 8 進数で 8 か 9 を使おうとしたのでしょう。
8 進数の解釈は 8 か 9 の手前で停止しました。

=item Illegal switch in PERL5OPT: %s

=begin original

(X) The PERL5OPT environment variable may only be used to set the
following switches: B<-[DIMUdmw]>.

=end original

(X) PERL5OPT 環境変数で設定できるのは B<-[DIMUdmw]> の
オプションだけです。

=item Ill-formed CRTL environ value "%s"

=begin original

(W internal) A warning peculiar to VMS.  Perl tried to read the CRTL's
internal environ array, and encountered an element without the C<=>
delimiter used to separate keys from values.  The element is ignored.

=end original

(W internal) VMS 固有の警告です。
Perl は CRTL の内部環境配列を読み込もうとしましたが、キーを値と
分離するために使われている C<=> デリミタのない要素に遭遇しました。
この要素は無視しました。

=item Ill-formed message in prime_env_iter: |%s|

=begin original

(W internal) A warning peculiar to VMS.  Perl tried to read a logical
name or CLI symbol definition when preparing to iterate over %ENV, and
didn't see the expected delimiter between key and value, so the line was
ignored.

=end original

(W internal) VMS 固有の警告です。
Perl は %ENV を反復する準備したときに論理名や CLI シンボル定義を
読み込もうとしましたが、キーと値の間のデリミタが見つからなかったので、
その行は無視しました。

=item (in cleanup) %s

=begin original

(W misc) This prefix usually indicates that a DESTROY() method raised
the indicated exception.  Since destructors are usually called by the
system at arbitrary points during execution, and often a vast number of
times, the warning is issued only once for any number of failures that
would otherwise result in the same message being repeated.

=end original

(W misc) この接頭辞は普通、示されている例外が DESTROY() メソッドで
発生したことを示しています。
デストラクタは普通実行中の任意の時点で呼び出され、しばしば大量に
呼び出されるので、この警告は同じメッセージが繰り返されないように、
何回失敗しても一度だけ発生します。

=begin original

Failure of user callbacks dispatched using the C<G_KEEPERR> flag could
also result in this warning.  See L<perlcall/G_KEEPERR>.

=end original

C<G_KEEPERR> フラグを使ってディスパッチしたユーザーコールバックに失敗した
場合にもこの警告が出ることがあります。
L<perlcall/G_KEEPERR> を参照してください。

=item Insecure dependency in %s

=begin original

(F) You tried to do something that the tainting mechanism didn't like.
The tainting mechanism is turned on when you're running setuid or
setgid, or when you specify B<-T> to turn it on explicitly.  The
tainting mechanism labels all data that's derived directly or indirectly
from the user, who is considered to be unworthy of your trust.  If any
such data is used in a "dangerous" operation, you get this error.  See
L<perlsec> for more information.

=end original

(F) 何か汚染チェックの機構が、望ましくないと判断することを
行なおうとしました。
setuid や setgid を実行したときや、明示的に B<-T> で指定したときに、
汚染チェック機構が働きます。
汚染チェック機構は、信頼がおけないと仮定されるユーザが直接、間接を問わず、
指定したデータに印を付けます。
そのようなデータを「危険な」操作に用いると、このエラーが発生します。
詳しくは、L<perlsec> を参照してください。

=item Insecure directory in %s

=begin original

(F) You can't use system(), exec(), or a piped open in a setuid or
setgid script if C<$ENV{PATH}> contains a directory that is writable by
the world.  See L<perlsec>.

=end original

(F) C<$ENV{PATH}> の中に、誰にでも書き込みができるディレクトリが
含まれているとき、system()、exec()、パイプのオープンを
行なうことはできません。
L<perlsec> を参照してください。

=item Insecure $ENV{%s} while running %s

=begin original

(F) You can't use system(), exec(), or a piped open in a setuid or
setgid script if any of C<$ENV{PATH}>, C<$ENV{IFS}>, C<$ENV{CDPATH}>,
C<$ENV{ENV}> or C<$ENV{BASH_ENV}> are derived from data supplied (or
potentially supplied) by the user.  The script must set the path to a
known value, using trustworthy data.  See L<perlsec>.

=end original

(F) C<$ENV{PATH}>, C<$ENV{IFS}>, C<$ENV{CDPATH}>, C<$ENV{ENV}>,
C<$ENV{BASH_ENV}> のいずれかがユーザーによって提供された(あるいは
提供された可能性のある)データの場合、setuid や setgid されたスクリプトでは
system(), exec(), パイプされる open を使うことはできません。
スクリプトはパスとして、信頼の置けるデータを使った、既知の値を
セットしなければなりません。
L<perlsec> を参照してください。

=item Integer overflow in %s number

=begin original

(W overflow) The hexadecimal, octal or binary number you have specified
either as a literal or as an argument to hex() or oct() is too big for
your architecture, and has been converted to a floating point number.
On a 32-bit architecture the largest hexadecimal, octal or binary number
representable without overflow is 0xFFFFFFFF, 037777777777, or
0b11111111111111111111111111111111 respectively.  Note that Perl
transparently promotes all numbers to a floating point representation
internally--subject to loss of precision errors in subsequent
operations.

=end original

(W overflow) リテラルまたは hex() や oct() の引数として指定された 16 進、
8 進、2 進数は実行しているアーキテクチャには大きすぎるので、浮動小数点数に
変換されました。
32 ビットアーキテクチャでは、オーバーフローせずに表現できる 16 進、8 進
2 進数はそれぞれ 0xFFFFFFFF, 037777777777, 
0b11111111111111111111111111111111 です。
Perl は全ての数値を内部では浮動小数点表現に透過的に変換することに
注意してください -- 引き続く操作によって精度が失われることがあります。

=item Internal disaster before << HERE in regex m/%s/

=begin original

(P) Something went badly wrong in the regular expression parser.
The << HERE shows in the regular expression about where the problem was
discovered.

=end original

(P) 正規表現解析部に何か悪いことが起こりました。
<< HERE で正規表現のどこに問題が発見されたかを示しています。

=item Internal inconsistency in tracking vforks

=begin original

(S) A warning peculiar to VMS.  Perl keeps track of the number of times
you've called C<fork> and C<exec>, to determine whether the current call
to C<exec> should affect the current script or a subprocess (see
L<perlvms/"exec LIST">).  Somehow, this count has become scrambled, so
Perl is making a guess and treating this C<exec> as a request to
terminate the Perl script and execute the specified command.

=end original

(S) VMS 特有の警告です。
Perl は C<fork> と C<exec> を呼び出した回数を数えています;
これは現在の C<exec> 呼び出しが現在のスクリプトかサブプロセスかどちらに
影響を与えるかを決定するためです(L<perlvms/"exec LIST"> を
参照してください)。
どういうわけか、このカウントがおかしくなったので、Perl はこの C<exec> が
Perl スクリプトを終了させて指定されたコマンドを実行する要求であると
仮定して、そのように扱いました。

=item Internal urp before << HERE in regex m/%s/

=begin original

(P) Something went badly awry in the regular expression parser. The <<<HERE
shows in the regular expression about where the problem was discovered.

=end original

(P) 正規表現解析部に何か間違ったことが起こりました。
<<<HERE で正規表現のどこに問題が発見されたかを示しています。

=item %s (...) interpreted as function

=begin original

(W syntax) You've run afoul of the rule that says that any list operator
followed by parentheses turns into a function, with all the list
operators arguments found inside the parentheses.  See 
L<perlop/Terms and List Operators (Leftward)>.

=end original

(W syntax) リスト演算子の直後に括弧を置くと、括弧内にあるリスト演算子引数を
持つ関数になる、という規則が適用されました。
L<perlop/Terms and List Operators (Leftward)> を参照してください。

=item Invalid %s attribute: %s

=begin original

The indicated attribute for a subroutine or variable was not recognized
by Perl or by a user-supplied handler.  See L<attributes>.

=end original

示されたサブルーチンや変数の属性は
Perl やユーザー提供のハンドラで認識されませんでした。
L<attributes> を参照してください。

=item Invalid %s attributes: %s

=begin original

The indicated attributes for a subroutine or variable were not
recognized by Perl or by a user-supplied handler.  See L<attributes>.

=end original

示されたサブルーチンや変数の属性は
Perl やユーザー提供のハンドラで認識されませんでした。
L<attributes> を参照してください。

=item Invalid conversion in %s: "%s"

=begin original

(W printf) Perl does not understand the given format conversion.  See
L<perlfunc/sprintf>.

=end original

(W printf) Perl は指定されたフォーマット変換が認識できませんでした。
L<perlfunc/sprintf> を参照してください。

=item invalid [] range "%s" in regexp

=begin original

(F) The range specified in a character class had a minimum character
greater than the maximum character.  See L<perlre>.

=end original

(F) 文字クラスに指定した範囲の最小値が、最大値よりも大きくなっています。
L<perlre> を参照してください。

=item Invalid separator character %s in attribute list

=begin original

(F) Something other than a colon or whitespace was seen between the
elements of an attribute list.  If the previous attribute had a
parenthesised parameter list, perhaps that list was terminated too soon.
See L<attributes>.

=end original

(F) 属性リストの要素の間にコロンと空白以外のものがあります。
直前の属性がかっこ付きのパラメータリストの場合、おそらくリストが
予定より早く終端されています。
L<attributes> を参照してください。

=item Invalid type in pack: '%s'

=begin original

(F) The given character is not a valid pack type.  See L<perlfunc/pack>.
(W pack) The given character is not a valid pack type but used to be
silently ignored.

=end original

(F) 与えられた文字は有効な pack の型ではありません。
L<perlfunc/pack> を参照してください。
(W pack) 与えられた文字は有効な pack の型ではありませんが、暗黙に
無視されました。

=item Invalid type in unpack: '%s'

=begin original

(F) The given character is not a valid unpack type.  See
L<perlfunc/unpack>.
(W unpack) The given character is not a valid unpack type but used to be
silently ignored.

=end original

(F) 与えられた文字は有効な unpack の型ではありません。
L<perlfunc/unpack> を参照してください。
(W unpack) 与えられた文字は有効な unpack の型ではありませんが、暗黙に
無視されました。

=item ioctl is not implemented

=begin original

(F) Your machine apparently doesn't implement ioctl(), which is pretty
strange for a machine that supports C.

=end original

(F) C をサポートしているマシンではおかしなことだと思いますが、
このマシンでは ioctl() が実装されていないようです。

=item `%s' is not a code reference

=begin original

(W) The second (fourth, sixth, ...) argument of overload::constant needs
to be a code reference. Either an anonymous subroutine, or a reference
to a subroutine.

=end original

(W) overload::constant の 2 番目 (4 番目、6 番目, ...) の引数はコード
リファレンスである必要があります。
無名サブルーチンか、サブルーチンへのリファレンスです。

=item `%s' is not an overloadable type

=begin original

(W) You tried to overload a constant type the overload package is unaware of.

=end original

(W) オーバーロードパッケージが知らない定数型をオーバーロードしようとしました。

=item junk on end of regexp

=begin original

(P) The regular expression parser is confused.

=end original

(P) 正規表現の構文解析ができなくなりました。

=item Label not found for "last %s"

=begin original

(F) You named a loop to break out of, but you're not currently in a loop
of that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=end original

(F) 脱出するループを指定しましたが、その名前のループの中にいません、
たとえ、呼び出された場所がそうであっても、今はそうではありません。
L<perlfunc/last> を参照してください。

=item Label not found for "next %s"

=begin original

(F) You named a loop to continue, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=end original

(F) 次の繰り返しを行なうループを指定しましたが、
その名前のループの中にいません。
たとえ、呼び出された場所がそうであっても、今はそうではありません。
L<perlfunc/last> を参照してください。

=item Label not found for "redo %s"

=begin original

(F) You named a loop to restart, but you're not currently in a loop of
that name, not even if you count where you were called from.  See
L<perlfunc/last>.

=end original

(F) 繰り返しの再実行を行なうループを指定しましたが、
その名前のループの中にいません。
たとえ、呼び出された場所がそうであっても、今はそうではありません。
L<perlfunc/last> を参照してください。

=item leaving effective %s failed

=begin original

(F) While under the C<use filetest> pragma, switching the real and
effective uids or gids failed.

=end original

(F) C<use filetest> プラグマを使っている間に、
実と実効の UID や GID の切り替えに失敗しました。

=item listen() on closed socket %s

=begin original

(W closed) You tried to do a listen on a closed socket.  Did you forget
to check the return value of your socket() call?  See
L<perlfunc/listen>.

=end original

(W closed) クローズされたソケットに listen を行なおうとしました。
socket() の呼び出し時に、返却値のチェックを忘れたのではありませんか。
L<perlfunc/listen> を参照してください。

=item Lookbehind longer than %d not implemented at {#} mark in regex %s

=begin original

There is an upper limit to the depth of lookbehind in the (?<=
regular expression construct.

=end original

(?<= 正規表現構造での前方参照の深さには上限があります。

=item Lvalue subs returning %s not implemented yet

=begin original

(F) Due to limitations in the current implementation, array and hash
values cannot be returned in subroutines used in lvalue context.  See
L<perlsub/"Lvalue subroutines">.

=end original

(F) 現在の実装の制限により、左辺値コンテキストで使われるサブルーチンは
配列とハッシュの値を返すことができません。
L<perlsub/"Lvalue subroutines"> を参照してください。

=item Lookbehind longer than %d not implemented before << HERE %s

=begin original

(F) There is currently a limit on the length of string which lookbehind can
handle. This restriction may be eased in a future release. The << HERE shows in
the regular expression about where the problem was discovered.

=end original

現在のところ前方参照が扱える文字列の長さには制限があります。
この制限は将来のリリースでは緩和されるでしょう。
<< HERE で正規表現のどこに問題が発見されたかを示しています。

=item Malformed PERLLIB_PREFIX

=begin original

(F) An error peculiar to OS/2.  PERLLIB_PREFIX should be of the form

=end original

(F) OS/2 固有のエラーです。
PERLLIB_PREFIX は以下のような形か:

    prefix1;prefix2

=begin original

or

=end original

あるいはこのような形で:

    prefix1 prefix2

=begin original

with nonempty prefix1 and prefix2.  If C<prefix1> is indeed a prefix of
a builtin library search path, prefix2 is substituted.  The error may
appear if components are not found, or are too long.  See
"PERLLIB_PREFIX" in L<perlos2>.

=end original

prefix1 と prefix2 が空でない形である必要があります。
C<prefix1> が組み込みライブラリ検索パスのプレフィックスなら、
prefix2 は置き換えられます。
このエラーは、コンポーネントが見つからないか、長すぎる時に起こります。
L<perlos2> の "PERLLIB_PREFIX" を参照してください。

=item Malformed UTF-8 character (%s)

=begin original

Perl detected something that didn't comply with UTF-8 encoding rules.

=end original

Perl が、何か UTF-8 エンコーディングルールに従わないものを
検出しました。

=item Malformed UTF-16 surrogate

=begin original

Perl thought it was reading UTF-16 encoded character data but while
doing it Perl met a malformed Unicode surrogate.

=end original

Perl は UTF-16 エンコード文字データを読み込んでいると考えましたが、
その間に Perl が不正な Unicode サロゲートに遭遇しました。

=item %s matches null string many times

=begin original

(W regexp) The pattern you've specified would be an infinite loop if the
regular expression engine didn't specifically check for that.  See
L<perlre>.

=end original

(W) 指定したパターンは、もし、正規表現エンジンがチェックを
行なっていなければ、無限ループに陥るものです。
L<perlre> を参照してください。

=item % may only be used in unpack

=begin original

(F) You can't pack a string by supplying a checksum, because the
checksumming process loses information, and you can't go the other way.
See L<perlfunc/unpack>.

=end original

(F) チェックサムを指定して pack を行なうことはできません。
チェックサム処理では、情報が失われ、どうしようもなくなるからです。
L<perlfunc/unpack> を参照してください。

=item Method for operation %s not found in package %s during blessing

=begin original

(F) An attempt was made to specify an entry in an overloading table that
doesn't resolve to a valid subroutine.  See L<overload>.

=end original

(F) 多重定義テーブルで、有効なサブルーチンに解決できない
エントリを指定しようとしました。
L<overload> を参照してください。

=item Method %s not permitted

=begin original

See Server error.

=end original

"Server error" を参照してください。

=item Might be a runaway multi-line %s string starting on line %d

=begin original

(S) An advisory indicating that the previous error may have been caused
by a missing delimiter on a string or pattern, because it eventually
ended earlier on the current line.

=end original

(S) ようやく現在行になって、文字列やパターンの終わりが見つかったことから、
先のエラーが、文字列やパターンのデリミタが、見つからなかったことで
起ったかもしれないことを、補足的に示しています。

=item Misplaced _ in number

=begin original

(W syntax) An underline in a decimal constant wasn't on a 3-digit boundary.

=end original

(W syntax) 十進数定数で下線が、3 桁ごとでありませんでした。

=item Missing %sbrace%s on \N{}

=begin original

(F) Wrong syntax of character name literal C<\N{charname}> within
double-quotish context.

=end original

(F) ダブルクォートされたコンテキストの中で、文字名リテラル C<\N{charname}> の
文法が間違っています。

=item Missing comma after first argument to %s function

=begin original

(F) While certain functions allow you to specify a filehandle or an
"indirect object" before the argument list, this ain't one of them.

=end original

(F) ある種の関数では、引数リストの前に、ファイルハンドルや
「間接オブジェクト」をおくことができますが、この関数は、
そういったものではありません。

=item Missing command in piped open

=begin original

(W pipe) You used the C<open(FH, "| command")> or
C<open(FH, "command |")> construction, but the command was missing or
blank.

=end original

(W pipe) C<open(FH, "| command")> か C<open(FH, "command |")> の構文を
使っていますが、コマンドが指定されていないか空白です。

=item Missing name in "my sub"

=begin original

(F) The reserved syntax for lexically scoped subroutines requires that
they have a name with which they can be found.

=end original

(F) 予約された文法である、レキシカルスコープのサブルーチンには
探すことの出来る名前が必要です。

=item Missing $ on loop variable

=begin original

(F) Apparently you've been programming in B<csh> too much.  Variables
are always mentioned with the $ in Perl, unlike in the shells, where it
can vary from one line to the next.

=end original

(F) B<csh> を使いすぎた症状が現れているようです。
Perl では、変数は常に $ を付けて表わされます。
その時によって違う、シェルとは違っています。

=item (Missing operator before %s?)

=begin original

(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  Often the missing operator is a comma.

=end original

(S) "%s found where operator expected" と共に表示される教育的な推測です。
しばしば抜けている演算子はカンマです。

=item Missing right curly or square bracket

=begin original

(F) The lexer counted more opening curly or square brackets than closing
ones.  As a general rule, you'll find it's missing near the place you
were last editing.

=end original

(F) 字句解析部が、閉じ中括弧(または大括弧)よりも
開き中括弧(大括弧)を多く発見しました。
一般的な規則として、最後に修正した場所の近くに間違いがあるといえます。

=item (Missing semicolon on previous line?)

=begin original

(S) This is an educated guess made in conjunction with the message "%s
found where operator expected".  Don't automatically put a semicolon on
the previous line just because you saw this message.

=end original

(S) このメッセージは、"%s found where operator expected" という
メッセージに伴って出される教育的な推測によるものです。
このメッセージが出たからといって、機械的に前の行に
セミコロンを付けることはしないでください。

=item Modification of a read-only value attempted

=begin original

(F) You tried, directly or indirectly, to change the value of a
constant.  You didn't, of course, try "2 = 1", because the compiler
catches that.  But an easy way to do the same thing is:

=end original

(F) 直接、間接に関らず、定数値を変更しようとしました。
もちろん、コンパイラが発見できる、"2 = 1" などといったことを
したわけではありません。
しかし、同じことは以下のようにしても起こります。

    sub mod { $_[0] = 1 }
    mod(2);

=begin original

Another way is to assign to a substr() that's off the end of the string.

=end original

substr() で、文字列の終わりよりも後ろに代入を行なうことでも起こります。

=begin original

Yet another way is to assign to a C<foreach> loop I<VAR> when I<VAR>
is aliased to a constant in the look I<LIST>:

=end original

もう一つの可能性は、C<foreach> ループにおいて、I<VAR> が I<LIST> の中の
定数のエイリアスであるときに、I<VAR> に代入した時です:

        $x = 1;
        foreach my $n ($x, 2) {
            $n *= 2; # modifies the $x, but fails on attempt to modify the 2
        } 

=item Modification of non-creatable array value attempted, %s

=begin original

(F) You tried to make an array value spring into existence, and the
subscript was probably negative, even counting from end of the array
backwards.

=end original

(F) 配列値を存在するようにしようとしました。　おそらく、
添字が負数で、配列の終わりから逆に数えたとしても、
おかしな位置を指しているようです。

=item Modification of non-creatable hash value attempted, %s

=begin original

(P) You tried to make a hash value spring into existence, and it
couldn't be created for some peculiar reason.

=end original

(F) ハッシュ値を存在するようにしようとしましたが、何か特別な理由で、
できませんでした。

=item Module name must be constant

=begin original

(F) Only a bare module name is allowed as the first argument to a "use".

=end original

(F) "use" の最初の引数としてモジュール名を示すのに許されているのは、
裸の単語だけです。

=item Module name required with -%c option

=begin original

(F) The C<-M> or C<-m> options say that Perl should load some module, but
you omitted the name of the module.  Consult L<perlrun> for full details
about C<-M> and C<-m>.

=end original

C<-M> と C<-m> のオプションは Perl にモジュールを読み込ませることを
指示しますが、モジュール名がありませんでした。
C<-M> と C<-m> に関する完全な詳細については L<perlrun> を参照してください。

=item msg%s not implemented

=begin original

(F) You don't have System V message IPC on your system.

=end original

(F) このシステムでは、System V メッセージ IPC は使えません。

=item Multidimensional syntax %s not supported

=begin original

(W syntax) Multidimensional arrays aren't written like C<$foo[1,2,3]>.
They're written like C<$foo[1][2][3]>, as in C.

=end original

(W syntax) 多次元配列は、C<$foo[1,2,3]> のようには書けません。
これは、C のように C<$foo[1][2][3]> のように書きます。

=item / must be followed by a*, A* or Z*

=begin original

(F) You had a pack template indicating a counted-length string,
Currently the only things that can have their length counted are a*, A*
or Z*.  See L<perlfunc/pack>.

=end original

(F) カウント長文字列を示す pack テンプレートがあります。
現在のところ長さをカウントできるのは a*, A*, Z* だけです。
L<perlfunc/pack> を参照してください。

=item / must be followed by a, A or Z

=begin original

(F) You had an unpack template indicating a counted-length string, which
must be followed by one of the letters a, A or Z to indicate what sort
of string is to be unpacked.  See L<perlfunc/pack>.

=end original

(F) カウント長文字列を示す unpack テンプレートがあります;
これはどの種類の文字列を unpack するかを指示する、文字 a, A, Z の
いずれかの後に続かなければなりません。
L<perlfunc/pack> を参照してください。

=item / must follow a numeric type

=begin original

(F) You had an unpack template that contained a '#', but this did not
follow some numeric unpack specification.  See L<perlfunc/pack>.

=end original

(F) '#' を含む unpack テンプレートがありますが、これがなんらかの
数値 unpack 指定に引き続いていません。
L<perlfunc/pack> を参照してください。

=item "my sub" not yet implemented

=begin original

(F) Lexically scoped subroutines are not yet implemented.  Don't try
that yet.

=end original

(F) レキシカルスコープのサブルーチンはまだ実装されていません。
まだ試さないでください。

=item "my" variable %s can't be in a package

=begin original

(F) Lexically scoped variables aren't in a package, so it doesn't make
sense to try to declare one with a package qualifier on the front.  Use
local() if you want to localize a package variable.

=end original

(F) 字句スコープの変数は、パッケージ内に置かれませんので、
頭にパッケージ名を付けて宣言することは、無意味です。
パッケージ変数をローカル化したい場合には、local() を使ってください。

=item Name "%s::%s" used only once: possible typo

=begin original

(W once) Typographical errors often show up as unique variable names.
If you had a good reason for having a unique name, then just mention it
again somehow to suppress the message.  The C<our> declaration is
provided for this purpose.

=end original

(W once) しばしばタイプミスによってユニークな変数名として表示されます。
ユニークな名前をを使う理由があるのなら、もう一度どこかで参照することで
このメッセージを抑制できます。
C<our> 宣言がこの目的のために提供されています。

=item Negative length

=begin original

(F) You tried to do a read/write/send/recv operation with a buffer
length that is less than 0.  This is difficult to imagine.

=end original

(F) ゼロより短い長さのバッファで、読み込み、書き込み、送信、受信を
行なおうとしました。
どのようなことがしたいのか判断できません。

=item Nested quantifiers before << HERE in regex m/%s/

=begin original

(F) You can't quantify a quantifier without intervening parentheses. So
things like ** or +* or ?* are illegal. The << HERE shows in the regular
expression about where the problem was discovered.

=end original

(F) 括弧を挟まないで、数量子を数量子で修飾することはできません。
つまり、** や +* や ?* といったものは、正しくありません。
<< HERE で正規表現のどこに問題が発見されたかを示しています。

=begin original

Note, however, that the minimal matching quantifiers, C<*?>, C<+?>, and
C<??> appear to be nested quantifiers, but aren't.  See L<perlre>.

=end original

しかし、最短一致数量子の C<*?>、C<+?>、C<??> は、ネストした数量子のように
見えますが、そうではありません。
L<perlre> を参照してください。

=item %s never introduced

=begin original

(S internal) The symbol in question was declared but somehow went out of
scope before it could possibly have been used.

=end original

(S internal) 問題のシンボルは、宣言されましたが、使われる前にスコープから
外れてしまいました。

=item No %s allowed while running setuid

=begin original

(F) Certain operations are deemed to be too insecure for a setuid or
setgid script to even be allowed to attempt.  Generally speaking there
will be another way to do what you want that is, if not secure, at least
securable.  See L<perlsec>.

=end original

(F) ある種の操作は、setuid や setgid スクリプトにとって、
やってみることはできても、とても安全なものとは考えられないものです。
一般に言って、安全ではなくても、安全にしうる、別の方法があるはずです。
L<perlsec> を参照してください。

=item No B<-e> allowed in setuid scripts

=begin original

(F) A setuid script can't be specified by the user.

=end original

(F) setuid スクリプトは、ユーザによって指定することはできません。

=item No comma allowed after %s

=begin original

(F) A list operator that has a filehandle or "indirect object" is not
allowed to have a comma between that and the following arguments.
Otherwise it'd be just another one of the arguments.

=end original

(F) ファイルハンドルや「間接オブジェクト」を伴うリスト演算子では、
それらとそれ以降の引数の間にコンマを入れることはできません。
そのようにした場合には、引数の一つとなってしまいます。

=begin original

One possible cause for this is that you expected to have imported a
constant to your name space with B<use> or B<import> while no such
importing took place, it may for example be that your operating system
does not support that particular constant. Hopefully you did use an
explicit import list for the constants you expect to see, please see
L<perlfunc/use> and L<perlfunc/import>. While an explicit import list
would probably have caught this error earlier it naturally does not
remedy the fact that your operating system still does not support that
constant. Maybe you have a typo in the constants of the symbol import
list of B<use> or B<import> or in the constant name at the line where
this error was triggered?

=end original

これの原因としてあり得るものの一つは、B<use> や B<import> を使って
名前空間にインポートしたつもりの定数が実際にはインポートされていなかった
場合です;
例えば OS が特定の定数に対応していない場合などです。
できればインポートしたい定数のリストを明示的に使ってください;
L<perlfunc/use> と L<perlfunc/import> を参照して下さい。
明示的なインポートリストでおそらくこのエラーをより早く知ることができますが、
そもそも OS がその定数に対応していないという問題を解決はしません。
おそらく B<use> や B<import> のシンボルインポートリストの定数か、
エラーを引き起こした行の定数名をタイプミスしたのでは?

=item No command into which to pipe on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '|' at the end of the command line, so it
doesn't know where you want to pipe the output from this command.

=end original

(F) VMSに固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインの最後にに '|' を発見しましたが、
このコマンドから出力をどこにパイプしたいのかがわかりませんでした。

=item No DB::DB routine defined

=begin original

(F) The currently executing code was compiled with the B<-d> switch, but
for some reason the perl5db.pl file (or some facsimile thereof) didn't
define a routine to be called at the beginning of each statement.  Which
is odd, because the file should have been required automatically, and
should have blown up the require if it didn't parse right.

=end original

(F) 現在実行中のコードは、B<-d> スイッチを付けてコンパイルされましたが、
何らかの理由により、perl5db.pl (あるいは、その複製) が各実行文の頭で
呼び出すルーティンを定義していません。
そのファイルは自動的に require されるものであり、正しく解釈できなければ、
require が失敗するはずですので、これはとても有り得ない状態です。

=item No dbm on this machine

=begin original

(P) This is counted as an internal error, because every machine should
supply dbm nowadays, because Perl comes with SDBM.  See L<SDBM_File>.

=end original

(P) これは、内部エラーとして扱われます。　Perl に SDBM が付いてくるので、
どのマシンでも dbm が使えるはずだからです。
L<SDBM_File> を参照してください。

=item No DBsub routine

=begin original

(F) The currently executing code was compiled with the B<-d> switch,
but for some reason the perl5db.pl file (or some facsimile thereof)
didn't define a DB::sub routine to be called at the beginning of each
ordinary subroutine call.

=end original

(F) 現在実行中のコードは、-d スイッチを付けてコンパイルされましたが、
何らかの理由により、perl5db.pl (あるいは、その複製) が
各サブルーティン呼び出しの頭で呼び出す
DB::sub ルーティンを定義していませんでした。

=item No error file after 2> or 2>> on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '2>' or a '2>>' on the command line, but can't
find the name of the file to which to write data destined for stderr.

=end original

(F) VMSに固有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、
コマンドラインに '2>' や '2>>' を発見しましたが、
標準エラーとしてデータを書き込むファイル名が見つかりませんでした。

=item No input file after < on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '<' on the command line, but can't find the
name of the file from which to read data for stdin.

=end original

(F) VMS 特有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、コマンドラインに
'<' を発見しましたが、標準入力として読み込むためのファイル名が
見つかりませんでした。

=item No #! line

=begin original

(F) The setuid emulator requires that scripts have a well-formed #! line
even on machines that don't support the #! construct.

=end original

(F) setuid エミュレータでは、たとえマシンがサポートしていなくても、
完全な形の #! 行がスクリプトに書かれていなければなりません。

=item "no" not allowed in expression

=begin original

(F) The "no" keyword is recognized and executed at compile time, and
returns no useful value.  See L<perlmod>.

=end original

(F) "no" キーワードは、コンパイル時に認識され、実行されるもので、
意味のある値を返しません。
L<perlmod> を参照してください。

=item No output file after > on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a lone '>' at the end of the command line, so it
doesn't know where you wanted to redirect stdout.

=end original

(F) VMS 特有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、コマンドラインの
最後に単独の '>' を発見したので、stdout をどこにリダイレクトしたいのかが
わかりませんでした。

=item No output file after > or >> on command line

=begin original

(F) An error peculiar to VMS.  Perl handles its own command line
redirection, and found a '>' or a '>>' on the command line, but can't
find the name of the file to which to write data destined for stdout.

=end original

(F) VMS 特有のエラーです。
Perl は独自にコマンドラインのリダイレクトを扱っていて、コマンドラインに
'>' や '>>' を発見しましたが、stdout を書き込むためのファイル名が
見つかりませんでした。

=item No package name allowed for variable %s in "our"

=begin original

(F) Fully qualified variable names are not allowed in "our"
declarations, because that doesn't make much sense under existing
semantics.  Such syntax is reserved for future extensions.

=end original

(F) 完全修飾変数名は "our" 宣言では使えません;
なぜなら現在の動作ではほとんど意味がないからです。
そのような文法は将来の拡張に予約されています。

=item No Perl script found in input

=begin original

(F) You called C<perl -x>, but no line was found in the file beginning
with #! and containing the word "perl".

=end original

(F) C<perl -x> を呼び出しましたが、そのファイルに #! で始まり、
"perl" という語を含む行が見つかりませんでした。

=item No setregid available

=begin original

(F) Configure didn't find anything resembling the setregid() call for
your system.

=end original

(F) Configure が、システム上に setregid() のような関数を
見つけられませんでした。

=item No setreuid available

=begin original

(F) Configure didn't find anything resembling the setreuid() call for
your system.

=end original

(F) Configure が、システム上に setreuid() のような関数を
見つけられませんでした。

=item No space allowed after -%c

=begin original

(F) The argument to the indicated command line switch must follow
immediately after the switch, without intervening spaces.

=end original

(F) 示されたコマンドラインスイッチの引数は、
スイッチの直後にスペースを空けないで書く必要があります。

=item No %s specified for -%c

=begin original

(F) The indicated command line switch needs a mandatory argument, but
you haven't specified one.

=end original

(F) 指示されたコマンドラインオプションには引数が必須ですが、それが
指定されませんでした。

=item No such pipe open

=begin original

(P) An error peculiar to VMS.  The internal routine my_pclose() tried to
close a pipe which hadn't been opened.  This should have been caught
earlier as an attempt to close an unopened filehandle.

=end original

(P) VMS 特有のエラーです。
内部ルーチンである my_pclose() が、開いていないパイプを閉じようとしました。
これは開いていないファイルハンドルを閉じようとしたとしてもっと早くに
捕捉されるべきものです。

=item No such pseudo-hash field "%s"

=begin original

(F) You tried to access an array as a hash, but the field name used is
not defined.  The hash at index 0 should map all valid field names to
array indices for that to work.

=end original

(F) 配列にハッシュとしてアクセスしようとしましたが、使われたフィールド名は
未定義です。
インデックス 0 のハッシュは全ての有効なフィールド名が動作する配列
インデックスにマッピングされるべきです。

=item No such pseudo-hash field "%s" in variable %s of type %s

=begin original

(F) You tried to access a field of a typed variable where the type does
not know about the field name.  The field names are looked up in the
%FIELDS hash in the type package at compile time.  The %FIELDS hash is
%usually set up with the 'fields' pragma.

=end original

(F) 型がフィールド名について知らない型付き変数のフィールドに
アクセスしようとしました。
フィールド名はコンパイル時に型パッケージの %FIELDS ハッシュから
検索されます。
%FIELDS ハッシュは通常 'fields' プラグマで設定されます。

=item No such signal: SIG%s

=begin original

(W signal) You specified a signal name as a subscript to %SIG that was
not recognized.  Say C<kill -l> in your shell to see the valid signal
names on your system.

=end original

(W signal) %SIG の添字として認識できないシグナル名を指定しました。
お使いのシステムで使用可能なシグナル名を調べるには、
シェル上で C<kill -l> などとしてください。

=item Not a CODE reference

=begin original

(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the ref() function to find out what kind of ref it really was.  See
also L<perlref>.

=end original

(F) Perl がコード値 (サブルーティン) へのリファレンスを
評価しようとしましたが、別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> も参照してください。

=item Not a format reference

=begin original

(F) I'm not sure how you managed to generate a reference to an anonymous
format, but this indicates you did, and that it didn't exist.

=end original

(F) どのように無名のフォーマットへのリファレンスを生成したのかは
わかりませんが、このメッセージは、それが指定されて、
存在しなかったことを示します。

=item Not a GLOB reference

=begin original

(F) Perl was trying to evaluate a reference to a "typeglob" (that is, a
symbol table entry that looks like C<*foo>), but found a reference to
something else instead.  You can use the ref() function to find out what
kind of ref it really was.  See L<perlref>.

=end original

(F) Perl が「型グロブ」(これは、C<*foo> のような
シンボルテーブルエントリです) へのリファレンスを評価しようとしましたが、
別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> を参照してください。

=item Not a HASH reference

=begin original

(F) Perl was trying to evaluate a reference to a hash value, but found a
reference to something else instead.  You can use the ref() function to
find out what kind of ref it really was.  See L<perlref>.

=end original

(F) Perl がハッシュ値へのリファレンスを評価しようとしましたが、
別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> を参照してください。

=item Not an ARRAY reference

=begin original

(F) Perl was trying to evaluate a reference to an array value, but found
a reference to something else instead.  You can use the ref() function
to find out what kind of ref it really was.  See L<perlref>.

=end original

(F) Perl が配列値へのリファレンスを評価しようとしましたが、
別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> を参照してください。

=item Not a perl script

=begin original

(F) The setuid emulator requires that scripts have a well-formed #! line
even on machines that don't support the #! construct.  The line must
mention perl.

=end original

(F) setuid エミュレータでは、たとえマシンがサポートしていなくても、
完全な形の #! 行がスクリプトに書かれていなければなりません。
この行で指定されるのは、perl でなければなりません。

=item Not a SCALAR reference

=begin original

(F) Perl was trying to evaluate a reference to a scalar value, but found
a reference to something else instead.  You can use the ref() function
to find out what kind of ref it really was.  See L<perlref>.

=end original

(F) Perl がスカラ値へのリファレンスを評価しようとしましたが、
別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> を参照してください。

=item Not a subroutine reference

=begin original

(F) Perl was trying to evaluate a reference to a code value (that is, a
subroutine), but found a reference to something else instead.  You can
use the ref() function to find out what kind of ref it really was.  See
also L<perlref>.

=end original

(F) Perl がコード値 (サブルーティン) へのリファレンスを
評価しようとしましたが、別のものへのリファレンスでした。
実際にどんな種類のリファレンスかを調べるには、ref() 関数を
使うことができます。
L<perlref> も参照してください。

=item Not a subroutine reference in overload table

=begin original

(F) An attempt was made to specify an entry in an overloading table that
doesn't somehow point to a valid subroutine.  See L<overload>.

=end original

(F) 多重定義テーブルで、有効なサブルーティンを指していないエントリを
指定しようとしました。
L<overload> を参照してください。

=item Not enough arguments for %s

=begin original

(F) The function requires more arguments than you specified.

=end original

(F) この関数は、指定したよりも多くの引数を必要とします。

=item Not enough format arguments

=begin original

(W syntax) A format specified more picture fields than the next line
supplied.  See L<perlform>.

=end original

(W syntax) 指定したフォーマットに、次の行で指定したより多くの
ピクチャフィールドがあります。
L<perlform> を参照してください。

=item %s: not found

=begin original

(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

=end original

(A) スクリプトを Perl ではなく Bourne shell で実行しようとしています。
#! ラインをチェックするか、手動でスクリプトを Perl に渡してください。

=item no UTC offset information; assuming local time is UTC

=begin original

(S) A warning peculiar to VMS.  Perl was unable to find the local
timezone offset, so it's assuming that local system time is equivalent
to UTC.  If it's not, define the logical name
F<SYS$TIMEZONE_DIFFERENTIAL> to translate to the number of seconds which
need to be added to UTC to get local time.

=end original

(S) VMS 固有の警告です。
Perl はローカルタイムゾーンオフセットを見つけることができなかったので、
ローカルシステムタイムは UTC と等価であると仮定します。
もし違うなら、論理名 F<SYS$TIMEZONE_DIFFERENTIAL> に、UTC からローカル
時刻を得るために加える必要がある秒数を定義してください。

=item Null filename used

=begin original

(F) You can't require the null filename, especially because on many
machines that means the current directory!  See L<perlfunc/require>.

=end original

(F) 特に、多くのマシンでカレントディレクトリを意味するため、
空のファイル名は require できません!
L<perlfunc/require> を参照してください。

=item NULL OP IN RUN

=begin original

(P debugging) Some internal routine called run() with a null opcode
pointer.

=end original

(P debugging) 内部ルーティンで、ヌル opcode ポインタで run() を
呼んだものがあります。

=item Null picture in formline

=begin original

(F) The first argument to formline must be a valid format picture
specification.  It was found to be empty, which probably means you
supplied it an uninitialized value.  See L<perlform>.

=end original

(F) formline の第 1 引数は有効なフォーマットピクチャー指定でなければ
なりません。
これが空でした; おそらく初期化していない値を指定したのでしょう。
L<perlform> を参照してください。

=item Null realloc

=begin original

(P) An attempt was made to realloc NULL.

=end original

(P) realloc NULL を行なおうとしました。

=item NULL regexp argument

=begin original

(P) The internal pattern matching routines blew it big time.

=end original

(P) 内部パターンマッチルーティンが、大当たりです。

=item NULL regexp parameter

=begin original

(P) The internal pattern matching routines are out of their gourd.

=end original

(P) 内部パターンマッチルーティンが、狂っています。

=item Number too long

=begin original

(F) Perl limits the representation of decimal numbers in programs to
about about 250 characters.  You've exceeded that length.  Future
versions of Perl are likely to eliminate this arbitrary limitation.  In
the meantime, try using scientific notation (e.g. "1e6" instead of
"1_000_000").

=end original

Perl はプログラム中での十進数の表現をおよそ 250 文字に制限しています。
この制限を越えました。
Perl の将来のバージョンではこの恣意的な制限は除去されるでしょう。
それまでの間は、科学的な記述法("1_000_000" ではなく "1e6")を
使用してください。

=item Octal number in vector unsupported

=begin original

(F) Numbers with a leading C<0> are not currently allowed in vectors.
The octal number interpretation of such numbers may be supported in a
future version.

=end original

頭に C<0> の付いた数値は現在のところベクタとしては使えません。
このような数値を 8 進数として解釈する機能は将来のバージョンで
対応されるでしょう。

=item Octal number > 037777777777 non-portable

=begin original

(W portable) The octal number you specified is larger than 2**32-1
(4294967295) and therefore non-portable between systems.  See
L<perlport> for more on portability concerns.

=end original

(W portable) 指定した 8 進数が 2**32-1 (4294967295) より大きいので、
システム間で移植性がありません。
移植性に関するさらなる考察については L<perlport> を参照してください。

=begin original

See also L<perlport> for writing portable code.

=end original

移植性のあるコードの書き方についても L<perlport> を参照してください。

=item Odd number of arguments for overload::constant

=begin original

(W) The call to overload::constant contained an odd number of arguments.
The arguments should come in pairs.

=end original

(W) 奇数の数の引数で overload::constant を呼び出しました。
引数はペアになっている必要があります。

=item Odd number of elements in hash assignment

=begin original

(W misc) You specified an odd number of elements to initialize a hash,
which is odd, because hashes come in key/value pairs.

=end original

(W misc) ハッシュリストへの要素の数が奇数でした。
ハッシュリストは、key/value のペアで与えられますから、
これは奇妙なことです。

=item Offset outside string

=begin original

(F) You tried to do a read/write/send/recv operation with an offset
pointing outside the buffer.  This is difficult to imagine.  The sole
exception to this is that C<sysread()>ing past the buffer will extend
the buffer and zero pad the new area.

=end original

(F) バッファの外を指すオフセットで read/write/send/recv 操作を
しようとしました。
これは想像しにくいことです。
唯一の例外は、バッファを通り過ぎて C<sysread()> するとバッファが
拡張され、新しいエリアには 0 でパッディングされます。

=item -%s on unopened filehandle %s

=begin original

(W unopened) You tried to invoke a file test operator on a filehandle
that isn't open.  Check your logic.  See also L<perlfunc/-X>.

=end original

(W unopened) 開いていないファイルハンドルに対してファイルテスト演算子を
使おうとしました。
論理をチェックしてください。
L<perlfunc/-X> も参照してください。

=item %s() on unopened %s %s

=begin original

(W unopened) An I/O operation was attempted on a filehandle that was
never initialized.  You need to do an open(), a sysopen(), or a socket()
call, or call a constructor from the FileHandle package.

=end original

(W unopened) 初期化していないファイルハンドルに I/O 操作をしようとしました。
open(), sysopen(), socket() を呼び出すか、FileHandle パッケージの
コンストラクタを呼び出す必要があります。

=item oops: oopsAV

=begin original

(S internal) An internal warning that the grammar is screwed up.

=end original

(S internal) 文法がおかしくなったことを示す内部警告です。

=item oops: oopsHV

=begin original

(S internal) An internal warning that the grammar is screwed up.

=end original

(S internal) 文法がおかしくなったことを示す内部警告です。

=item Operation `%s': no method found, %s

=begin original

(F) An attempt was made to perform an overloaded operation for which no
handler was defined.  While some handlers can be autogenerated in terms
of other handlers, there is no default handler for any operation, unless
C<fallback> overloading key is specified to be true.  See L<overload>.

=end original

(F) ハンドラが定義されていないオーバーロード操作が行われました。
一部のハンドラは他のハンドラから自動生成されますが、C<fallback>
オーバーロードキーが真に指定されていない限り、どの動作にも
デフォルトのハンドラはありません。
L<overload> を参照してください。

=item Operator or semicolon missing before %s

=begin original

(S ambiguous) You used a variable or subroutine call where the parser
was expecting an operator.  The parser has assumed you really meant to
use an operator, but this is highly likely to be incorrect.  For
example, if you say "*foo *foo" it will be interpreted as if you said
"*foo * 'foo'".

=end original

(S ambiguous) パーサーが演算子を装置している場所で変数やサブルーチン
呼び出しが使われました。
パーサーはあなたが本当に演算子を使おうとしていると仮定しますが、
これは大抵正しくありません。
例えば、"*foo *foo" とすると、"*foo * 'foo'" としたとして解釈されます。

=item "our" variable %s redeclared

=begin original

(W misc) You seem to have already declared the same global once before
in the current lexical scope.

=end original

(W misc) 現在のレキシカルスコープで、既に同じ名前のグローバル変数を
宣言しているようです。

=item Out of memory!

=begin original

(X) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request.  Perl has
no option but to exit immediately.

=end original

(X) 要求を満たすだけの、十分な残メモリ (または、仮想メモリ) が
取得できないことを示す、0 を malloc() 関数が返しました。
Perl は直ちに終了するしかありませんでした。

=item Out of memory during "large" request for %s

=begin original

(F) The malloc() function returned 0, indicating there was insufficient
remaining memory (or virtual memory) to satisfy the request. However,
the request was judged large enough (compile-time default is 64K), so a
possibility to shut down by trapping this error is granted.

=end original

(F) malloc() 関数が 0 を返しました; これは要求を満たすメモリ
(または仮想メモリ)が不十分であることを示しています。
しかし、要求が十分大きい(コンパイル時のデフォルトは 64K)ので、
このエラーをトラップすることでシャットダウンできる可能性があります。

=item Out of memory during request for %s

=begin original

(X|F) The malloc() function returned 0, indicating there was
insufficient remaining memory (or virtual memory) to satisfy the
request.

=end original

(X|F) malloc() 関数が 0 を返しました; これは要求を満たすメモリ
(または仮想メモリ)が不十分であることを示しています。

=begin original

The request was judged to be small, so the possibility to trap it
depends on the way perl was compiled.  By default it is not trappable.
However, if compiled for this, Perl may use the contents of C<$^M> as an
emergency pool after die()ing with this message.  In this case the error
is trappable I<once>, and the error message will include the line and file
where the failed request happened.

=end original

要求は小さいものと判定されたので、これをトラップできる確率は perl が
どのようにコンパイルされたかに依存します。
デフォルトではこれはトラップできません。
しかし、もしこのためにコンパイルすると、Perl はこのメッセージと共に
die() した後の非常用エリアとして C<$^M> の内容を使います。
この場合エラーは I<一度だけ> トラップ可能で、エラーメッセージは失敗した
要求が起きたファイルと行番号を含んでいます。

=item Out of memory during ridiculously large request

=begin original

(F) You can't allocate more than 2^31+"small amount" bytes.  This error
is most likely to be caused by a typo in the Perl program. e.g.,
C<$arr[time]> instead of C<$arr[$time]>.

=end original

(F) 2^31+「少量」バイト以上割り当てることはできません。
このエラーはほとんどの場合(C<$arr[$time]> の代わりに
C<$arr[time]> のような) Perl プログラムのタイプミスが原因です。

=item Out of memory for yacc stack

=begin original

(F) The yacc parser wanted to grow its stack so it could continue
parsing, but realloc() wouldn't give it more memory, virtual or
otherwise.

=end original

(F) yacc パーサーが解析を続けるために、スタックを広げようとしましたが、
realloc() が仮想やその他のメモリを確保できませんでした。

=item @ outside of string

=begin original

(F) You had a pack template that specified an absolute position outside
the string being unpacked.  See L<perlfunc/pack>.

=end original

(F) unpack される文字列の外に絶対位置指定している、
pack テンプレートを指定しました。
L<perlfunc/pack> を参照してください。

=item %s package attribute may clash with future reserved word: %s

=begin original

(W reserved) A lowercase attribute name was used that had a
package-specific handler.  That name might have a meaning to Perl itself
some day, even though it doesn't yet.  Perhaps you should use a
mixed-case attribute name, instead.  See L<attributes>.

=end original

(W reserved) パッケージ固有のハンドラが、小文字の属性名を使っています。
この名前は、たとえ今は使っていなくても、 Perl 自身がいつか使うかもしれません。
おそらく代わりに大文字小文字の混じった属性名を使うべきでしょう。
L<attributes> を参照してください。

=item page overflow

=begin original

(W io) A single call to write() produced more lines than can fit on a
page.  See L<perlform>.

=end original

(W io) write() の 1 度の呼び出しで、1 ページに収まるより
多くの行ができました。
L<perlform> を参照してください。

=item panic: %s

=begin original

(P) An internal error.

=end original

(P) 内部エラーです。

=item panic: ck_grep

=begin original

(P) Failed an internal consistency check trying to compile a grep.

=end original

(P) grep をコンパイルしようとして、内部の一貫性チェックに
引っ掛かりました。

=item panic: ck_split

=begin original

(P) Failed an internal consistency check trying to compile a split.

=end original

(P) split をコンパイルしようとして、内部の一貫性チェックに
引っ掛かりました。

=item panic: corrupt saved stack index

=begin original

(P) The savestack was requested to restore more localized values than
there are in the savestack.

=end original

(P) セーブスタックにある以上のローカル化した値を元に戻す
要求がありました。

=item panic: del_backref

=begin original

(P) Failed an internal consistency check while trying to reset a weak
reference.

=end original

(P) 弱いリファレンスをリセットしようとしたときに内部の
一貫性チェックに引っ掛かりました。

=item panic: die %s

=begin original

(P) We popped the context stack to an eval context, and then discovered
it wasn't an eval context.

=end original

(P) eval コンテキストへコンテキストスタックをポップしたあと、
eval コンテキストでないことがわかりました。

=item panic: pp_match

=begin original

(P) The internal pp_match() routine was called with invalid operational
data.

=end original

(P) 内部の pp_match() ルーティンが、無効な省略可能データを
付けて呼ばれました。

=item panic: do_subst

=begin original

(P) The internal pp_subst() routine was called with invalid operational
data.

=end original

(P) 内部の pp_subst() ルーティンが、無効な省略可能データを
付けて呼ばれました。

=item panic: do_trans_%s

=begin original

(P) The internal do_trans routines were called with invalid operational
data.

=end original

(P) 内部の pp_trans ルーティンが、無効な省略可能データを
付けて呼ばれました。

=item panic: frexp

=begin original

(P) The library function frexp() failed, making printf("%f") impossible.

=end original

(P) ライブラリ関数 frexp() が失敗したので、printf("%f") ができません。

=item panic: goto

=begin original

(P) We popped the context stack to a context with the specified label,
and then discovered it wasn't a context we know how to do a goto in.

=end original

(P) 指定したラベルを伴うコンテキストへコンテキストスタックを
ポップしたあと、どのように goto するかがわかっている
コンテキストでないことがわかりました。

=item panic: INTERPCASEMOD

=begin original

(P) The lexer got into a bad state at a case modifier.

=end original

(P) 大文字小文字修飾子のところで、字句解析部がおかしな状態に陥りました。

=item panic: INTERPCONCAT

=begin original

(P) The lexer got into a bad state parsing a string with brackets.

=end original

(P) 中括弧を伴う文字列を解析中に、字句解析部がおかしな状態に陥りました。

=item panic: kid popen errno read

=begin original

(F) forked child returned an incomprehensible message about its errno.

=end original

(F) fork した子プロセスが errno に関して不完全なメッセージを返しました。

=item panic: last

=begin original

(P) We popped the context stack to a block context, and then discovered
it wasn't a block context.

=end original

(P) block コンテキストへコンテキストスタックをポップしたあと、
block コンテキストでないことがわかりました。

=item panic: leave_scope clearsv

=begin original

(P) A writable lexical variable became read-only somehow within the
scope.

=end original

(P) 書き込み可能な字句スコープ変数が、どういうわけか、スコープ内で
リードオンリーになりました。

=item panic: leave_scope inconsistency

=begin original

(P) The savestack probably got out of sync.  At least, there was an
invalid enum on the top of it.

=end original

(P) おそらく、セーブスタックの同期がとれていません。
少なくとも、トップに不正な enum がありました。

=item panic: magic_killbackrefs

=begin original

(P) Failed an internal consistency check while trying to reset all weak
references to an object.

=end original

(P) あるオブジェクトへの全ての弱い参照をリセットしようとした時に内部の
一貫性チェックに引っ掛かりました。

=item panic: malloc

=begin original

(P) Something requested a negative number of bytes of malloc.

=end original

(P) malloc に負のバイト数で要求が行なわれました。

=item panic: mapstart

=begin original

(P) The compiler is screwed up with respect to the map() function.

=end original

(P) コンパイラが、map() 関数に関しておかしくなりました。

=item panic: null array

=begin original

(P) One of the internal array routines was passed a null AV pointer.

=end original

(P) 内部配列ルーティンで、ヌル AV ポインタを渡されたものがありました。

=item panic: pad_alloc

=begin original

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=end original

(P) コンパイラが、一時領域や字句形式を割り当て、解放している
スクラッチパッドについて混乱しました。

=item panic: pad_free curpad

=begin original

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=end original

(P) コンパイラが、一時領域や字句形式を割り当て、解放している
スクラッチパッドについて混乱しました。

=item panic: pad_free po

=begin original

(P) An invalid scratch pad offset was detected internally.

=end original

(P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

=item panic: pad_reset curpad

=begin original

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=end original

(P) コンパイラが、一時領域や字句形式を割り当て、解放している
スクラッチパッドについて混乱しました。

=item panic: pad_sv po

=begin original

(P) An invalid scratch pad offset was detected internally.

=end original

(P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

=item panic: pad_swipe curpad

=begin original

(P) The compiler got confused about which scratch pad it was allocating
and freeing temporaries and lexicals from.

=end original

(P) コンパイラが、一時領域や字句形式を割り当て、解放している
スクラッチパッドについて混乱しました。

=item panic: pad_swipe po

=begin original

(P) An invalid scratch pad offset was detected internally.

=end original

(P) 不正なスクラッチパッドのオフセットが、内部的に検出されました。

=item panic: pp_iter

=begin original

(P) The foreach iterator got called in a non-loop context frame.

=end original

(P) foreach の繰返し子が、ループ文脈以外のところで呼ばれました。

=item panic: pp_split

=begin original

(P) Something terrible went wrong in setting up for the split.

=end original

(P) split の準備中に何かまずいことが起こってしまいました。

=item panic: realloc

=begin original

(P) Something requested a negative number of bytes of realloc.

=end original

(P) 何か、realloc に負のバイト数を要求したものがあります。

=item panic: restartop

=begin original

(P) Some internal routine requested a goto (or something like it), and
didn't supply the destination.

=end original

(P) 内部ルーティンから goto (または、同じようなもの) が
要求されましたが、飛び先が与えれていません。

=item panic: return

=begin original

(P) We popped the context stack to a subroutine or eval context, and
then discovered it wasn't a subroutine or eval context.

=end original

(P) サブルーティンコンテキストや eval コンテキストへ、
コンテキストスタックをポップしたあと、サブルーティンコンテキストや
eval コンテキストでないことがわかりました。

=item panic: scan_num

=begin original

(P) scan_num() got called on something that wasn't a number.

=end original

(P) scan_num() が、何か数字でないものに対して呼ばれました。

=item panic: sv_insert

=begin original

(P) The sv_insert() routine was told to remove more string than there
was string.

=end original

(P) sv_insert() ルーティンが、存在する以上の文字列を削除するように
指示されました。

=item panic: top_env

=begin original

(P) The compiler attempted to do a goto, or something weird like that.

=end original

(P) コンパイラが、goto など妙なことを行なおうとしました。

=item panic: yylex

=begin original

(P) The lexer got into a bad state while processing a case modifier.

=end original

(P) 大文字小文字修飾子を処理中に、字句解析部がおかしな状態に陥りました。

=item panic: utf16_to_utf8: odd bytelen

=begin original

(P) Something tried to call utf16_to_utf8 with an odd (as opposed
to even) byte length. 

=end original

(P) 何かが(偶数ではなく)奇数のバイト長で utf16_to_utf8 を
呼び出そうとしました。

=item Parentheses missing around "%s" list

=begin original

(W parenthesis) You said something like

=end original

(W parenthesis) おそらく以下のようにしたのでしょう:

    my $foo, $bar = @_;

=begin original

when you meant

=end original

以下のようにすべきです:

    my ($foo, $bar) = @_;

=begin original

Remember that "my", "our", and "local" bind tighter than comma.

=end original

"my" や "local" は、コンマよりも強く結合することを忘れないでください。

=item Perl %s required--this is only version %s, stopped

=begin original

(F) The module in question uses features of a version of Perl more
recent than the currently running version.  How long has it been since
you upgraded, anyway?  See L<perlfunc/require>.

=end original

(F) 問題のモジュールは、現在実行中の Perl よりも最近のバージョンの
機能を使っています。
ところで、いつからアップグレードしていないのですか?
L<perlfunc/require> を参照してください。

=item PERL_SH_DIR too long

=begin original

(F) An error peculiar to OS/2. PERL_SH_DIR is the directory to find the
C<sh>-shell in.  See "PERL_SH_DIR" in L<perlos2>.

=end original

(F) OS/2 固有のエラーです。
PERL_SH_DIR は C<sh>-shell を見つけるためのディレクトリです。
L<perlos2> の "PERL_SH_DIR" を参照してください。

=item perl: warning: Setting locale failed.

=begin original

(S) The whole warning message will look something like:

=end original

(S) 警告全体は以下のような形になります:

	perl: warning: Setting locale failed.
	perl: warning: Please check that your locale settings:
	        LC_ALL = "En_US",
	        LANG = (unset)
	    are supported and installed on your system.
	perl: warning: Falling back to the standard locale ("C").

=begin original

Exactly what were the failed locale settings varies.  In the above the
settings were that the LC_ALL was "En_US" and the LANG had no value.
This error means that Perl detected that you and/or your operating
system supplier and/or system administrator have set up the so-called
locale system but Perl could not use those settings.  This was not
dead serious, fortunately: there is a "default locale" called "C" that
Perl can and will use, the script will be run.  Before you really fix
the problem, however, you will get the same error message each time
you run Perl.  How to really fix the problem can be found in
L<perllocale> section B<LOCALE PROBLEMS>.

=end original

正確にどのロケール設定が失敗したのかは様々です。
上記では設定は LC_ALL は "En_US" で、LANG は空でした。
このエラーは、あなたや OS 供給者やシステム管理者がロケールシステムと呼ばれる
ものをセットアップしましたが、Perl がこれらの設定を使えないことを
検出したことを意味します。
これは幸いにして致命的ではありません; Perl が使用できる "C" と呼ばれる
「デフォルトロケール」が存在するので、スクリプトは実行されます。
しかし、本当にこの問題を解決するまでは、Perl を実行する毎に同じエラー
メッセージが表示されます。
本当にこの問題を修正する方法は L<perllocale> の B<LOCALE PROBLEMS> の
章にあります。

=item Permission denied

=begin original

(F) The setuid emulator in suidperl decided you were up to no good.

=end original

(F) suidperl の setuid エミュレータは、実行者が安全とは
言えないと判断しました。

=item pid %x not a child

=begin original

(W exec) A warning peculiar to VMS.  Waitpid() was asked to wait for a
process which isn't a subprocess of the current process.  While this is
fine from VMS' perspective, it's probably not what you intended.

=end original

(W exec) VMS 固有の警告です。
現在のプロセスのサブプロセスでないプロセスに Waitpid() を使いました。
これは VMS の観点からは問題ありませんが、おそらくあなたの望んでいることでは
ないでしょう。

=item POSIX syntax [%s] belongs inside character classes

=begin original

(W unsafe) The character class constructs [: :], [= =], and [. .]  go
I<inside> character classes, the [] are part of the construct, for
example: /[012[:alpha:]345]/.  Note that [= =] and [. .] are not
currently implemented; they are simply placeholders for future
extensions and will cause fatal errors.

=end original

(W regexp) 例えば /[012[:alpha:]345]/ のように、文字クラス構造 [: :], [= =],
[. .] が文字クラスの I<内側> にあり、[] は構造の一部です。
[= =] と [. .] は現在のところ実装されていないことに注意してください;
これらは単に将来の拡張のためのプレースホルダであり、致命的エラーを
生成します。

=item POSIX  syntax [. .] is reserved for future extensions

=begin original

(F regexp) Within regular expression character classes ([]) the syntax
beginning with "[." and ending with ".]" is reserved for future
extensions.  If you need to represent those character sequences inside
a regular expression character class, just quote the square brackets
with the backslash: "\[." and ".\]".

=end original

(F regexp) 正規表現文字クラス ([]) の中では、"[." で始まる文法と ".]" で
終わる文法は将来の拡張のために予約されます。
正規表現文字クラスの中でこのような文字シーケンスを表現する必要がある
場合には、"\[." と ".\]" のように、大かっこをバックスラッシュで
クォートしてください。

=item POSIX syntax [= =] is reserved for future extensions

=begin original

(F) Within regular expression character classes ([]) the syntax
beginning with "[=" and ending with "=]" is reserved for future
extensions.  If you need to represent those character sequences inside
a regular expression character class, just quote the square brackets
with the backslash: "\[=" and "=\]".

=end original

(F) 正規表現文字クラス ([]) の中では、"[=" で始まる文法と "=]" で
終わる文法は将来の拡張のために予約されます。
正規表現文字クラスの中でこのような文字シーケンスを表現する必要がある
場合には、"\[=" と "=\]" のように、大かっこをバックスラッシュで
クォートしてください。

=item POSIX class [:%s:] unknown

=begin original

(F) The class in the character class [: :] syntax is unknown.  See
L<perlre>.

=end original

(F) 文字クラス [: :] 文法の中のクラスは不明です。
L<perlre> を参照してください。

=item POSIX getpgrp can't take an argument

=begin original

(F) Your system has POSIX getpgrp(), which takes no argument, unlike
the BSD version, which takes a pid.

=end original

(F) お使いのシステムは、引数に pid をとる BSD バージョンの
getpgrp() と違って、引数をとらない POSIX のものを使っています。

=item Possible attempt to put comments in qw() list

=begin original

(W qw) qw() lists contain items separated by whitespace; as with literal
strings, comment characters are not ignored, but are instead treated as
literal data.  (You may have used different delimiters than the
parentheses shown here; braces are also frequently used.)

=end original

(W qw) qw() リストは空白で分割されたアイテムを含んでいます;
リテラル文字列では、コメント文字無視されず、リテラルデータとして扱われます。
(かっこ以外のデリミタを使うこともできます; 中かっこもよく使われます。)

=begin original

You probably wrote something like this:

=end original

おそらく以下のように書いたのでしょう:

    @list = qw(
	a # a comment
        b # another comment
    );

=begin original

when you should have written this:

=end original

以下のように書くべきです:

    @list = qw(
	a
        b
    );

=begin original

If you really want comments, build your list the
old-fashioned way, with quotes and commas:

=end original

本当にコメントをつけたいのなら、
リストを昔のクォートとカンマの形で書いてください。

    @list = (
        'a',    # a comment
        'b',    # another comment
    );

=item Possible attempt to separate words with commas

=begin original

(W qw) qw() lists contain items separated by whitespace; therefore
commas aren't needed to separate the items.  (You may have used
different delimiters than the parentheses shown here; braces are also
frequently used.)

=end original

(W qw) qw() リストに空白で分割された項目があります;
そのため、カンマは項目を分割する必要がありません。
(ここで使われているのと違うデリミタを用いているかもしれません;
大括弧もよく使われます。)

=begin original

You probably wrote something like this:

=end original

おそらく以下のように書いたのでしょう:

    qw! a, b, c !;

=begin original

which puts literal commas into some of the list items.  Write it without
commas if you don't want them to appear in your data:

=end original

リスト要素の中にリテラルのカンマを書いています。
データの中にカンマを出したくないなら、カンマなしで書きます:

    qw! a b c !;

=item Possible memory corruption: %s overflowed 3rd argument

=begin original

(F) An ioctl() or fcntl() returned more than Perl was bargaining for.
Perl guesses a reasonable buffer size, but puts a sentinel byte at the
end of the buffer just in case.  This sentinel byte got clobbered, and
Perl assumes that memory is now corrupted.  See L<perlfunc/ioctl>.

=end original

(F) ioctl() や fcntl() が、Perl が求めていた以上のものを返してきました。
Perl は、適量のバッファサイズを見積もりますが、念のためにバッファの
最後に目印を付けています。
この目印が壊されたため、Perl はメモリの破壊が起こったと判断しました。
L<perlfunc/ioctl> を参照してください。

=item Possible Y2K bug: %s

=begin original

(W y2k) You are concatenating the number 19 with another number, which
could be a potential Year 2000 problem.

=end original

(W y2k) 数値 19 を他の数値と結合しています; これは潜在的な
2000 年問題かもしれません。

=item pragma "attrs" is deprecated, use "sub NAME : ATTRS" instead

=begin original

(W deprecated) You have written something like this:

=end original

(W deprecated) おそらく以下のように書いたのでしょう:

    sub doit
    {
        use attrs qw(locked);
    }

=begin original

You should use the new declaration syntax instead.

=end original

代わりに新しい定義の文法で書くべきです:

    sub doit : locked
    {
        ...

=begin original

The C<use attrs> pragma is now obsolete, and is only provided for
backward-compatibility. See L<perlsub/"Subroutine Attributes">.

=end original

C<use attrs> プラグマはもう古いもので、後方互換性のためだけに
提供されています。
L<perlsub/"Subroutine Attributes"> を参照してください。

=item Precedence problem: open %s should be open(%s)

=begin original

(S precedence) The old irregular construct

=end original

(S precedence) 古い変則的な構文

    open FOO || die;

=begin original

is now misinterpreted as

=end original

は現在は、Perl 5 の文法の厳しい正規化の結果、単項演算子か
リスト演算子と解釈されますので、

    open(FOO || die);

=begin original

because of the strict regularization of Perl 5's grammar into unary and
list operators.  (The old open was a little of both.)  You must put
parentheses around the filehandle, or use the new "or" operator instead
of "||".

=end original

という風に誤った解釈がなされます。
(古い open は、単項演算子とリスト演算子の中間のようなものでした。)
ファイルハンドルの前後を括弧で囲むか、"||" 演算子の代わりに
"or" 演算子を使わなくてはなりません。

=item Premature end of script headers

=begin original

See Server error.

=end original

"Server error"を参照してください。

=item printf() on closed filehandle %s

=begin original

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your logic flow.

=end original

(W closed) 書き込みを行なおうとしたファイルハンドルは、既にクローズされています。
論理フローをチェックしてください。

=item print() on closed filehandle %s

=begin original

(W closed) The filehandle you're printing on got itself closed sometime
before now.  Check your logic flow.

=end original

(W closed) print を行なおうとしたファイルハンドルは、既にクローズされています。
論理フローをチェックしてください。

=item Process terminated by SIG%s

=begin original

(W) This is a standard message issued by OS/2 applications, while *nix
applications die in silence.  It is considered a feature of the OS/2
port.  One can easily disable this by appropriate sighandlers, see
L<perlipc/"Signals">.  See also "Process terminated by SIGTERM/SIGINT"
in L<perlos2>.

=end original

(W) *nix アプリケーションは何も出力せずに終了しますが、
OS/2 アプリケーションはこれを標準メッセージとして出力します。
これは OS/2 版の仕様とみなされています。
適切なシグナルハンドラによって簡単に無効にできます;
L<perlipc/"Signals"> を参照してください。
L<perlos2> の "Process terminated by SIGTERM/SIGINT" も参照してください。

=item Prototype mismatch: %s vs %s

=begin original

(S unsafe) The subroutine being declared or defined had previously been
declared or defined with a different function prototype.

=end original

(S unsafe) 以前異なる関数プロトタイプで宣言または定義されたサブルーチンが
宣言または定義されました。

=item Quantifier in {,} bigger than %d before << HERE in regex m/%s/

=begin original

(F) There is currently a limit to the size of the min and max values of the
{min,max} construct. The << HERE shows in the regular expression about where
the problem was discovered. See L<perlre>.

=end original

現在のところ、{min,max} 構造の最大値と最小値には制限があります。
<< HERE で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Quantifier unexpected on zero-length expression before << HERE %s

=begin original

(W regexp) You applied a regular expression quantifier in a place where
it makes no sense, such as on a zero-width assertion.  Try putting the
quantifier inside the assertion instead.  For example, the way to match
"abc" provided that it is followed by three repetitions of "xyz" is
C</abc(?=(?:xyz){3})/>, not C</abc(?=xyz){3}/>.

=end original

(W regexp) 正規表現量指定子をゼロ幅アサーションのような意味のない場所に
適用しました。
代わりにアサーションの中に量指定子を置いてください。
例えば、"xyz" を 3 回繰り返した後の "abc" にマッチングさせるには、
C</abc(?=xyz){3}/> ではなく C</abc(?=(?:xyz){3})/> としてください。

=item Range iterator outside integer range

=begin original

(F) One (or both) of the numeric arguments to the range operator ".."
are outside the range which can be represented by integers internally.
One possible workaround is to force Perl to use magical string increment
by prepending "0" to your numbers.

=end original

(F) 範囲演算子 ".." の一つ(または両方)の数値引数が、内部で整数として
表現できる範囲を越えています。
回避方法のひとつとしては、数値の頭に "0" を付けることで Perl に
マジカル文字列インクリメントの使用を強制させることです。

=item readline() on closed filehandle %s

=begin original

(W closed) The filehandle you're reading from got itself closed sometime
before now.  Check your logic flow.

=end original

(W closed) 読み込みを行なおうとしたファイルハンドルは、既にクローズされています。
論理フローをチェックしてください。

=item Reallocation too large: %lx

=begin original

(F) You can't allocate more than 64K on an MS-DOS machine.

=end original

(F) MS-DOS マシンでは、64K を越えるメモリを割り当てることはできません。

=item realloc() of freed memory ignored

=begin original

(S malloc) An internal routine called realloc() on something that had
already been freed.

=end original

内部ルーチンが、何か既に解放されているものに対して realloc() を
呼び出しました。

=item Recompile perl with B<-D>DEBUGGING to use B<-D> switch

=begin original

(F debugging) You can't use the B<-D> option unless the code to produce
the desired output is compiled into Perl, which entails some overhead,
which is why it's currently left out of your copy.

=end original

(F debugging) Perl のコンパイル時に、適切な出力ルーティンが
組み込まれていなければ、B<-D> スイッチを使うことはできません。
これは、多少のオーバヘッドがかかるもので、それが現在使っている
Perl に組み込んでない理由でしょう。

=item Recursive inheritance detected in package '%s'

=begin original

(F) More than 100 levels of inheritance were used.  Probably indicates
an unintended loop in your inheritance hierarchy.

=end original

(F) 100 レベル以上の継承が行なわれました。
おそらく、継承階層の中で、予想外のループになっている部分があるものと
思われます。

=item Recursive inheritance detected while looking for method %s

=begin original

(F) More than 100 levels of inheritance were encountered while invoking
a method.  Probably indicates an unintended loop in your inheritance
hierarchy.

=end original

(F) メソッドの起動中に 100 レベル以上の継承が行なわれました。
おそらく、継承階層の中で、予想外のループになっている部分があるものと
思われます。

=item Reference found where even-sized list expected

=begin original

(W misc) You gave a single reference where Perl was expecting a list
with an even number of elements (for assignment to a hash). This usually
means that you used the anon hash constructor when you meant to use
parens. In any case, a hash requires key/value B<pairs>.

=end original

(W misc) Perl が(ハッシュへの代入のために)偶数の数の要素のリストを
想定しているところに 1 つのリファレンスを渡しました。
これは普通かっこを使うべきところで無名ハッシュコンストラクタを使ったことを
意味します。
とにかく、ハッシュはキー/値の B<組> を要求します。

    %hash = { one => 1, two => 2, };	# WRONG
    %hash = [ qw/ an anon array / ];	# WRONG
    %hash = ( one => 1, two => 2, );	# right
    %hash = qw( one 1 two 2 );			# also fine

=item Reference is already weak

=begin original

(W misc) You have attempted to weaken a reference that is already weak.
Doing so has no effect.

=end original

(W misc) 既に弱いリファレンスを弱めようとしました。
そうしても何の効果もありません。

=item Reference miscount in sv_replace()

=begin original

(W internal) The internal sv_replace() function was handed a new SV with
a reference count of other than 1.

=end original

(W internal) 内部の sv_replace() 関数が、参照数が 1 でない、新規の
SV を扱いました。

=item Reference to nonexistent group before << HERE in regex m/%s/

=begin original

(F) You used something like C<\7> in your regular expression, but there are
not at least seven sets of capturing parentheses in the expression. If you
wanted to have the character with value 7 inserted into the regular expression,
prepend a zero to make the number at least two digits: C<\07>

=end original

正規表現の中で C<\7> のような記述がありますが、
正規表現の中に値を捕らえる括弧が 7 つありません。
正規表現の中に値 7 を持つ文字を挿入したい場合、
ゼロをつけて最低二桁の数値にする必要があります: C<\07>

=begin original

The << HERE shows in the regular expression about where the problem was
discovered.

=end original

<< HERE で正規表現のどこに問題が発見されたかを示しています。

=item regexp memory corruption

=begin original

(P) The regular expression engine got confused by what the regular
expression compiler gave it.

=end original

(P) 正規表現コンパイラが渡したもので、正規表現エンジンが
処理できなくなりました。

=item Regexp out of space

=begin original

(P) A "can't happen" error, because safemalloc() should have caught it
earlier.

=end original

(P) safemalloc() が見つけるはずなので、「起こるはずのないエラー」です。

=item Repeat count in pack overflows

=begin original

(F) You can't specify a repeat count so large that it overflows your
signed integers.  See L<perlfunc/pack>.

=end original

(F) 繰り返し回数として符号付き整数をオーバーフローするような
値は指定できません。
L<perlfunc/pack> を参照してください。

=item Repeat count in unpack overflows

=begin original

(F) You can't specify a repeat count so large that it overflows your
signed integers.  See L<perlfunc/unpack>.

=end original

(F) 繰り返し回数として符号付き整数をオーバーフローするような
値は指定できません。
L<perlfunc/unpack> を参照してください。

=item Reversed %s= operator

=begin original

(W syntax) You wrote your assignment operator backwards.  The = must
always comes last, to avoid ambiguity with subsequent unary operators.

=end original

(W syntax) 代入演算子を逆順に書いています。
等号の後に単項演算子が続くときに、曖昧になるのを避けるため、
代入演算子では、等号 = が、最後にこないといけません。

=item Runaway format

=begin original

(F) Your format contained the ~~ repeat-until-blank sequence, but it
produced 200 lines at once, and the 200th line looked exactly like the
199th line.  Apparently you didn't arrange for the arguments to exhaust
themselves, either by using ^ instead of @ (for scalar variables), or by
shifting or popping (for array variables).  See L<perlform>.

=end original

(F) 定義したフォーマットに、空になるまで繰り返す ~~ が
含まれていましたが、一度に 200 行以上となり、199 行目と 200 行目が
全く同じになりました。
(スカラ変数には) @ の代わりに ^ を用いるか、(配列変数には) shift か pop を
行なうかして、引数が自動的になくなるようになっていないといけませんが、
そうなっていないようです。
L<perlform> を参照してください。

=item Scalar value @%s[%s] better written as $%s[%s]

=begin original

(W syntax) You've used an array slice (indicated by @) to select a
single element of an array.  Generally it's better to ask for a scalar
value (indicated by $).  The difference is that C<$foo[&bar]> always
behaves like a scalar, both when assigning to it and when evaluating its
argument, while C<@foo[&bar]> behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.

=end original

(W syntax) 配列の一つの要素を選ぶのに、(@ で示される) 配列
スライスを用いました。
一般には、($ で示される) スカラ値を使った方が良いと思われます。
違いは、C<$foo[&bar]> とした場合、代入の対象としたときにも、
添字を評価するときにも、常にスカラとして振る舞うのに対し、
C<@foo[&bar]> の場合には、代入の対象としてもリストとして振る舞い、
添字にもリストコンテキストを与えることになります。
これは、1 つの添字だけを期待するときには、おかしなこととなるでしょう。

=begin original

On the other hand, if you were actually hoping to treat the array
element as a list, you need to look into how references work, because
Perl will not magically convert between scalars and lists for you.  See
L<perlref>.

=end original

一方、もし本当に配列要素をリストとして扱いたい場合、リファレンスが
どのように働くかについて詳しく知る必要があります; なぜなら
Perl はスカラとリストを自動的に変換したりはしないからです。
L<perlref> を参照してください。

=item Scalar value @%s{%s} better written as $%s{%s}

=begin original

(W syntax) You've used a hash slice (indicated by @) to select a single
element of a hash.  Generally it's better to ask for a scalar value
(indicated by $).  The difference is that C<$foo{&bar}> always behaves
like a scalar, both when assigning to it and when evaluating its
argument, while C<@foo{&bar}> behaves like a list when you assign to it,
and provides a list context to its subscript, which can do weird things
if you're expecting only one subscript.

=end original

(W syntax) ハッシュの一つの要素を選ぶのに、(@ で示される) ハッシュ
スライスを用いました。
一般には、($ で示される) スカラ値を使った方が良いと思われます。
違いは、C<$foo{&bar}> とした場合、代入の対象としたときにも、
添字を評価するときにも、常にスカラとして振る舞うのに対し、
C<@foo{&bar}> の場合には、代入の対象としてもリストとして振る舞い、
添字にもリストコンテキストを与えることになります。
これは、1 つの添字だけを期待するときには、おかしなこととなるでしょう。

=begin original

On the other hand, if you were actually hoping to treat the hash element
as a list, you need to look into how references work, because Perl will
not magically convert between scalars and lists for you.  See
L<perlref>.

=end original

一方、もし本当にハッシュ要素をリストとして扱いたい場合、リファレンスが
どのように働くかについて詳しく知る必要があります; なぜなら
Perl はスカラとリストを自動的に変換したりはしないからです。
L<perlref> を参照してください。

=item Scalars leaked: %d

=begin original

(P) Something went wrong in Perl's internal bookkeeping of scalars:
not all scalar variables were deallocated by the time Perl exited.
What this usually indicates is a memory leak, which is of course bad,
especially if the Perl program is intended to be long-running.

=end original

(P) Perl 内部のスカラ管理で何かがおかしくなりました:
Perl 終了時に全てのスカラ変数が解放されませんでした。
これは普通メモリリークを示していて、これはもちろん悪いことですが、
Perl プログラムが長い間動作する場合には特にそうです。

=item Script is not setuid/setgid in suidperl

=begin original

(F) Oddly, the suidperl program was invoked on a script without a setuid
or setgid bit set.  This doesn't make much sense.

=end original

(F) 妙なことに、setuid ビット、もしくは setgid ビットが立っていない
スクリプトに対して、suidperl プログラムが起動されました。
これは意味がありません。

=item Search pattern not terminated

=begin original

(F) The lexer couldn't find the final delimiter of a // or m{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading C<$> from a variable C<$m> may cause this error.

=end original

(F) // もしくは m{} 構文の最後の区切り文字が見つかりませんでした。
括弧類の区切り文字では、ネストを数えることを忘れないでください。
C<$m> 変数の前に C<$> をつけるのを忘れるとこのエラーが出ることがあります。

=item %sseek() on unopened filehandle

=begin original

(W unopened) You tried to use the seek() or sysseek() function on a
filehandle that was either never opened or has since been closed.

=end original

(W unopened) オープンされていないファイルハンドルか、既にクローズされた
ファイルハンドルに対して、seek() 関数や sysseek() 関数を使おうとしました。

=item select not implemented

=begin original

(F) This machine doesn't implement the select() system call.

=end original

(F) このマシンでは、select() システムコールは実装されていません。

=item Semicolon seems to be missing

=begin original

(W semicolon) A nearby syntax error was probably caused by a missing
semicolon, or possibly some other missing operator, such as a comma.

=end original

(W semicolon) この付近の構文エラーは、おそらくセミコロンか、コンマなどの
演算子がなかったために起こったものと考えられます。

=item semi-panic: attempt to dup freed string

=begin original

(S internal) The internal newSVsv() routine was called to duplicate a
scalar that had previously been marked as free.

=end original

(S internal) 既に解放と印を付けたスカラを複製するために、内部の
newSVsv() ルーティンが呼ばれました。

=item sem%s not implemented

=begin original

(F) You don't have System V semaphore IPC on your system.

=end original

(F) このシステムでは、System V セマフォ IPC は使えません。

=item send() on closed socket %s

=begin original

(W closed) The socket you're sending to got itself closed sometime
before now.  Check your logic flow.

=end original

(W closed) 送信を行なおうとしたソケットは、既にクローズされています。
論理フローをチェックしてください。

=item Sequence (? incomplete before << HERE mark in regex m/%s/

=begin original

(F) A regular expression ended with an incomplete extension (?. The <<<HERE
shows in the regular expression about where the problem was discovered. See
L<perlre>.

=end original

(F) 正規表現が不完全な拡張 (? で終わっています。
<<<HERE で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Sequence (?{...}) not terminated or not {}-balanced in %s

=begin original

(F) If the contents of a (?{...}) clause contains braces, they must balance
for Perl to properly detect the end of the clause. See L<perlre>.

=end original

(F) (?{...}) 節の中に大括弧がある場合、対応していなければなりません。
Perl が正しく節の最後を検出するためです。
L<perlre> を参照してください。

=item Sequence (?%s...) not implemented before << HERE mark in %s

=begin original

(F) A proposed regular expression extension has the character reserved but
has not yet been written. The << HERE shows in the regular expression about
where the problem was discovered. See L<perlre>.

=end original

(F) 使おうとした正規表現の拡張は、予約された文字ですが、
まだ実装されていません。
<< HERE で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Sequence (?%s...) not recognized before << HERE mark in %s

=begin original

(F) You used a regular expression extension that doesn't make sense.
The << HERE shows in the regular expression about
where the problem was discovered. 
See L<perlre>.

=end original

(F) お使いになった正規表現の拡張は、意味をなしません。
<< HERE で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Sequence (?#... not terminated in regex m/%s/

=begin original

(F) A regular expression comment must be terminated by a closing
parenthesis.  Embedded parentheses aren't allowed.  See L<perlre>.

=end original

(F) 正規表現コメントは、閉じ括弧で終わらなければなりません。
括弧を含めることは許されません。
L<perlre> を参照してください。

=item 500 Server error

=begin original

See Server error.

=end original

"Server error" を参照してください。

=item Server error

=begin original

This is the error message generally seen in a browser window when trying
to run a CGI program (including SSI) over the web. The actual error text
varies widely from server to server. The most frequently-seen variants
are "500 Server error", "Method (something) not permitted", "Document
contains no data", "Premature end of script headers", and "Did not
produce a valid header".

=end original

これは、一般的には CGI (SSI を含みます)プログラムを WWW 越しに
実行しようとしたときにブラウザのウィンドウに表示されるメッセージです。
実際のエラーテキストはサーバーによって大きく異なります。
もっともよく見られるものとしては、"500 Server error",
"Method (something) not permitted", "Document contains no data",
"Premature end of script headers", "Did not produce a valid header" が
あります。

=begin original

B<This is a CGI error, not a Perl error>.

=end original

B<これは CGI のエラーであり、Perl のエラーではありません>.

=begin original

You need to make sure your script is executable, is accessible by the
user CGI is running the script under (which is probably not the user
account you tested it under), does not rely on any environment variables
(like PATH) from the user it isn't running under, and isn't in a
location where the CGI server can't find it, basically, more or less.
Please see the following for more information:

=end original

まずはあなたのスクリプトが実行可能か、CGI を実行するユーザー(これはおそらく
あなたがテストしたユーザーではありません)で読み込み可能か、実行しているのとは
異なるユーザーの環境変数(PATH など)に依存していないか、CGI サーバーが
見つけられない場所に置いていないか、といったことを確認する必要があるでしょう。
さらなる情報については以下を参照してください。

	http://www.perl.com/CPAN/doc/FAQs/cgi/idiots-guide.html
	http://www.perl.com/CPAN/doc/FAQs/cgi/perl-cgi-faq.html
	ftp://rtfm.mit.edu/pub/usenet/news.answers/www/cgi-faq
	http://hoohoo.ncsa.uiuc.edu/cgi/interface.html
	http://www-genome.wi.mit.edu/WWW/faqs/www-security-faq.html

=begin original

You should also look at L<perlfaq9>.

=end original

L<perlfaq9> も見るべきでしょう。

=item setegid() not implemented

=begin original

(F) You tried to assign to C<$)>, and your operating system doesn't
support the setegid() system call (or equivalent), or at least Configure
didn't think so.

=end original

(F) C<$)> へ代入を行なおうとしましたが、この OS では、setegid()
システムコール (または、同等のもの) がサポートされていません。
少なくとも Configure では、そう判断されました。

=item seteuid() not implemented

=begin original

(F) You tried to assign to C<< $> >>, and your operating system doesn't
support the seteuid() system call (or equivalent), or at least Configure
didn't think so.

=end original

(F) C<< $> >> へ代入を行なおうとしましたが、この OS では、seteuid()
システムコール (または、同等のもの) がサポートされていません。
少なくとも Configure では、そう判断されました。

=item setpgrp can't take arguments

=begin original

(F) Your system has the setpgrp() from BSD 4.2, which takes no
arguments, unlike POSIX setpgid(), which takes a process ID and process
group ID.

=end original

(F) このシステムの setpgrp() は BSD 4.2 由来のもので、引数がありません。
POSIX setpgid() はプロセス ID とプロセスグループ ID を引数にとります。

=item setrgid() not implemented

=begin original

(F) You tried to assign to C<$(>, and your operating system doesn't
support the setrgid() system call (or equivalent), or at least Configure
didn't think so.

=end original

(F) C<$(> へ代入を行なおうとしましたが、この OS では、setrgid()
システムコール (または、同等のもの) がサポートされていません。
少なくとも Configure では、そう判断されました。

=item setruid() not implemented

=begin original

(F) You tried to assign to C<$<>, and your operating system doesn't
support the setruid() system call (or equivalent), or at least Configure
didn't think so.

=end original

(F) C<$<> へ代入を行なおうとしましたが、この OS では、setruid()
システムコール (または、同等のもの) がサポートされていません。
少なくとも Configure では、そう判断されました。

=item setsockopt() on closed socket %s

=begin original

(W closed) You tried to set a socket option on a closed socket.  Did you
forget to check the return value of your socket() call?  See
L<perlfunc/setsockopt>.

=end original

(W closed) 閉じているソケットにソケットオプションを設定しようとしました。
socket() 呼び出しの返り値のチェックを忘れていませんか?
L<perlfunc/setsockopt> を参照してください。

=item Setuid/gid script is writable by world

=begin original

(F) The setuid emulator won't run a script that is writable by the
world, because the world might have written on it already.

=end original

(F) setuid エミュレータは、誰もが書き込みができるようになっている
スクリプトは実行しません。
誰かが既に書き換えたかも知れないからです。

=item shm%s not implemented

=begin original

(F) You don't have System V shared memory IPC on your system.

=end original

(F) このシステムでは、System V 共有メモリ IPC は使えません。

=item <> should be quotes

=begin original

(F) You wrote C<< require <file> >> when you should have written
C<require 'file'>.

=end original

(F) C<require 'file'> と書くべきところで C<< require <file> >> と
書いています。

=item /%s/ should probably be written as "%s"

=begin original

(W syntax) You have used a pattern where Perl expected to find a string,
as in the first argument to C<join>.  Perl will treat the true or false
result of matching the pattern against $_ as the string, which is
probably not what you had in mind.

=end original

(W syntax) C<join> の最初の引数として、Perl が文字列を想定しているところに
パターンを使いました。
Perl は $_ をパターンマッチングした結果の真か偽の値を文字列として
扱いますが、これはおそらく望んでいることではないでしょう。

=item shutdown() on closed socket %s

=begin original

(W closed) You tried to do a shutdown on a closed socket.  Seems a bit
superfluous.

=end original

(W closed) クローズされたソケットに shutdown を行なおうとしました。
多少、無駄のように思われます。

=item SIG%s handler "%s" not defined

=begin original

(W signal) The signal handler named in %SIG doesn't, in fact, exist.
Perhaps you put it into the wrong package?

=end original

(W signal) %SIG 内で指定したシグナルハンドラが、存在しません。
間違ったパッケージで、設定を行なっているのかもしれません。

=item sort is now a reserved word

=begin original

(F) An ancient error message that almost nobody ever runs into anymore.
But before sort was a keyword, people sometimes used it as a filehandle.

=end original

(F) もはや、誰もお目にかかることのない、旧世代のエラーメッセージです。
ただ、sort がキーワードとなる前には、これをファイルハンドルとして
使う方がいました。

=item Sort subroutine didn't return a numeric value

=begin original

(F) A sort comparison routine must return a number.  You probably blew
it by not using C<< <=> >> or C<cmp>, or by not using them correctly.
See L<perlfunc/sort>.

=end original

(F) sort の比較ルーティンは、必ず数値を返さなければなりません。
C<< <=> >> や C<cmp> を使わなかったか、正しく使わなかったものと思います。
L<perlfunc/sort> を参照してください。

=item Sort subroutine didn't return single value

=begin original

(F) A sort comparison subroutine may not return a list value with more
or less than one element.  See L<perlfunc/sort>.

=end original

(F) sort の比較サブルーティンは、要素が 1 個以外のリスト値を
返すことはできません。
L<perlfunc/sort>を参照してください。

=item Split loop

=begin original

(P) The split was looping infinitely.  (Obviously, a split shouldn't
iterate more times than there are characters of input, which is what
happened.) See L<perlfunc/split>.

=end original

(P) split が無限ループに陥りました。
(明らかに、split は、入力文字数以上にはできないはずですが、
そうなってしまいました。)　
L<perlfunc/split> を参照してください。

=item Statement unlikely to be reached

=begin original

(W exec) You did an exec() with some statement after it other than a
die().  This is almost always an error, because exec() never returns
unless there was a failure.  You probably wanted to use system()
instead, which does return.  To suppress this warning, put the exec() in
a block by itself.

=end original

(W exec) exec() の後に、die() 以外の実行文があります。
失敗したとき以外は、exec() から戻ってくることはありませんから、
ほとんどの場合には誤りでしょう。
戻ってくるsystem() に置き換える必要があるかもしれません。
この警告を止めるには、ブロック内に exec() だけを記述してください。

=item stat() on unopened filehandle %s

=begin original

(W unopened) You tried to use the stat() function on a filehandle that
was either never opened or has since been closed.

=end original

(W unopened) オープンされていないファイルハンドルか、既にクローズされた
ファイルハンドルに対して、stat() 関数を使おうとしました。

=item Stub found while resolving method `%s' overloading %s

=begin original

(P) Overloading resolution over @ISA tree may be broken by importation
stubs.  Stubs should never be implicitly created, but explicit calls to
C<can> may break this.

=end original

(P) @ISA ツリーでのオーバーロードの解決がインポートのスタブで壊されました。
スタブは暗黙に作られることはありませんが、明示的に C<can> を呼び出すと
これを破壊することがあります。

=item Subroutine %s redefined

=begin original

(W redefine) You redefined a subroutine.  To suppress this warning, say

=end original

(W redefine) サブルーティンを再定義しました。
この警告を止めるには、以下のようにしてください:

    {
	no warnings;
	eval "sub name { ... }";
    }

=item Substitution loop

=begin original

(P) The substitution was looping infinitely.  (Obviously, a substitution
shouldn't iterate more times than there are characters of input, which
is what happened.)  See the discussion of substitution in
L<perlop/"Quote and Quote-like Operators">.

=end original

(P) 置換が無限ループに陥りました。
(明らかに、置換は入力文字数以上には起こらないはずですが、
それが起こってしまいました。)
L<perlop/"Quote and Quote-like Operators"> を参照してください。

=item Substitution pattern not terminated

=begin original

(F) The lexer couldn't find the interior delimiter of a s/// or s{}{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading C<$> from variable C<$s> may cause this error.

=end original

(F) s/// もしくは s{}{} 構文の真ん中の区切り文字が見つかりませんでした。
括弧類の区切り文字では、ネストを数えることを忘れないでください。
C<$s> 変数の前に C<$> をつけるのを忘れるとこのエラーが出ることがあります。

=item Substitution replacement not terminated

=begin original

(F) The lexer couldn't find the final delimiter of a s/// or s{}{}
construct.  Remember that bracketing delimiters count nesting level.
Missing the leading C<$> from variable C<$s> may cause this error.

=end original

(F) s/// もしくは s{}{} 構文の最後の区切り文字が見つかりませんでした。
括弧類の区切り文字では、ネストを数えることを忘れないでください。
C<$s> 変数の前に C<$> をつけるのを忘れるとこのエラーが出ることがあります。

=item substr outside of string

=begin original

(W substr),(F) You tried to reference a substr() that pointed outside of
a string.  That is, the absolute value of the offset was larger than the
length of the string.  See L<perlfunc/substr>.  This warning is fatal if
substr is used in an lvalue context (as the left hand side of an
assignment or as a subroutine argument for example).

=end original

(W substr),(F) 文字列の外を指す substr() を参照しようとしました。
つまり、オフセットの絶対値が、文字列の長さより大きくなっています。
L<perlfunc/substr> を参照してください。
この警告は、substr が(代入の左側やサブルーチンの引数といった)
左辺値として使われた場合は致命的となります。

=item suidperl is no longer needed since %s

=begin original

(F) Your Perl was compiled with B<-D>SETUID_SCRIPTS_ARE_SECURE_NOW, but
a version of the setuid emulator somehow got run anyway.

=end original

(F) お使いの Perl は、-DSETUID_SCRIPTS_ARE_SECURE_NOW を
指定してコンパイルされていますが、setuid エミュレータが、
実行されてしまいました。

=item Switch (?(condition)... contains too many branches before << HE%s

=begin original

(F) A (?(condition)if-clause|else-clause) construct can have at most two
branches (the if-clause and the else-clause). If you want one or both to
contain alternation, such as using C<this|that|other>, enclose it in
clustering parentheses:

=end original

(F) (?(condition)if-clause|else-clause) 構造は最大で 2 つの分岐
(if-clause と else-clause) を持つことができます。
片方、または両方に選択肢を含めたいときは、それをかっこで囲んでください:

    (?(condition)(?:this|that|other)|else-clause)

=begin original

The << HERE shows in the regular expression about where the problem was
discovered. See L<perlre>.

=end original

<< HERE で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Switch condition not recognized before << HERE in regex m/%s/

=begin original

(F) If the argument to the (?(...)if-clause|else-clause) construct is a
number, it can be only a number. The << HERE shows in the regular expression
about where the problem was discovered. See L<perlre>.

=end original

(?(...)if-clause|else-clause) 構造の引数が数値なら、数値だけが可能です。
<< HERE で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item switching effective %s is not implemented

=begin original

(F) While under the C<use filetest> pragma, we cannot switch the real
and effective uids or gids.

=end original

(F) C<use filetest> プラグマを使っている間に、
実と実効の UID や GID の切り替えに失敗しました。

=item syntax error

=begin original

(F) Probably means you had a syntax error.  Common reasons include:

=end original

(F) おそらく、構文エラーが起こっています。
よくある原因としては以下のことが考えられます:

=begin original

    A keyword is misspelled.
    A semicolon is missing.
    A comma is missing.
    An opening or closing parenthesis is missing.
    An opening or closing brace is missing.
    A closing quote is missing.

=end original

    キーワードのスペルミス。
    セミコロンを忘れた。
    コンマを忘れた。
    開き括弧、閉じ括弧を忘れた。
    開き中括弧、閉じ中括弧を忘れた。
    クォートの閉じ忘れ。

=begin original

Often there will be another error message associated with the syntax
error giving more information.  (Sometimes it helps to turn on B<-w>.)
The error message itself often tells you where it was in the line when
it decided to give up.  Sometimes the actual error is several tokens
before this, because Perl is good at understanding random input.
Occasionally the line number may be misleading, and once in a blue moon
the only way to figure out what's triggering the error is to call
C<perl -c> repeatedly, chopping away half the program each time to see
if the error went away.  Sort of the cybernetic version of S<20
questions>.

=end original

多くの場合、構文エラーと一緒に、別のエラーメッセージが出て、
情報を与えてくれます。(-w を付けることが、助けになることもあります。)
エラーメッセージ自身には、何行目まで行って、諦めたのかということも
含まれています。
Perl はでたらめな入力を理解するのが得意なので、実際のエラーはもう少し前に
在ることもあります。
ときには、行番号が全く役に立たないこともあり、はまってしまったなら、
エラーのきっかけが何かを見つける唯一の手段は、プログラムを寸断して、
エラーがなくなるまで、perl -c を繰り返すしかありません。
S<頭の体操 20 問>だと思ってください。

=item syntax error at line %d: `%s' unexpected

=begin original

(A) You've accidentally run your script through the Bourne shell instead
of Perl.  Check the #! line, or manually feed your script into Perl
yourself.

=end original

(A) スクリプトを perl ではなく Bourne shell で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item %s syntax OK

=begin original

(F) The final summary message when a C<perl -c> succeeds.

=end original

(F) C<perl -c> が成功したときの最終まとめメッセージです。

=item System V %s is not implemented on this machine

=begin original

(F) You tried to do something with a function beginning with "sem",
"shm", or "msg" but that System V IPC is not implemented in your
machine.  In some machines the functionality can exist but be
unconfigured.  Consult your system support.

=end original

(F) 何か、名前が "sem"、"shm"、"msg" で始まる関数を実行しようとしましたが、
あなたのマシンには System V IPC が実装されていません。
機能はあっても設定されていない場合もあります。
システムサポートに相談してください。

=item syswrite() on closed filehandle %s

=begin original

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your logic flow.

=end original

(W closed) 書き込みを行なおうとしたファイルハンドルは、
既にクローズされています。
論理フローをチェックしてください。

=item Target of goto is too deeply nested

=begin original

(F) You tried to use C<goto> to reach a label that was too deeply nested
for Perl to reach.  Perl is doing you a favor by refusing.

=end original

(F) C<goto> で、Perl が届かないほど深くネストしたラベルに移動しようとしました。
Perl は親切にもこれを拒否します。

=item tell() on unopened filehandle

=begin original

(W unopened) You tried to use the tell() function on a filehandle that
was either never opened or has since been closed.

=end original

(W unopened) オープンされていないファイルハンドルか、既にクローズされた
ファイルハンドルに対して、tell() 関数を使おうとしました。

=item That use of $[ is unsupported

=begin original

(F) Assignment to C<$[> is now strictly circumscribed, and interpreted
as a compiler directive.  You may say only one of

=end original

(F) 現在、C<$[> への代入は、厳しく制限され、コンパイラ指示子と解釈されます。
使えるのは以下の形だけです:

    $[ = 0;
    $[ = 1;
    ...
    local $[ = 0;
    local $[ = 1;
    ...

=begin original

This is to prevent the problem of one module changing the array base out
from under another module inadvertently.  See L<perlvar/$[>.

=end original

これは、一つのモジュールで、他のモジュールが意図しないような、
配列のベースを変更する問題を回避するためのものです。
L<perlvar/$[> を参照してください。

=item The crypt() function is unimplemented due to excessive paranoia

=begin original

(F) Configure couldn't find the crypt() function on your machine,
probably because your vendor didn't supply it, probably because they
think the U.S. Government thinks it's a secret, or at least that they
will continue to pretend that it is.  And if you quote me on that, I
will deny it.

=end original

(F) Configure は、マシン上で crypt() 関数を見つけられませんでした。
おそらく、ベンダからの供給がなかったからで、おそらく、ベンダは
アメリカ政府がそれを秘密だとしていると思っているか、
少なくとも思っているというふりをしているのでしょう。
私を引き合いに出したところで、それは否定されることでしょう。

=item The %s function is unimplemented

=begin original

The function indicated isn't implemented on this architecture, according
to the probings of Configure.

=end original

(F) この関数は、Configure の調査によると、このアーキテクチャでは、
実装されていないようです。

=item The stat preceding C<-l _> wasn't an lstat

=begin original

(F) It makes no sense to test the current stat buffer for symbolic
linkhood if the last stat that wrote to the stat buffer already went
past the symlink to get to the real file.  Use an actual filename
instead.

=end original

(F) 過去の stat がシンボリックリンクを通り過ぎた、実際のファイルの
情報を取って、stat バッファに入れているときに、シンボリックタイプの
stat をカレント stat バッファに対して行なっても意味がありません。
実際のファイル名を使ってください。

=item This Perl can't reset CRTL environ elements (%s)

=item This Perl can't set CRTL environ elements (%s=%s)

=begin original

(W internal) Warnings peculiar to VMS.  You tried to change or delete an
element of the CRTL's internal environ array, but your copy of Perl
wasn't built with a CRTL that contained the setenv() function.  You'll
need to rebuild Perl with a CRTL that does, or redefine
F<PERL_ENV_TABLES> (see L<perlvms>) so that the environ array isn't the
target of the change to
%ENV which produced the warning.

=end original

(W internal) VMS 固有の警告です。
CRTL の内部環境配列を変更または削除しようとしましたが、この Perl は
setenv() 関数を含んだ CRTL でビルドされていません。
これを含む CRTL を使って Perl を再ビルドするか、環境配列がこの警告を
出力している %ENV を変更するターゲットとならないように 
F<PERL_ENV_TABLES> (L<perlvms> を参照してください) を再定義してください。

=item times not implemented

=begin original

(F) Your version of the C library apparently doesn't do times().  I
suspect you're not running on Unix.

=end original

(F) お使いの C ライブラリでは、times() を行わないようです。
UNIX ではない環境でしょうか。

=item Too few args to syscall

=begin original

(F) There has to be at least one argument to syscall() to specify the
system call to call, silly dilly.

=end original

(F) syscall() には、最低限でも呼び出すシステムコールを示す、
引数が一つ必要です。

=item Too late for "B<-T>" option

=begin original

(X) The #! line (or local equivalent) in a Perl script contains the
B<-T> option, but Perl was not invoked with B<-T> in its command line.
This is an error because, by the time Perl discovers a B<-T> in a
script, it's too late to properly taint everything from the environment.
So Perl gives up.

=end original

(X) Perl スクリプトの #! 行(あるいはローカルで等価なもの)に B<-T>
オプションが含まれていますが、Perl はコマンドラインで B<-T> 付きで
起動されていません。
Perl がスクリプトの中で B<-T> を発見した時点では、環境からの全てを
汚染チェックするには遅すぎるので、これはエラーになります。
それで Perl は諦めます。

=begin original

If the Perl script is being executed as a command using the #!
mechanism (or its local equivalent), this error can usually be fixed by
editing the #! line so that the B<-T> option is a part of Perl's first
argument: e.g. change C<perl -n -T> to C<perl -T -n>.

=end original

perl スクリプトが #! 機構(またはローカルな等価な機構)を使ってコマンドとして
実行される場合、このエラーは普通 B<-T> オプションを Perl の最初の引数に
変更する(C<perl -n -T> を C<perl -T -n> に変更する)ことで修正されます。

=begin original

If the Perl script is being executed as C<perl scriptname>, then the
B<-T> option must appear on the command line: C<perl -T scriptname>.

=end original

Perl スクリプトが C<perl scriptname> として起動される場合、B<-T> オプションは
コマンドラインに書かなければなりません: C<perl -T scriptname>

=item Too late for "-%s" option

=begin original

(X) The #! line (or local equivalent) in a Perl script contains the
B<-M> or B<-m> option.  This is an error because B<-M> and B<-m> options
are not intended for use inside scripts.  Use the C<use> pragma instead.

=end original

(X) Perl スクリプトの #! 行(またはローカルな等価な機構)に B<-M> や 
B<-m> オプションが含まれています。
B<-M> と B<-m> のオプションは、スクリプト内部で使うためのものではないので、
これはエラーになります。
代わりに C<use> プラグマを使ってください。

=item Too late to run %s block

=begin original

(W void) A CHECK or INIT block is being defined during run time proper,
when the opportunity to run them has already passed.  Perhaps you are
loading a file with C<require> or C<do> when you should be using C<use>
instead.  Or perhaps you should put the C<require> or C<do> inside a
BEGIN block.

=end original

(W void) CHECK か INIT のブロックが、それが実行される機会が過ぎてから
実行時に定義されました。
おそらく C<use> を使うべきときに C<require> か C<do> を使ってファイルを
読み込んでいます。
あるいはおそらく BEGIN ブロックの中に C<require> か C<do> を
書いたのでしょう。

=item Too many args to syscall

=begin original

(F) Perl supports a maximum of only 14 args to syscall().

=end original

(F) Perl では、syscall() に最大 14 までしか、引数を渡すことができません。

=item Too many arguments for %s

=begin original

(F) The function requires fewer arguments than you specified.

=end original

(F) 関数が要求する以上の引数を指定しました。

=item Too many )'s

=begin original

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item Too many ('s

=item trailing \ in regexp

=begin original

(F) The regular expression ends with an unbackslashed backslash.
Backslash it.   See L<perlre>.

=end original

(F) 正規表現が、バックスラッシュを付けていないバックスラッシュで
終了しました。バックスラッシュを付けてください。
L<perlre> を参照してください。

=item Transliteration pattern not terminated

=begin original

(F) The lexer couldn't find the interior delimiter of a tr/// or tr[][]
or y/// or y[][] construct.  Missing the leading C<$> from variables
C<$tr> or C<$y> may cause this error.

=end original

(F) tr///, tr[][], y///, y[][]  構文の真ん中の区切り文字が
見つかりませんでした。
C<$tr> 変数 や C<$y> 変数の前に C<$> をつけるのを忘れると
このエラーが出ることがあります。


=item Transliteration replacement not terminated

=begin original

(F) The lexer couldn't find the final delimiter of a tr/// or tr[][]
construct.

=end original

(F) tr/// もしくは tr[][] 構文の最後の区切り文字が見つかりませんでした。

=item truncate not implemented

=begin original

(F) Your machine doesn't implement a file truncation mechanism that
Configure knows about.

=end original

(F) このマシンでは、Configure が知りうる、ファイルの切り詰めの機能が
実装されていません。

=item Type of arg %d to %s must be %s (not %s)

=begin original

(F) This function requires the argument in that position to be of a
certain type.  Arrays must be @NAME or C<@{EXPR}>.  Hashes must be
%NAME or C<%{EXPR}>.  No implicit dereferencing is allowed--use the
{EXPR} forms as an explicit dereference.  See L<perlref>.

=end original

(F) この関数は、その位置に決まった型の引数を必要とします。
配列は、@NAME もしくは C<@{EXPR}> でなくてはならず、ハッシュは、
%NAME もしくは C<%{EXPR}> でなければなりません。
暗黙の被参照は許されませんので、明示的な被参照として、
{EXPR} 形式を使ってください。
L<perlref> を参照してください。

=item umask: argument is missing initial 0

=begin original

(W umask) A umask of 222 is incorrect.  It should be 0222, because octal
literals always start with 0 in Perl, as in C.

=end original

(W umask) umask 222 は正しくありません。
Perl の 8 進数リテラルは、C と同じように 0 で始まりますから、
0222 とすべきです。

=item umask not implemented

=begin original

(F) Your machine doesn't implement the umask function and you tried to
use it to restrict permissions for yourself (EXPR & 0700).

=end original

(F) umask 関数が実装されていないマシンで、自分自身の権限を制限する
(EXPR & 0700) ためにこれを使おうとしました。

=item Unable to create sub named "%s"

=begin original

(F) You attempted to create or access a subroutine with an illegal name.

=end original

(F) 不正な名前のサブルーチンを作成または呼び出ししようとしました。

=item Unbalanced context: %d more PUSHes than POPs

=begin original

(W internal) The exit code detected an internal inconsistency in how
many execution contexts were entered and left.

=end original

(W internal) いくつの実行コンテキストに入って、出たかということの
内部矛盾が exit コードで発見されました。

=item Unbalanced saves: %d more saves than restores

=begin original

(W internal) The exit code detected an internal inconsistency in how
many values were temporarily localized.

=end original

(W internal) いくつの値が、一時的にローカル化されたかということの
内部矛盾が exit コードで発見されました。

=item Unbalanced scopes: %d more ENTERs than LEAVEs

=begin original

(W internal) The exit code detected an internal inconsistency in how
many blocks were entered and left.

=end original

(W internal) いくつのブロックに入って、出たかということの
内部矛盾が exit コードで発見されました。

=item Unbalanced tmps: %d more allocs than frees

=begin original

(W internal) The exit code detected an internal inconsistency in how
many mortal scalars were allocated and freed.

=end original

(W internal) いくつの揮発性スカラの割り当てを行ない、解放したかと
いうことの内部矛盾が exit コードで発見されました。

=item Undefined format "%s" called

=begin original

(F) The format indicated doesn't seem to exist.  Perhaps it's really in
another package?  See L<perlform>.

=end original

(F) このフォーマットは存在しないように見えます。
おそらく、別のパッケージに存在するのではないでしょうか。
L<perlform> を参照してください。

=item Undefined sort subroutine "%s" called

=begin original

(F) The sort comparison routine specified doesn't seem to exist.
Perhaps it's in a different package?  See L<perlfunc/sort>.

=end original

(F) 指定された sort の比較ルーティンは存在していないように思われます。
おそらく、別のパッケージに存在するのではないでしょうか。
L<perlfunc/sort>を参照してください。

=item Undefined subroutine &%s called

=begin original

(F) The subroutine indicated hasn't been defined, or if it was, it has
since been undefined.

=end original

(F) 指定されたサブルーティンが定義されていません。
定義されていたとしても、既に未定義になっています。

=item Undefined subroutine called

=begin original

(F) The anonymous subroutine you're trying to call hasn't been defined,
or if it was, it has since been undefined.

=end original

(F) 呼びだそうとしている無名のサブルーティンは、定義されていません。
定義されていたとしても、既に未定義になっています。

=item Undefined subroutine in sort

=begin original

(F) The sort comparison routine specified is declared but doesn't seem
to have been defined yet.  See L<perlfunc/sort>.

=end original

(F) 指定された sort の比較ルーティンは宣言されましたが、
定義されていないようです。
L<perlfunc/sort> を参照してください。

=item Undefined top format "%s" called

=begin original

(F) The format indicated doesn't seem to exist.  Perhaps it's really in
another package?  See L<perlform>.

=end original

(F) 示されたフォーマットが存在しないようです。
おそらく本当は他のパッケージにあるのでは?
L<perlform> を参照してください。

=item Undefined value assigned to typeglob

=begin original

(W misc) An undefined value was assigned to a typeglob, a la
C<*foo = undef>.  This does nothing.  It's possible that you really mean
C<undef *foo>.

=end original

(W misc) C<*foo = undef> のように、未定義値を型グロブに代入しました。
これは何もしません。
本当は C<undef *foo> としたかったのかもしれません。

=item %s: Undefined variable

=begin original

(A) You've accidentally run your script through B<csh> instead of Perl.
Check the #! line, or manually feed your script into Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item unexec of %s into %s failed!

=begin original

(F) The unexec() routine failed for some reason.  See your local FSF
representative, who probably put it there in the first place.

=end original

(F) unexec() ルーティンが何らかの理由によって失敗しました。
最初にインストールしたであろう、サイトの FSF 代表者にたずねてみてください。

=item Unknown BYTEORDER

=begin original

(F) There are no byte-swapping functions for a machine with this byte
order.

=end original

(F) このバイト順序を入れ替える関数がありません。

=item Unknown switch condition (?(%.2s before << HERE in regex m/%s/

=begin original

(F) The condition of a (?(condition)if-clause|else-clause) construct is not
known. The condition may be lookaround (the condition is true if the
lookaround is true), a (?{...}) construct (the condition is true if the
code evaluates to a true value), or a number (the condition is true if the
set of capturing parentheses named by the number is defined).

=end original

(F) (?(condition)if-clause|else-clause) 構文の条件が不明です。
条件は参照 (参照が真なら条件は真)、
(?{...}) 構文 (コードが真の値に評価されれば真)、
数値 (番号付けされた、捕捉されたかっこの集合が定義されていれば真) の
いずれかです。

=begin original

The << HERE shows in the regular expression about where the problem was
discovered.  See L<perlre>.

=end original

<< HERE で正規表現のどこに問題が発見されたかを示しています。
L<perlre> を参照してください。

=item Unknown open() mode '%s'

=begin original

(F) The second argument of 3-argument open() is not among the list
of valid modes: C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->.

=end original

(F) 3 引数 open() の 第 2 引数が以下の有効なモードの
どれでもありませんでした:
C<< < >>, C<< > >>, C<<< >> >>>, C<< +< >>,
C<< +> >>, C<<< +>> >>>, C<-|>, C<|->.

=item Unknown process %x sent message to prime_env_iter: %s

=begin original

(P) An error peculiar to VMS.  Perl was reading values for %ENV before
iterating over it, and someone else stuck a message in the stream of
data Perl expected.  Someone's very confused, or perhaps trying to
subvert Perl's population of %ENV for nefarious purposes.

=end original

(P) VMS 固有のエラーです。
Perl は %ENV を反復する前に %ENV から値を読み込み、Perl が想定している
データストリームの中に誰かがメッセージを差し込みました。
誰かはとても混乱しているか、邪悪な目的のために %ENV の Perl の集団を
滅亡させようとしています。

=item unmatched [ before << HERE mark in regex m/%s/

=begin original

(F) The brackets around a character class must match. If you wish to
include a closing bracket in a character class, backslash it or put it
first. See L<perlre>. The << HERE shows in the regular expression about
where the escape was discovered.

=end original

(F) 文字クラスの周りの大かっこが一致していません。
文字クラスに閉じ大かっこを含めたい場合は、バックスラッシュをつけるか
先頭に置いてください。
L<perlre> を参照してください。
<< HERE で正規表現のどこに問題が発見されたかを示しています。

=item unmatched ( in regexp before << HERE mark in regex m/%s/

=begin original

(F) Unbackslashed parentheses must always be balanced in regular
expressions.  If you're a vi user, the % key is valuable for finding the
matching parenthesis.  See L<perlre>.

=end original

(F) 正規表現の中ではバックスラッシュのついていないかっこは常に
対応していなければなりません。
vi ユーザーであれば、% キーが対応するかっこの発見に有用です。
L<perlre> を参照してください。

=item Unmatched right %s bracket

=begin original

(F) The lexer counted more closing curly or square brackets than opening
ones, so you're probably missing a matching opening bracket.  As a
general rule, you'll find the missing one (so to speak) near the place
you were last editing.

=end original

(F) 字句解析部が開き中括弧よりも多くの閉じ中括弧または大括弧を
見つけました。
開き中括弧または大括弧のもれと思われます。
一般的な規則として、最後に修正した場所の付近に、忘れた中括弧
または大括弧 (であるはずのもの) があることでしょう。

=item Unquoted string "%s" may clash with future reserved word

=begin original

(W reserved) You used a bareword that might someday be claimed as a
reserved word.  It's best to put such a word in quotes, or capitalize it
somehow, or insert an underbar into it.  You might also declare it as a
subroutine.

=end original

(W) いつの日にか、予約語とかち合うかもしれない、裸の単語を使用しています。
そのような単語は、クォートするか、大文字を入れるか、アンダーバー (_) を
いれるかしてください。
その裸の単語は、サブルーティンとして宣言することも可能です。

=item Unrecognized character %s

=begin original

(F) The Perl parser has no idea what to do with the specified character
in your Perl script (or eval).  Perhaps you tried to run a compressed
script, a binary program, or a directory as a Perl program.

=end original

(F) Perl パーサーは、Perl スクリプト(または eval) で出てきた文字に対して
どうすればよいか分かりませんでした。
おそらく圧縮したスクリプト、バイナリプログラム、ディレクトリといったものを
Perl プログラムとして実行しようとしたのでしょう。

=item /%s/: Unrecognized escape \\%c in character class passed through

=begin original

(W regexp) You used a backslash-character combination which is not
recognized by Perl inside character classes.  The character was
understood literally.

=end original

(W regexp) Perl 内部文字クラスで認識できない、バックスラッシュ-文字の
組み合わせを使いました。
文字はリテラルに理解されます。

=item Unrecognized escape \\%c passed through before << HERE in m/%s/

=begin original

(W regexp) You used a backslash-character combination which is not
recognized by Perl. This combination appears in an interpolated variable or
a C<'>-delimited regular expression. The character was understood
literally. The << HERE shows in the regular expression about where the escape
was discovered.

=end original

(W regexp) Perl が認識できない、バックスラッシュ-文字の組み合わせが
使われています。
この組み合わせは展開された変数の中か、C<'>-デリミタの正規表現で
出現します。
この文字はリテラルに処理されます。
<< HERE で正規表現のどこに問題が発見されたかを示しています。

=item Unrecognized escape \\%c passed through

=begin original

(W misc) You used a backslash-character combination which is not
recognized by Perl.

=end original

(W misc) Perl が理解できないバックスラッシュ-文字の組み合わせが
使われています。

=item Unrecognized signal name "%s"

=begin original

(F) You specified a signal name to the kill() function that was not
recognized.  Say C<kill -l> in your shell to see the valid signal names
on your system.

=end original

(F) kill() 関数に、認識できないシグナル名を指定しました。
お使いのシステムで使用可能なシグナル名を調べるには、
シェル上で C<kill -l> などとしてください。

=item Unrecognized switch: -%s  (-h will show valid options)

=begin original

(F) You specified an illegal option to Perl.  Don't do that.  (If you
think you didn't do that, check the #! line to see if it's supplying the
bad switch on your behalf.)

=end original

(F) Perl に間違ったオプションを指定しました。
これを行なってはいけません。
(指定したつもりがないのであれば、#! 行に間違ったオプションが
スイッチが指定されていないかをチェックしてください。)

=item Unsuccessful %s on filename containing newline

=begin original

(W newline) A file operation was attempted on a filename, and that
operation failed, PROBABLY because the filename contained a newline,
PROBABLY because you forgot to chomp() it off.  See L<perlfunc/chomp>.

=end original

(W newline) あるファイル名に対して、ファイル操作を行ないましたが、
失敗しました。
「おそらく」ファイル名に改行文字がついていたからで、
「おそらく」 chomp() するのを忘れたのでしょう。　
L<perlfunc/chomp> を参照してください。

=item Unsupported directory function "%s" called

=begin original

(F) Your machine doesn't support opendir() and readdir().

=end original

(F) このマシンでは、opendir() や readdir() がサポートされていません。

=item Unsupported function %s

=begin original

(F) This machine doesn't implement the indicated function, apparently.
At least, Configure doesn't think so.

=end original

(F) このマシンでは、表示した関数は実装されていません。
少なくとも、Configure はそう判断しました。

=item Unsupported function fork

=begin original

(F) Your version of executable does not support forking.

=end original

(F) この実行ファイルは fork に対応していません。

=begin original

Note that under some systems, like OS/2, there may be different flavors
of Perl executables, some of which may support fork, some not. Try
changing the name you call Perl by to C<perl_>, C<perl__>, and so on.

=end original

OS/2 のようなシステムには、Perl 実行ファイルにいくつかの種類があり、
fork に対応しているものとしていないものがあります。
Perl を呼び出す時の名前を C<perl_>, C<perl__> のように
変えてみてください。

=item Unsupported script encoding

=begin original

(F) Your program file begins with a Unicode Byte Order Mark (BOM) which
declares it to be in a Unicode encoding that Perl cannot yet read.

=end original

(F) プログラムファイルが、Perl が読み込めない Unicode エンコーディングを
宣言する Unicode Byte Order Mark (BOM) で始まっています。

=item Unsupported socket function "%s" called

=begin original

(F) Your machine doesn't support the Berkeley socket mechanism, or at
least that's what Configure thought.

=end original

(F) このマシンでは、Berkeley ソケット機構がサポートされていないか、
少なくとも Configure がそう判断しました。

=item Unterminated attribute list

=begin original

(F) The lexer found something other than a simple identifier at the
start of an attribute, and it wasn't a semicolon or the start of a
block.  Perhaps you terminated the parameter list of the previous
attribute too soon.  See L<attributes>.

=end original

(F) 字句解析器が、属性の先頭として単純な識別子やセミコロンやブロックの
開始でないものを発見しました。
おそらく以前の属性のパラメータリストを早く終端しすぎたのでしょう。
L<attributes> を参照してください。

=item Unterminated attribute parameter in attribute list

=begin original

(F) The lexer saw an opening (left) parenthesis character while parsing
an attribute list, but the matching closing (right) parenthesis
character was not found.  You may need to add (or remove) a backslash
character to get your parentheses to balance.  See L<attributes>.

=end original

(F) 字句解析器が、属性リストをパースしているときに開き(左)かっこを
発見しましたが、対応する閉じ(右)かっこが見つかりませんでした。
かっこのバランスを取るために、バックスラッシュを追加(または削除)する
必要があるでしょう。
L<attributes> を参照してください。

=item Unterminated compressed integer

=begin original

(F) An argument to unpack("w",...) was incompatible with the BER
compressed integer format and could not be converted to an integer.
See L<perlfunc/pack>.

=end original

(F) unpack("w",...) の引数が BER 圧縮整数フォーマットと互換性がなく、
整数に変換できませんでした。
L<perlfunc/pack> を参照してください。

=item Unterminated <> operator

=begin original

(F) The lexer saw a left angle bracket in a place where it was expecting
a term, so it's looking for the corresponding right angle bracket, and
not finding it.  Chances are you left some needed parentheses out
earlier in the line, and you really meant a "less than".

=end original

(F) 項が必要とされるところで、開き山括弧が見つけたため、
対応する閉じ山括弧を探しましたが、見つかりませんでした。
可能性としては、必要な括弧を省いてしまい、本当は、「小なり記号」を
表したかった場合が考えられます。

=item untie attempted while %d inner references still exist

=begin original

(W untie) A copy of the object returned from C<tie> (or C<tied>) was
still valid when C<untie> was called.

=end original

(W untie) C<tie> (または C<tied>) から返されたオブジェクトが、
C<untie> が呼び出されたときにまだ有効でした。

=item Useless use of %s in void context

=begin original

(W void) You did something without a side effect in a context that does
nothing with the return value, such as a statement that doesn't return a
value from a block, or the left side of a scalar comma operator.  Very
often this points not to stupidity on your part, but a failure of Perl
to parse your program the way you thought it would.  For example, you'd
get this if you mixed up your C precedence with Python precedence and
said

=end original

(W void) ブロックの値を返さない文や、スカラのコンマ演算子の左側のように
返却値の無い文脈で、副作用のないことを行ないました。
多くは、みなさんの間違いを指摘するものではなく、Perl がみなさんの
意向を汲み取った解釈ができないことで起こります。
たとえば、みなさんが C の優先順位を Python の優先順位と混同して
以下のようにした場合です:

    $one, $two = 1, 2;

=begin original

when you meant to say

=end original

以下のようにするべきです。

    ($one, $two) = (1, 2);

=begin original

Another common error is to use ordinary parentheses to construct a list
reference when you should be using square or curly brackets, for
example, if you say

=end original

その他の良くあるエラーとしては、リストを作るのに中括弧や
大括弧を使うべきところで普通の括弧を使うことです。
例えば、以下のように書いた場合です:

    $array = (1,2);

=begin original

when you should have said

=end original

以下のように書くべきです:

    $array = [1,2];

=begin original

The square brackets explicitly turn a list value into a scalar value,
while parentheses do not.  So when a parenthesized list is evaluated in
a scalar context, the comma is treated like C's comma operator, which
throws away the left argument, which is not what you want.  See
L<perlref> for more on this.

=end original

角かっこはリスト値を明示的にスカラ値に変換しますが、かっこは変換しません。
そのため、かっこで括られたリストをスカラコンテキストで評価すると、
カンマは C のカンマ演算子のように扱われ、左側の引数は捨てられます;
これは望んでいることではないでしょう。
これに関するさらなる情報については L<perlref> を参照してください。

=item Useless use of "re" pragma

=begin original

(W) You did C<use re;> without any arguments.   That isn't very useful.

=end original

(W) C<use re;> プラグマを引数なしで指定しました。これは無意味です。

=item "use" not allowed in expression

=begin original

(F) The "use" keyword is recognized and executed at compile time, and
returns no useful value.  See L<perlmod>.

=end original

(F) "use" キーワードは、コンパイル時に認識され、実行されるもので、
意味のある値を返しません。
L<perlmod> を参照してください。

=item Use of bare << to mean <<"" is deprecated

=begin original

(D deprecated) You are now encouraged to use the explicitly quoted form
if you wish to use an empty line as the terminator of the here-document.

=end original

(D deprecated) ヒアドキュメントの終端子として空行を使いたいときには、
明示的にクォートされた形を使うことを推奨しています。

=item Use of implicit split to @_ is deprecated

=begin original

(D deprecated) It makes a lot of work for the compiler when you clobber
a subroutine's argument list, so it's better if you assign the results
of a split() explicitly to an array (or list).

=end original

(D deprecated) サブルーティンの引数を壊すとコンパイラに多大な労力を
かけることになるので、split() の結果は明示的に配列 (やリスト) に
代入を行なうようにしてください。

=item Use of inherited AUTOLOAD for non-method %s() is deprecated

=begin original

(D deprecated) As an (ahem) accidental feature, C<AUTOLOAD> subroutines
are looked up as methods (using the C<@ISA> hierarchy) even when the
subroutines to be autoloaded were called as plain functions (e.g.
C<Foo::bar()>), not as methods (e.g. C<< Foo->bar() >> or C<<
$obj->bar() >>).

=end original

(D deprecated) (エヘン)偶発的な仕様によって、C<AUTOLOAD> サブルーチンは、
autoload されるサブルーチンがメソッド (C<< Foo->bar() >> や
C<< $obj->bar() >>) ではなく、普通の関数 (C<Foo::bar()>) として
呼び出された場合にも、(C<@ISA> 階層を使って) メソッドとして検索します。

=begin original

This bug will be rectified in future by using method lookup only for
methods' C<AUTOLOAD>s.  However, there is a significant base of existing
code that may be using the old behavior.  So, as an interim step, Perl
currently issues an optional warning when non-methods use inherited
C<AUTOLOAD>s.

=end original

このバグは、メソッドの検索をメソッドの C<AUTOLOAD> のみで使うことによって
将来修正される予定です。
しかし、現在のコードの大部分は古い振る舞いを使っています。
それで、暫定的なステップとして、Perl は現在のところは、
メソッド以外が継承されたC<AUTOLOAD> を使うときにオプションの警告を
発生させます。

=begin original

The simple rule is:  Inheritance will not work when autoloading
non-methods.  The simple fix for old code is:  In any module that used
to depend on inheriting C<AUTOLOAD> for non-methods from a base class
named C<BaseClass>, execute C<*AUTOLOAD = \&BaseClass::AUTOLOAD> during
startup.

=end original

単純な規則は: 継承は autoload された非メソッドには動作しません。
古いコードを修正する簡単な方法は: C<BaseClass> という名前のベースクラスから
非メソッドのための継承した C<AUTOLOAD> に依存しているモジュールに対して、
開始時に C<*AUTOLOAD = \&BaseClass::AUTOLOAD> を実行してください。

=begin original

In code that currently says C<use AutoLoader; @ISA = qw(AutoLoader);>
you should remove AutoLoader from @ISA and change C<use AutoLoader;> to
C<use AutoLoader 'AUTOLOAD';>.

=end original

C<use AutoLoader; @ISA = qw(AutoLoader);> としているコードでは、
@ISA から AutoLoader を取り除いて、C<use AutoLoader;> を
C<use AutoLoader 'AUTOLOAD';> に変更するべきです。

=item Use of %s in printf format not supported

=begin original

(F) You attempted to use a feature of printf that is accessible from
only C.  This usually means there's a better way to do it in Perl.

=end original

(F) C でのみアクセス可能な printf の機能を使おうとしました。
これは普通 Perl で行うより良い方法があります。

=item Use of $* is deprecated

=begin original

(D deprecated) This variable magically turned on multi-line pattern
matching, both for you and for any luckless subroutine that you happen
to call.  You should use the new C<//m> and C<//s> modifiers now to do
that without the dangerous action-at-a-distance effects of C<$*>.

=end original

(D) この変数は、自分のスクリプトでも、たまたま呼んだ先のサブルーティンでも、
複数行のパターンマッチを有効にしてしまいます。
C<$*> の離れたところに与える危険な影響を避けてこれを行なうために、
新しい C<//m> 修飾子と C<//s> 修飾子を使ってください。

=item Use of %s is deprecated

=begin original

(D deprecated) The construct indicated is no longer recommended for use,
generally because there's a better way to do it, and also because the
old way has bad side effects.

=end original

(D deprecated) 示した構文は、もはや使うことが推奨されません。
一般にはもっと良い方法があるからであり、また古い方法は、悪い副作用が
あるからです。

=item Use of $# is deprecated

=begin original

(D deprecated) This was an ill-advised attempt to emulate a poorly
defined B<awk> feature.  Use an explicit printf() or sprintf() instead.

=end original

(D deprecated) これは、貧相な awk の機能をエミュレートしようとする
ものでした。
代わりに、明示的に printf() や sprintf() を使ってください。

=item Use of reserved word "%s" is deprecated

=begin original

(D deprecated) The indicated bareword is a reserved word.  Future
versions of perl may use it as a keyword, so you're better off either
explicitly quoting the word in a manner appropriate for its context of
use, or using a different name altogether.  The warning can be
suppressed for subroutine names by either adding a C<&> prefix, or using
a package qualifier, e.g. C<&our()>, or C<Foo::our()>.

=end original

(D deprecated) 示されている裸の単語は予約語です。
将来のバージョンの perl ではこれをキーワードとして使う可能性があるので、
使っているコンテキストに適した形で単語をクォートするか、違う名前を
使ってください。
この警告は、サブルーチン名の前に C<&> を付ける(C<&our()>)か、
パッケージ修飾子を付ける(C<Foo::our()>)ことで消すことができます。

=item Use of uninitialized value%s

=begin original

(W uninitialized) An undefined value was used as if it were already
defined.  It was interpreted as a "" or a 0, but maybe it was a mistake.
To suppress this warning assign a defined value to your variables.

=end original

(W uninitialized) 未定義値を、あたかも既に定義されているかのように
使用しました。
これは、"" か 0 と解釈されますが、間違いの可能性があります。
この警告を止めるには、変数に定義された値を代入してください。

=begin original

To help you figure out what was undefined, perl tells you what operation
you used the undefined value in.  Note, however, that perl optimizes your
program and the operation displayed in the warning may not necessarily
appear literally in your program.  For example, C<"that $foo"> is
usually optimized into C<"that " . $foo>, and the warning will refer to
the C<concatenation (.)> operator, even though there is no C<.> in your
program.

=end original

To help you figure out what was undefined, perl tells you what operation
you used the undefined value in.  Note, however, that perl optimizes your
program and the operation displayed in the warning may not necessarily
appear literally in your program.  For example, C<"that $foo"> is
usually optimized into C<"that " . $foo>, and the warning will refer to
the C<concatenation (.)> operator, even though there is no C<.> in your
program.

=item Value of %s can be "0"; test with defined()

=begin original

(W misc) In a conditional expression, you used <HANDLE>, <*> (glob),
C<each()>, or C<readdir()> as a boolean value.  Each of these constructs
can return a value of "0"; that would make the conditional expression
false, which is probably not what you intended.  When using these
constructs in conditional expressions, test their values with the
C<defined> operator.

=end original

(W misc) 条件式の中で、<HANDLE>, <*> (グロブ), C<each()>, C<readdir()> を
真偽値として使いました。
これらの構文は値 "0" を返すことがあります; これは条件式では偽を示しますが、
これはおそらく望んでいることではないでしょう。
これらの構文を条件式の中で使うときは、その値を C<defined> 演算子で
テストしてください。

=item Value of CLI symbol "%s" too long

=begin original

(W misc) A warning peculiar to VMS.  Perl tried to read the value of an
%ENV element from a CLI symbol table, and found a resultant string
longer than 1024 characters.  The return value has been truncated to
1024 characters.

=end original

(W misc) VMS 固有の警告です。
Perl は CLI シンボルテーブルから %ENV 要素の値を読み込もうとしましたが、
結果の文字列が 1024 文字を越えました。
返り値は 1024 文字に切り詰められます。

=item Variable "%s" is not imported%s

=begin original

(F) While "use strict" in effect, you referred to a global variable that
you apparently thought was imported from another module, because
something else of the same name (usually a subroutine) is exported by
that module.  It usually means you put the wrong funny character on the
front of your variable.

=end original

(F) "use strict" が有効のときに、見たところ他のモジュールから
インポートされたとあなたが考えたグローバル変数を参照しました;
なぜなら同じ名前の何か他のもの(通常はサブルーチン)がそのモジュールから
エクスポートされています。
これは普通は変数の前に間違ったおかしな文字を置いたことを意味します。

=item "%s" variable %s masks earlier declaration in same %s

=begin original

(W misc) A "my" or "our" variable has been redeclared in the current
scope or statement, effectively eliminating all access to the previous
instance.  This is almost always a typographical error.  Note that the
earlier variable will still exist until the end of the scope or until
all closure referents to it are destroyed.

=end original

(W misc) 現在のスコープや文で "my" 変数や "our" 変数が再宣言されたので、
以前の実体への全てのアクセスができなくなりました。
これはほとんどの場合タイプミスです。
以前の変数は、スコープが終わるか、それを参照している全てのクロージャが
破壊されるまでは存在し続けることに注意してください。

=item Variable "%s" may be unavailable

=begin original

(W closure) An inner (nested) I<anonymous> subroutine is inside a
I<named> subroutine, and outside that is another subroutine; and the
anonymous (innermost) subroutine is referencing a lexical variable
defined in the outermost subroutine.  For example:

=end original

(W closure) 内部の(ネストした) I<無名> サブルーチンが I<名前つき>
サブルーチンの内側にあり、その外側は別のサブルーチンです;
そして無名の(一番内側の)サブルーチンが一番外側のサブルーチンで
定義されているレキシカル変数で参照されています。
例えば:

   sub outermost { my $a; sub middle { sub { $a } } }

=begin original

If the anonymous subroutine is called or referenced (directly or
indirectly) from the outermost subroutine, it will share the variable as
you would expect.  But if the anonymous subroutine is called or
referenced when the outermost subroutine is not active, it will see the
value of the shared variable as it was before and during the *first*
call to the outermost subroutine, which is probably not what you want.

=end original

無名サブルーチンが一番外側のサブルーチンから呼び出されるか(直接または
間接に)リファレンスされたとき、予想通りに変数は共有されます。
しかし、一番外側のサブルーチンが有効でない時に無名サブルーチンが呼び出されたり
リファレンスされたりすると、共有された変数の値は一番外側のサブルーチンへの
最初の呼び出し前および呼び出し中のものになります;
これはおそらく望んでいることではないでしょう。

=begin original

In these circumstances, it is usually best to make the middle subroutine
anonymous, using the C<sub {}> syntax.  Perl has specific support for
shared variables in nested anonymous subroutines; a named subroutine in
between interferes with this feature.

=end original

このような状況では、普通は C<sub {}> 構文を使って、サブルーチン middle を
無名にするのが最良です。
Perl はネストした無名サブルーチンで変数を共有する機能をサポートしています;
この機能のインターフェースの間の名前付きサブルーチンです。

=item Variable syntax

=begin original

(A) You've accidentally run your script through B<csh> instead
of Perl.  Check the #! line, or manually feed your script into
Perl yourself.

=end original

(A) スクリプトを perl ではなく B<csh> で実行しようとしました。
#! 行をチェックするか、スクリプトを直接 Perl で起動してください。

=item Variable "%s" will not stay shared

=begin original

(W closure) An inner (nested) I<named> subroutine is referencing a
lexical variable defined in an outer subroutine.

=end original

(W closure) 内部の(ネストした) I<名前付き> サブルーチンが、
外側のサブルーチンで定義したレキシカル変数を参照しています。

=begin original

When the inner subroutine is called, it will probably see the value of
the outer subroutine's variable as it was before and during the *first*
call to the outer subroutine; in this case, after the first call to the
outer subroutine is complete, the inner and outer subroutines will no
longer share a common value for the variable.  In other words, the
variable will no longer be shared.

=end original

内側のサブルーチンが呼び出された時、おそらく外側のサブルーチンの値は、
最初の外側のサブルーチンへの呼び出し前および呼び出し中のものになります;
この場合、外側のサブルーチンへの最初の呼び出しが終了した後、内側と
外側のサブルーチンは変数に関して同じ値を共有しなくなります。
言い換えると、変数はもはや共有されません。

=begin original

Furthermore, if the outer subroutine is anonymous and references a
lexical variable outside itself, then the outer and inner subroutines
will I<never> share the given variable.

=end original

さらに、外側のサブルーチンが無名で、それ自身の外側のレキシカル変数を
参照している場合、外側と内側のサブルーチンは与えられた変数は
共有 I<しません>。

=begin original

This problem can usually be solved by making the inner subroutine
anonymous, using the C<sub {}> syntax.  When inner anonymous subs that
reference variables in outer subroutines are called or referenced, they
are automatically rebound to the current values of such variables.

=end original

この問題は普通、C<sub {}> 構文を使って内側のサブルーチンを無名にすることで
解決します。
外側のサブルーチンの変数を参照している内側の無名サブルーチンが
呼び出されたり参照されたとき、これらはそのような変数の現在の値に
自動的に回復します。

=item Variable length lookbehind not implemented before << HERE in %s

=begin original

(F) Lookbehind is allowed only for subexpressions whose length is fixed and
known at compile time. The << HERE shows in the regular expression about where
the problem was discovered.

=end original

(F) 後方参照は長さが固定で、コンパイル時に確定している副式に対してのみ可能です。
<< HERE で正規表現のどこに問題が発見されたかを示しています。

=item Version number must be a constant number

=begin original

(P) The attempt to translate a C<use Module n.n LIST> statement into
its equivalent C<BEGIN> block found an internal inconsistency with
the version number.

=end original

(P) C<use Module n.n LIST> 文を等価な C<BEGIN> ブロックに変換しようと
したときに、バージョン番号について内部の不整合を発見しました。

=item Warning: something's wrong

=begin original

(W) You passed warn() an empty string (the equivalent of C<warn "">) or
you called it with no args and C<$_> was empty.

=end original

(W) warn() に空文字列を渡した (C<warn ""> と透過です) か、
引数なしで呼び出され、C<$_> も空でした。

=item Warning: unable to close filehandle %s properly

=begin original

(S) The implicit close() done by an open() got an error indication on
the close().  This usually indicates your file system ran out of disk
space.

=end original

(S) open() によって暗黙のうちに行なわれる close() が、
close() のエラーとなりました。
通常、ファイルシステムがいっぱいであることを示します。

=item Warning: Use of "%s" without parentheses is ambiguous

=begin original

(S ambiguous) You wrote a unary operator followed by something that
looks like a binary operator that could also have been interpreted as a
term or unary operator.  For instance, if you know that the rand
function has a default argument of 1.0, and you write

=end original

(S ambiguous) 単項演算子の後に、何か項にも単項演算子にも解釈できる、
二項演算子のようなものが置かれました。
たとえば、rand 関数がデフォルトの引数として、1.0 をとることを知って
いれば、以下のように書いて:

    rand + 5;

=begin original

you may THINK you wrote the same thing as

=end original

以下の同じことと思うかもしれませんが:

    rand() + 5;

=begin original

but in actual fact, you got

=end original

実際には以下のようになります:

    rand(+5);

=begin original

So put in parentheses to say what you really mean.

=end original

したがって、思うように解釈させるには、括弧が必要になります。

=item Wide character in %s

=begin original

(F) Perl met a wide character (>255) when it wasn't expecting one.

=end original

(F) Perl が(想定していないところで)ワイド文字(>255)に遭遇しました。

=item write() on closed filehandle %s

=begin original

(W closed) The filehandle you're writing to got itself closed sometime
before now.  Check your logic flow.

=end original

(W) 書き込みを行なおうとしたファイルハンドルは、既にクローズされています。
論理フローをチェックしてください。

=item X outside of string

=begin original

(F) You had a pack template that specified a relative position before
the beginning of the string being unpacked.  See L<perlfunc/pack>.

=end original

(F) unpack している文字列の先頭より前の相対位置を示している
pack テンプレートを指定しました。
L<perlfunc/pack> を参照してください。

=item x outside of string

=begin original

(F) You had a pack template that specified a relative position after
the end of the string being unpacked.  See L<perlfunc/pack>.

=end original

(F) unpack している文字列の最後より後の相対位置を示している
pack テンプレートを指定しました。
L<perlfunc/pack> を参照してください。

=item Xsub "%s" called in sort

=begin original

(F) The use of an external subroutine as a sort comparison is not yet
supported.

=end original

(F) ソートの比較ルーティンとして、外部サブルーティンを使用することは、
まだサポートされていません。

=item Xsub called in sort

=begin original

(F) The use of an external subroutine as a sort comparison is not yet
supported.

=end original

(F) ソートの比較ルーティンとして、外部サブルーティンを使用することは、
まだサポートされていません。

=item You can't use C<-l> on a filehandle

=begin original

(F) A filehandle represents an opened file, and when you opened the file
it already went past any symlink you are presumably trying to look for.
Use a filename instead.

=end original

(F) ファイルはオープンされたファイルを表わすものであり、
ファイルをオープンしたときには、探しているシンボリックリンクは、
既に通り過ぎた後です。
代わりにファイル名を使ってください。

=item YOU HAVEN'T DISABLED SET-ID SCRIPTS IN THE KERNEL YET!

=begin original

(F) And you probably never will, because you probably don't have the
sources to your kernel, and your vendor probably doesn't give a rip
about what you want.  Your best bet is to use the wrapsuid script in the
eg directory to put a setuid C wrapper around your script.

=end original

(F) (このカーネルでは、SET-ID スクリプトが禁止されていません!)
そして、そうすることはできないでしょう。　カーネルのソースはお持ちでは
ないでしょうし、ベンダも欲しいものを提供してはくれないでしょうから。
もっとも良いのは、スクリプトに setuid C ラッパーを被せるために、
eg ディレクトリの wrapsuid スクリプトを使ってみることです。

=item You need to quote "%s"

=begin original

(W syntax) You assigned a bareword as a signal handler name.
Unfortunately, you already have a subroutine of that name declared,
which means that Perl 5 will try to call the subroutine when the
assignment is executed, which is probably not what you want.  (If it IS
what you want, put an & in front.)

=end original

(W syntax) シグナルハンドラ名に、裸の単語を代入しました。
残念ながら、そのサブルーティンは既に宣言されていて、Perl 5 では、
おそらく思惑とは違って、代入の実行時にサブルーティンの呼び出しが起こります。
(もし、本当にそうしたいのであれば、サブルーティン名に & を付けてください。)

=back

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp>
Update: Kentaro Shirakata <argrath@ub32.org>
License: GPL or Artistic

=end meta

=cut
