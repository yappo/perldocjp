
=encoding euc-jp

=head1 NAME

=begin original

perlrun - how to execute the Perl interpreter

=end original

perlrun - Perl インタプリタの起動方法

=head1 SYNOPSIS

B<perl>	S<[ B<-sTtuUWX> ]>
	S<[ B<-hv> ] [ B<-V>[:I<configvar>] ]>
	S<[ B<-cw> ] [ B<-d>[B<t>][:I<debugger>] ] [ B<-D>[I<number/list>] ]>
	S<[ B<-pna> ] [ B<-F>I<pattern> ] [ B<-l>[I<octal>] ] [ B<-0>[I<octal/hexadecimal>] ]>
	S<[ B<-I>I<dir> ] [ B<-m>[B<->]I<module> ] [ B<-M>[B<->]I<'module...'> ] [ B<-f> ]>
	S<[ B<-C [I<number/list>] >]>
	S<[ B<-P> ]>
	S<[ B<-S> ]>
	S<[ B<-x>[I<dir>] ]>
	S<[ B<-i>[I<extension>] ]>
	S<[ B<-eE> I<'command'> ] [ B<--> ] [ I<programfile> ] [ I<argument> ]...>

=head1 DESCRIPTION

=begin original

The normal way to run a Perl program is by making it directly
executable, or else by passing the name of the source file as an
argument on the command line.  (An interactive Perl environment
is also possible--see L<perldebug> for details on how to do that.)
Upon startup, Perl looks for your program in one of the following
places:

=end original

Perl プログラムを実行する普通の方法は、直接実行できる形にするか、
コマンドラインの引数としてソースファイルの名前を渡すことです。
(対話的な Perl 環境もあります -- どのようにするかの詳細については
L<perldebug> を参照して下さい。)
実行にあたって、Perl は指定されたプログラムを以下に示す場所で
探します:

=over 4

=item 1.

=begin original

Specified line by line via B<-e> or B<-E> switches on the command line.

=end original

コマンドライン上で B<-e> か B<-E> のスイッチで指定された行。

=item 2.

=begin original

Contained in the file specified by the first filename on the command line.
(Note that systems supporting the #! notation invoke interpreters this
way. See L<Location of Perl>.)

=end original

コマンドライン上で最初のファイル名として示されたファイルの中。
(#! 記法をサポートしているシステムでは、このようにして
インタプリタを呼び出します。
L<Location of Perl> を参照して下さい。)

=item 3.

=begin original

Passed in implicitly via standard input.  This works only if there are
no filename arguments--to pass arguments to a STDIN-read program you
must explicitly specify a "-" for the program name.

=end original

標準入力から暗黙に渡される。
ファイル名を示す引数が無い場合にのみうまくいきます。
STDIN から読み込むプログラムに引数を渡すには、
プログラム名として明示的に "-" を指定しなくてはなりません、

=back

=begin original

With methods 2 and 3, Perl starts parsing the input file from the
beginning, unless you've specified a B<-x> switch, in which case it
scans for the first line starting with #! and containing the word
"perl", and starts there instead.  This is useful for running a program
embedded in a larger message.  (In this case you would indicate the end
of the program using the C<__END__> token.)

=end original

2 番目、3 番目の方法では、B<-x> スイッチを指定した場合を除いて、
Perl は入力ファイルを最初から解析し始めます。
　B<-x> スイッチを
指定した場合には、まず、最初に #! と "perl" という文字列を
含む行を探し、そこから解析を始めます。
これは、大きなテキストにプログラムを埋め込んで、実行するようなときに便利です。
(この場合、プログラムの終わりは、トークン C<__END__> を使って
示すとよいでしょう。)

=begin original

The #! line is always examined for switches as the line is being
parsed.  Thus, if you're on a machine that allows only one argument
with the #! line, or worse, doesn't even recognize the #! line, you
still can get consistent switch behavior regardless of how Perl was
invoked, even if B<-x> was used to find the beginning of the program.

=end original

#! を含む行のスイッチが必ず解析されるようになりました。
つまり、#! の行で引数が一つしか許されない、あるいはもっと悪く、
#! の行が認識されないといったシステムで運用している場合にも、B<-x> で
プログラムの開始位置を見つけた場合を含め、どのように Perl が起動されたかに
よらず、一貫したスイッチの動作を期待できるようになっています。

=begin original

Because historically some operating systems silently chopped off
kernel interpretation of the #! line after 32 characters, some
switches may be passed in on the command line, and some may not;
you could even get a "-" without its letter, if you're not careful.
You probably want to make sure that all your switches fall either
before or after that 32-character boundary.  Most switches don't
actually care if they're processed redundantly, but getting a "-"
instead of a complete switch could cause Perl to try to execute
standard input instead of your program.  And a partial B<-I> switch
could also cause odd results.

=end original

歴史的なオペレーティングシステムの中にはカーネルによる #! 行の解釈が、
エラーなしに 32 文字で打ち切られてしまうものがありますので、あるスイッチは
コマンドラインに渡され、あるスイッチは渡されないといったことが起こります。
注意しないと、文字が続かない "-" だけが渡されるといったことも
起こり得ます。
すべてのスイッチが、確実に 32 文字境界の前か後ろかのどちらかに
なるようにしたいことでしょう。
多くのスイッチは、余分に処理されても問題ありませんが、完全なスイッチの
代わりに "-" が入っていた場合には、プログラムの代わりに、標準入力を Perl に
実行させることになってしまいます。
B<-I> スイッチが中途半端になった場合にもおかしな結果となり得ます。

=begin original

Some switches do care if they are processed twice, for instance
combinations of B<-l> and B<-0>.  Either put all the switches after
the 32-character boundary (if applicable), or replace the use of
B<-0>I<digits> by C<BEGIN{ $/ = "\0digits"; }>.

=end original

2 回実行されることに注意する必要のあるスイッチもあります。
例えば B<-l> と B<-0> の組み合わせです。
(可能なら) 両方のスイッチが 32 文字境界の後ろにいくようにするか、
B<-0>I<digits> を C<BEGIN{ $/ = "\0digits"; }> で置き換えてください。

=begin original

Parsing of the #! switches starts wherever "perl" is mentioned in the line.
The sequences "-*" and "- " are specifically ignored so that you could,
if you were so inclined, say

=end original

#! スイッチの解析は、行内で "perl" が示された位置から始まります。
とりわけ "-*" と "- " という文字の並びは無視されますので、以下のように
書くと:

    #!/bin/sh -- # -*- perl -*- -p
    eval 'exec perl -wS $0 ${1+"$@"}'
        if $running_under_some_shell;

=begin original

to let Perl see the B<-p> switch.

=end original

Perl に B<-p> スイッチを渡すことができます。

=begin original

A similar trick involves the B<env> program, if you have it.

=end original

似たようなトリックは(持っていれば) B<env> プログラムでも使えます。

    #!/usr/bin/env perl

=begin original

The examples above use a relative path to the perl interpreter,
getting whatever version is first in the user's path.  If you want
a specific version of Perl, say, perl5.005_57, you should place
that directly in the #! line's path.

=end original

上の例は Perl インタプリタに相対パスを使って、
ユーザーの PATH で最初にあったバージョンを使います。
もし特定のバージョンの Perl、例えば perl5.005_57 が使いたいなら、
#! 行のパスに直接書くべきです。

=begin original

If the #! line does not contain the word "perl", the program named after
the #! is executed instead of the Perl interpreter.  This is slightly
bizarre, but it helps people on machines that don't do #!, because they
can tell a program that their SHELL is F</usr/bin/perl>, and Perl will then
dispatch the program to the correct interpreter for them.

=end original

#! 行に "perl" という語が含まれていなければ、#! の後に指定された
プログラムが Perl インタプリタの代わりに実行されます。
これは少し変わっていますが、#! が行なえないマシンを使っている方には
有効でしょう。
プログラムに対して使っている SHELL が F</usr/bin/perl> だと言っておけば、
Perl が正しいインタプリタを起動してくれるからです。

=begin original

After locating your program, Perl compiles the entire program to an
internal form.  If there are any compilation errors, execution of the
program is not attempted.  (This is unlike the typical shell script,
which might run part-way through before finding a syntax error.)

=end original

プログラムの場所が特定できたなら、Perl はプログラム全体を内部形式に
コンパイルし始めます。
コンパイルエラーが見つかった時には、プログラムの実行は行なわれません。
(これは、構文エラーがある場合にも、途中まで実行される可能性のある、
典型的なシェルのスクリプトと異なる点です。)

=begin original

If the program is syntactically correct, it is executed.  If the program
runs off the end without hitting an exit() or die() operator, an implicit
C<exit(0)> is provided to indicate successful completion.

=end original

プログラムが構文的に正しければ、実行されることになります。
プログラムが、exit() 演算子にも die() 演算子にも当たらないで最後まで
到達すると、正常に完了したことを示すために、暗黙の C<exit(0)> が
行なわれます。

=head2 #! and quoting on non-Unix systems
X<hashbang> X<#!>

(非 Unix システムでの #! とクォート)

=begin original

Unix's #! technique can be simulated on other systems:

=end original

Unix の #! のテクニックは他のシステムでもシミュレートされています。

=over 4

=item OS/2

=begin original

Put

=end original

以下のように

    extproc perl -S -your_switches

=begin original

as the first line in C<*.cmd> file (B<-S> due to a bug in cmd.exe's
`extproc' handling).

=end original

C<*.cmd> ファイルの最初の行に書いてください (B<-S> は cmd.exe の
`extproc' の扱いのバグを引き起こします)。

=item MS-DOS

=begin original

Create a batch file to run your program, and codify it in
C<ALTERNATE_SHEBANG> (see the F<dosish.h> file in the source
distribution for more information).

=end original

プログラムを実行するバッチファイルを作って、C<ALTERNATE_SHEBANG> で
コード化してください (さらなる情報についてはソース配布パッケージの
F<dosish.h> ファイルを参照して下さい)。

=item Win95/NT

=begin original

The Win95/NT installation, when using the ActiveState installer for Perl,
will modify the Registry to associate the F<.pl> extension with the perl
interpreter.  If you install Perl by other means (including building from
the sources), you may have to modify the Registry yourself.  Note that
this means you can no longer tell the difference between an executable
Perl program and a Perl library file.

=end original

Win95/NT でのインストールにおいて、ActiveState の Perl 用インストーラを
使った場合は、拡張子 F<.pl> を Perl インタプリタに関連付けるよう
レジストリを変更します。
他の方法で Perl をインストールした場合(ソースから構築した場合を含みます)、
レジストリを自分で変更する必要があります。
これは実行可能な Perl プログラムと Perl ライブラリファイルとの
違いがなくなってしまうことに注意してください。

=item Macintosh

=begin original

Under "Classic" MacOS, a perl program will have the appropriate Creator and
Type, so that double-clicking them will invoke the MacPerl application.
Under Mac OS X, clickable apps can be made from any C<#!> script using Wil
Sanchez' DropScript utility: http://www.wsanchez.net/software/ .

=end original

"Classic" MacOS では、perl プログラムは適切な Creator と Type を
持っているので、ダブルクリックすれば Perl アプリケーションを起動できます。
Mac OS X では、クリック可能なアプリケーションは、どんな C<#!> からでも
Wil Sanchez' DropScript utility を使うことで作成できます:
http://www.wsanchez.net/software/ 。

=item VMS

=begin original

Put

=end original

以下のように

    $ perl -mysw 'f$env("procedure")' 'p1' 'p2' 'p3' 'p4' 'p5' 'p6' 'p7' 'p8' !
    $ exit++ + ++$status != 0 and $exit = $status = undef;

=begin original

at the top of your program, where B<-mysw> are any command line switches you
want to pass to Perl.  You can now invoke the program directly, by saying
C<perl program>, or as a DCL procedure, by saying C<@program> (or implicitly
via F<DCL$PATH> by just using the name of the program).

=end original

プログラムの先頭に書いてください。
ここで B<-mysw> は Perl に渡したいコマンドラインスイッチです。
これで C<perl program> として直接プログラムを起動できますし、
C<@program> として(あるいは F<DCL$PATH> 経由でプログラム名を使って)
DSL 手続きとして起動できます。

=begin original

This incantation is a bit much to remember, but Perl will display it for
you if you say C<perl "-V:startperl">.

=end original

この決まり文句は覚えるには少々長すぎますが、C<perl "-V:startperl"> とすれば
Perl がこれを表示してくれます。

=back

=begin original

Command-interpreters on non-Unix systems have rather different ideas
on quoting than Unix shells.  You'll need to learn the special
characters in your command-interpreter (C<*>, C<\> and C<"> are
common) and how to protect whitespace and these characters to run
one-liners (see B<-e> below).

=end original

非 Unix システムのコマンドインタプリタはクォートに関して
Unix シェルと異なった考え方をしています。
お使いのコマンドインタプリタの特殊文字について (C<*>, C<\>, C<"> は
一般的です)、そして一行で起動するために(後述する B<-e> を参照して下さい)
空白や特殊文字を保護する方法について学ぶ必要があるでしょう。

=begin original

On some systems, you may have to change single-quotes to double ones,
which you must I<not> do on Unix or Plan 9 systems.  You might also
have to change a single % to a %%.

=end original

システムによってはシングルクォートをダブルクォートに変更する必要が
あるかもしれません。
しかし Unix や Plan9 のシステムでは I<してはいけません>。
また、単体の % を %% に変更する必要があるかもしれません。

=begin original

For example:

=end original

例えば:

    # Unix
    perl -e 'print "Hello world\n"'

    # MS-DOS, etc.
    perl -e "print \"Hello world\n\""

    # Macintosh
    print "Hello world\n"
     (then Run "Myscript" or Shift-Command-R)

    # VMS
    perl -e "print ""Hello world\n"""

=begin original

The problem is that none of this is reliable: it depends on the
command and it is entirely possible neither works.  If B<4DOS> were
the command shell, this would probably work better:

=end original

問題は、これらはどれも信頼性がないことです。
これはコマンドに依存し、どれも動かないかもしれません。
B<4DOS> がコマンドシェルなら、おそらくよりよく動きます:

    perl -e "print <Ctrl-x>"Hello world\n<Ctrl-x>""

=begin original

B<CMD.EXE> in Windows NT slipped a lot of standard Unix functionality in
when nobody was looking, but just try to find documentation for its
quoting rules.

=end original

Windows NT の B<CMD.EXE> は誰も見ていない間に多くの標準 Unix 機能が
入り込んでいますが、クォートのルールに関しては
ドキュメントを探してみてください。

=begin original

Under the Macintosh, it depends which environment you are using.  The MacPerl
shell, or MPW, is much like Unix shells in its support for several
quoting variants, except that it makes free use of the Macintosh's non-ASCII
characters as control characters.

=end original

Macintosh では、使っている環境に依存します。
MacPerl shell や MPW はクォート関係の対応に関して
かなり Unix シェルと似ています。
しかし、Macintosh の非 ASCII 文字をコントロール文字として
自由に使うことができます。

=begin original

There is no general solution to all of this.  It's just a mess.

=end original

この辺りのことに関する一般的な解決方法はありません。
まったくぐちゃぐちゃです。

=head2 Location of Perl
X<perl, location of interpreter>

(Perl の位置)

=begin original

It may seem obvious to say, but Perl is useful only when users can
easily find it.  When possible, it's good for both F</usr/bin/perl>
and F</usr/local/bin/perl> to be symlinks to the actual binary.  If
that can't be done, system administrators are strongly encouraged
to put (symlinks to) perl and its accompanying utilities into a
directory typically found along a user's PATH, or in some other
obvious and convenient place.

=end original

当たり前のように聞こえるかもしれませんが、
Perl はユーザーが簡単に発見できる場合にのみ有用です。
可能なら、F</usr/bin/perl> と F</usr/local/bin/perl> の両方に
実際のバイナリへのシンボリックリンクを置くというのはよい考えです。
もしこれが無理なら、システム管理者は Perl と付随するユーティリティ (への
シンボリックリンク) を、典型的にユーザーの PATH で見付かるディレクトリか、
その他の明らかで便利な場所に置くべきです。

=begin original

In this documentation, C<#!/usr/bin/perl> on the first line of the program
will stand in for whatever method works on your system.  You are
advised to use a specific path if you care about a specific version.

=end original

このドキュメントでは、C<#!/usr/bin/perl> とプログラムの先頭に書けば
システムの全てのメソッドが実行できるものとしています。
特定のバージョンを使いたい場合は、特定のパスを使うか:

    #!/usr/local/bin/perl5.00554

=begin original

or if you just want to be running at least version, place a statement
like this at the top of your program:

=end original

あるいは単に最低限のバージョンを指定した場合は、
以下のような行をプログラムの先頭に置いてください:

    use 5.005_54;

=head2 Command Switches
X<perl, command switches> X<command switches>

(コマンドスイッチ)

=begin original

As with all standard commands, a single-character switch may be
clustered with the following switch, if any.

=end original

全ての標準コマンドと同様に、1 文字のスイッチは、次に続くスイッチが
あれば、それとつなげることができます。

    #!/usr/bin/perl -spi.orig	# same as -s -p -i.orig

=begin original

Switches include:

=end original

スイッチ一覧:

=over 5

=item B<-0>[I<octal/hexadecimal>]
X<-0> X<$/>

=begin original

specifies the input record separator (C<$/>) as an octal or
hexadecimal number.  If there are no digits, the null character is the
separator.  Other switches may precede or follow the digits.  For
example, if you have a version of B<find> which can print filenames
terminated by the null character, you can say this:

=end original

入力レコードセパレータ (C<$/>) を 8 進数または 16 進数で示します。
digits を指定しないと、ヌル文字がセパレータになります。
他のスイッチを前に置いてもかまいませんし、digits のあとに
つなげてもかまいません。
たとえば、ファイル名をヌル文字で区切って表示できる find があれば:

    find . -name '*.orig' -print0 | perl -n0e unlink

=begin original

The special value 00 will cause Perl to slurp files in paragraph mode.
The value 0777 will cause Perl to slurp files whole because there is no
legal byte with that value.

=end original

00 という特別な値は、Perl にパラグラフモードで、ファイルを読ませます。
0777 という値は、該当するバイトがないため、
Perl にファイル全体を読ませることになります。

=begin original

If you want to specify any Unicode character, use the hexadecimal
format: C<-0xHHH...>, where the C<H> are valid hexadecimal digits.
(This means that you cannot use the C<-x> with a directory name that
consists of hexadecimal digits.)

=end original

Unicode 文字を指定したい場合は、16 進数のフォーマット C<-0xHHH...> を
使ってください。
ここで C<H> は 16 進数として有効な文字です
(これは C<-x> で 16 進数の数値からなるディレクトリ名を指定できない
ことを意味します)。

=item B<-a>
X<-a> X<autosplit>

=begin original

turns on autosplit mode when used with a B<-n> or B<-p>.  An implicit
split command to the @F array is done as the first thing inside the
implicit while loop produced by the B<-n> or B<-p>.

=end original

B<-n> や B<-p> といっしょに用いると、自動 split モードになります。
B<-n> や B<-p> で作られる暗黙のループ内の最初の文として、
配列 @F への暗黙の split コマンドが実行されます。

    perl -ane 'print pop(@F), "\n";'

=begin original

is equivalent to

=end original

は以下のものと等価です。

    while (<>) {
	@F = split(' ');
	print pop(@F), "\n";
    }

=begin original

An alternate delimiter may be specified using B<-F>.

=end original

B<-F> を使って区切文字を変更することができます。

=item B<-C [I<number/list>]>
X<-C>

=begin original

The C<-C> flag controls some of the Perl Unicode features.

=end original

C<-C>フラグは Perl Unicode 機能のいくつかを制御します。

=begin original

As of 5.8.1, the C<-C> can be followed either by a number or a list
of option letters.  The letters, their numeric values, and effects
are as follows; listing the letters is equal to summing the numbers.

=end original

5.8.1 から、C<-C> フラグは数値またはオプション文字のリストを
つけることが出来ます。
指定可能な文字と数値およびその効果は以下の通りです;
文字のリストは数値の合計と同じです。

=begin original

    I     1   STDIN is assumed to be in UTF-8
    O     2   STDOUT will be in UTF-8
    E     4   STDERR will be in UTF-8
    S     7   I + O + E
    i     8   UTF-8 is the default PerlIO layer for input streams
    o    16   UTF-8 is the default PerlIO layer for output streams
    D    24   i + o
    A    32   the @ARGV elements are expected to be strings encoded
              in UTF-8
    L    64   normally the "IOEioA" are unconditional,
              the L makes them conditional on the locale environment
              variables (the LC_ALL, LC_TYPE, and LANG, in the order
              of decreasing precedence) -- if the variables indicate
              UTF-8, then the selected "IOEioA" are in effect
    a   256   Set ${^UTF8CACHE} to -1, to run the UTF-8 caching code in
              debugging mode.

=end original

    I     1   STDIN は UTF-8 と仮定する
    O     2   STDOUT は UTF-8 と仮定する
    E     4   STDERR は UTF-8 と仮定する
    S     7   I + O + E
    i     8   UTF-8 は入力ストリームのデフォルト PerlIO 層
    o    16   UTF-8 は出力ストリームのデフォルト PerlIO 層
    D    24   i + o
    A    32   @ARGV の要素は UTF-8 でエンコードされた文字列と推測する
    L    64   通常は "IOEioA" は無条件ですが、
              L はロケール環境変数(LC_ALL, LC_TYPE, LANG, 優先度順)によって
              条件付きとなります  -- もし変数が UTF-8 を示していれば、
              選択された "IOEioA" が有効になります
    a   256   デバッグモードで UTF-8 キャッシュコードを実行するために、
              ${^UTF8CACHE} を -1 にセットする。

=for documenting_the_underdocumented
perl.h gives W/128 as PERL_UNICODE_WIDESYSCALLS "/* for Sarathy */"

=for todo
perltodo mentions Unicode in %ENV and filenames. I guess that these will be
options e and f (or F).

=begin original

For example, C<-COE> and C<-C6> will both turn on UTF-8-ness on both
STDOUT and STDERR.  Repeating letters is just redundant, not cumulative
nor toggling.

=end original

例えば、C<-COE> と C<-C6> はどちらも STDOUT と STDERR を UTF-8 化します。
同じ文字を繰り返しても冗長なだけで、加算されたりトグルになったりはしません。

=begin original

The C<io> options mean that any subsequent open() (or similar I/O
operations) will have the C<:utf8> PerlIO layer implicitly applied
to them, in other words, UTF-8 is expected from any input stream,
and UTF-8 is produced to any output stream.  This is just the default,
with explicit layers in open() and with binmode() one can manipulate
streams as usual.

=end original

C<io> オプションは引き続く open() (あるいは同様の I/O 操作) において
暗黙的に C<:utf8> PerlIO 層が適用されます。
言い換えると、入力ストリームでは UTF-8 が想定され、出力ストリームは
UTF-8 で出力されます。
これは単にデフォルトであり、通常どおり open() と binmode() で明示的に
変更できます。

=begin original

C<-C> on its own (not followed by any number or option list), or the
empty string C<""> for the C<PERL_UNICODE> environment variable, has the
same effect as C<-CSDL>.  In other words, the standard I/O handles and
the default C<open()> layer are UTF-8-fied B<but> only if the locale
environment variables indicate a UTF-8 locale.  This behaviour follows
the I<implicit> (and problematic) UTF-8 behaviour of Perl 5.8.0.

=end original

C<-C> が単体で(数値やオプションリストなし)起動されるか、
C<PERL_UNICODE> 環境変数が空文字列 C<""> の場合、C<-CSDL> と
同じ効果となります。
言い換えると、標準 I/O 操作とデフォルトの C<open()> 層はロケール環境変数が
UTF-8 ロケールを示している場合 B<のみ> UTF-8 化されます。
この振る舞いは Perl 5.8.0 での I<暗黙の> (そして問題のある) UTF-8 に
関する振る舞いと同じです。

=begin original

You can use C<-C0> (or C<"0"> for C<PERL_UNICODE>) to explicitly
disable all the above Unicode features.

=end original

C<-C0> (あるいは C<PERL_UNICODE> に C<"0">) を指定すると
明示的に上記の全ての Unicode 機能を無効にします。

=begin original

The read-only magic variable C<${^UNICODE}> reflects the numeric value
of this setting.  This is variable is set during Perl startup and is
thereafter read-only.  If you want runtime effects, use the three-arg
open() (see L<perlfunc/open>), the two-arg binmode() (see L<perlfunc/binmode>),
and the C<open> pragma (see L<open>).

=end original

読み込み専用のマジック変数 C<${^UNICODE}> にこの設定の数値表現が
反映されます。
これは Perl 起動時にセットされる変数で、読み込み専用です。
実行中に効果を得たい場合は、3 引数の open() (L<perlfunc/open> 参照),
2 引数の binmode() (L<perlfunc/binmode> 参照), C<open> プラグマ
(L<open> 参照) を使ってください。

=begin original

(In Perls earlier than 5.8.1 the C<-C> switch was a Win32-only switch
that enabled the use of Unicode-aware "wide system call" Win32 APIs.
This feature was practically unused, however, and the command line
switch was therefore "recycled".)

=end original

(5.8.1 以前の Perl では C<-C> スイッチは Win32 専用のスイッチで、
Unicode 対応の "ワイド文字システムコール" Win32 API を使うためのものでした。
この機能は事実上使われませんでしたが、コマンドラインスイッチは
"再利用" されました。)

=item B<-c>
X<-c>

=begin original

causes Perl to check the syntax of the program and then exit without
executing it.  Actually, it I<will> execute C<BEGIN>, C<UNITCHECK>,
C<CHECK>, and C<use> blocks, because these are considered as occurring
outside the execution of your program.  C<INIT> and C<END> blocks,
however, will be skipped.

=end original

Perl にスクリプトの構文のチェックを行なわせ、実行せずに
終了するようにします。
実際には、C<BEGIN>, C<UNITCHECK>, C<CHECK>, C<use> ブロックは
I<実行します>。
これらはプログラムの実行の外側にあるものと考えられるからです。
C<INIT> と C<END> ブロックはスキップされます。

=item B<-d>
X<-d> X<-dt>

=item B<-dt>

=begin original

runs the program under the Perl debugger.  See L<perldebug>.
If B<t> is specified, it indicates to the debugger that threads
will be used in the code being debugged.

=end original

Perl デバッガの下でプログラムを実行します。
L<perldebug> を参照してください。
B<t> が指定されると、デバッグするコードがスレッドを使っていることを
デバッガに示します。

=item B<-d:>I<foo[=bar,baz]>
X<-d> X<-dt>

=item B<-dt:>I<foo[=bar,baz]>

=begin original

runs the program under the control of a debugging, profiling, or
tracing module installed as Devel::foo. E.g., B<-d:DProf> executes
the program using the Devel::DProf profiler.  As with the B<-M>
flag, options may be passed to the Devel::foo package where they
will be received and interpreted by the Devel::foo::import routine.
The comma-separated list of options must follow a C<=> character.
If B<t> is specified, it indicates to the debugger that threads
will be used in the code being debugged.
See L<perldebug>.

=end original

Devel::foo としてインストールされる デバッグ・プロファイリング・
トレースモジュールの制御下でプログラムを実行します。
つまり、B<-d:DProf> は Devel::DProf プロファイラを使って
プログラムを実行します。
B<-M> フラグと共に使うと、オプションは Devel::foo パッケージに渡され、
Devel::foo::import ルーチンで解釈されます。
オプションをコンマ区切りのリストにするときは C<=> の文字の後に
続けなければなりません。
B<t> が指定されると、デバッグするコードがスレッドを使っていることを
デバッガに示します。
L<perldebug> を参照して下さい。

=item B<-D>I<letters>
X<-D> X<DEBUGGING> X<-DDEBUGGING>

=item B<-D>I<number>

=begin original

sets debugging flags.  To watch how it executes your program, use
B<-Dtls>.  (This works only if debugging is compiled into your
Perl.)  Another nice value is B<-Dx>, which lists your compiled
syntax tree.  And B<-Dr> displays compiled regular expressions;
the format of the output is explained in L<perldebguts>.

=end original

デバッグフラグを設定します。
スクリプトがどのように実行されるかを見るには、B<-Dtls> を使ってください。
(これは、デバッグ機能を盛り込んでコンパイルしたときにだけ働きます。)
この他に役に立つ値としては、コンパイルされた構文ツリーを表示する、
B<-Dx> があげられます。
B<-Dr> は、コンパイルした正規表現を表示します。
出力形式については L<perldebguts> に説明があります。

=begin original

As an alternative, specify a number instead of list of letters (e.g.,
B<-D14> is equivalent to B<-Dtls>):

=end original

文字のリストの代わりに数字を指定することもできます
(たとえば、B<-D14> は B<-Dtls> と等価です):

=begin original

        1  p  Tokenizing and parsing (with v, displays parse stack)
        2  s  Stack snapshots (with v, displays all stacks)
        4  l  Context (loop) stack processing
        8  t  Trace execution
       16  o  Method and overloading resolution
       32  c  String/numeric conversions
       64  P  Print profiling info, preprocessor command for -P, source file input state
      128  m  Memory allocation
      256  f  Format processing
      512  r  Regular expression parsing and execution
     1024  x  Syntax tree dump
     2048  u  Tainting checks
     4096  U  Unofficial, User hacking (reserved for private, unreleased use)
     8192  H  Hash dump -- usurps values()
    16384  X  Scratchpad allocation
    32768  D  Cleaning up
    65536  S  Thread synchronization
   131072  T  Tokenising
   262144  R  Include reference counts of dumped variables (eg when using -Ds)
   524288  J  Do not s,t,P-debug (Jump over) opcodes within package DB
  1048576  v  Verbose: use in conjunction with other flags
  2097152  C  Copy On Write
  4194304  A  Consistency checks on internal structures
  8388608  q  quiet - currently only suppresses the "EXECUTING" message

=end original

        1  p  トークン化と構文解析 (v と併用されると、パーススタックの表示)
        2  s  スタックの表示 (v と併用されると、全てのスタックの表示)
        4  l  コンテキスト(ループ)スタックの処理
        8  t  実行のトレース
       16  o  メソッドとオーバーロードの解決
       32  c  文字列/数値変換
       64  P  プロファイリング情報、-P のためのプリプロセッサコマンド、ソースファイル入力状態の表示
      128  m  メモリ配置
      256  f  フォーマットの処理
      512  r  正規表現の解析と実効
     1024  x  構文トリーのダンプ
     2048  u  汚染チェック
     4096  U  非公式な、ユーザーハック (プライベートな、リリースされない利用法のために予約)
     8192  H  ハッシュのダンプ -- values() の横取り
    16384  X  スクラッチパッドの配置
    32768  D  全消去
    65536  S  スレッド同期
   131072  T  トークン化
   262144  R  ダンプされた変数のリファレンスカウントを含む(-Dsのとき)
   524288  J  DB パッケージの中では s,t,P デバッグコードを実行しない
  1048576  v  詳細: 他のフラグと組み合わせて使う
  2097152  C  コピーオンライト
  4194304  A  内部構造の一貫性チェック
  8388608  q  静粛 - 現在のところ "EXECUTING" メッセージだけを抑制する

=begin original

All these flags require B<-DDEBUGGING> when you compile the Perl
executable (but see L<Devel::Peek>, L<re> which may change this).
See the F<INSTALL> file in the Perl source distribution
for how to do this.  This flag is automatically set if you include B<-g>
option when C<Configure> asks you about optimizer/debugger flags.

=end original

これらの全てのフラグは Perl 実行ファイルをコンパイルするときに
B<-DDEBUGGING> が指定されている必要があります
(但しこれを変更するときは L<Devel::Peek>, L<re> を参照してください)。
そうするためにどうすればいいかについては Perl のソース配布パッケージの
F<INSTALL> ファイルを参照して下さい。
このフラグは C<Configure> が最適化/デバッガフラグを尋ねたときに
B<-g> オプション込みで指定すれば自動的にセットされます。

=begin original

If you're just trying to get a print out of each line of Perl code
as it executes, the way that C<sh -x> provides for shell scripts,
you can't use Perl's B<-D> switch.  Instead do this

=end original

シェルスクリプトにおける C<sh -x> のように、単に今実行している Perl の
コードを表示したい場合は、Perl の B<-D> スイッチは使えません。
代わりに以下のようにしてください:

  # If you have "env" utility
  env PERLDB_OPTS="NonStop=1 AutoTrace=1 frame=2" perl -dS program

  # Bourne shell syntax
  $ PERLDB_OPTS="NonStop=1 AutoTrace=1 frame=2" perl -dS program

  # csh syntax
  % (setenv PERLDB_OPTS "NonStop=1 AutoTrace=1 frame=2"; perl -dS program)

=begin original

See L<perldebug> for details and variations.

=end original

詳細とバリエーションについては L<perldebug> を参照して下さい。

=item B<-e> I<commandline>
X<-e>

=begin original

may be used to enter one line of program.  If B<-e> is given, Perl
will not look for a filename in the argument list.  Multiple B<-e>
commands may be given to build up a multi-line script.  Make sure
to use semicolons where you would in a normal program.

=end original

1 行のプログラムを指定するのに使用します。
B<-e> が指定されると Perl は引数のリストからはファイル名を探しません。
複数の -e コマンドで、複数行のスクリプトを構成することができます。
通常のプログラムでセミコロンを置くところには、セミコロンを使うことに
気を付けてください。

=item B<-E> I<commandline>
X<-E>

=begin original

behaves just like B<-e>, except that it implicitly enables all
optional features (in the main compilation unit). See L<feature>.

=end original

B<-e> と同様に振る舞いますが、暗黙に全てのオプション機能を(main
コンパイル単位で)有効にします。
L<feature> を参照してください。

=item B<-f>
X<-f>

=begin original

Disable executing F<$Config{sitelib}/sitecustomize.pl> at startup.

=end original

起動時の F<$Config{sitelib}/sitecustomize.pl> の実行を無効化します。

=begin original

Perl can be built so that it by default will try to execute
F<$Config{sitelib}/sitecustomize.pl> at startup.  This is a hook that
allows the sysadmin to customize how perl behaves.  It can for
instance be used to add entries to the @INC array to make perl find
modules in non-standard locations.

=end original

Perl は実行時にデフォルトで F<$Config{sitelib}/sitecustomize.pl> を
実行しようとさせるようにビルドできます。
これはシステム管理者が、perl がどのように振る舞うかをカスタマイズするための
フックです。
例えば、perl が非標準の位置にあるモジュールを見つけられるように @INC 配列に
エントリを追加するために使えます。

=item B<-F>I<pattern>
X<-F>

=begin original

specifies the pattern to split on if B<-a> is also in effect.  The
pattern may be surrounded by C<//>, C<"">, or C<''>, otherwise it will be
put in single quotes. You can't use literal whitespace in the pattern.

=end original

B<-a> も有効なときに、split を行なう正規表現を指定します。
パターンは C<//>, C<"">, C<''> で囲むか、シングルクォートの中に書きます。
パターン中にリテラルな空白は使えません。

=item B<-h>
X<-h>

=begin original

prints a summary of the options.

=end original

オプションの一覧を表示します。

=item B<-i>[I<extension>]
X<-i> X<in-place>

=begin original

specifies that files processed by the C<E<lt>E<gt>> construct are to be
edited in-place.  It does this by renaming the input file, opening the
output file by the original name, and selecting that output file as the
default for print() statements.  The extension, if supplied, is used to
modify the name of the old file to make a backup copy, following these
rules:

=end original

C<E<lt>E<gt>> の構文で処理されたファイルを置き換えるための拡張子を
指定します。
これは、入力ファイルをリネームし、元の名前で出力ファイルを open し、
print() 文のデフォルトとしてその出力ファイルを select することで行ないます。
extension が指定されると、昔の内容のバックアップを行なう
ファイル名の拡張子として、元のファイル名に付け加えられます。

=begin original

If no extension is supplied, no backup is made and the current file is
overwritten.

=end original

extension が指定されないと、バックアップを作らず、現在のファイルが
上書きされます。

=begin original

If the extension doesn't contain a C<*>, then it is appended to the
end of the current filename as a suffix.  If the extension does
contain one or more C<*> characters, then each C<*> is replaced
with the current filename.  In Perl terms, you could think of this
as:

=end original

extension に C<*> が含まれていない場合、現在のファイル名の末尾に
接尾子として付け加えられます。
extension に一つ以上の C<*> の文字がある場合、
それぞれの C<*> は現在のファイル名で置き換えられます。
Perl 的に書くと、以下のようになります:

    ($backup = $extension) =~ s/\*/$file_name/g;

=begin original

This allows you to add a prefix to the backup file, instead of (or in
addition to) a suffix:

=end original

以下のようにすると、(接尾子の代わりに、あるいは接尾子に加えて)
バックアップファイルに接頭子をつけることができます。

    $ perl -pi'orig_*' -e 's/bar/baz/' fileA	# backup to 'orig_fileA'

=begin original

Or even to place backup copies of the original files into another
directory (provided the directory already exists):

=end original

元のファイルのバックアップコピーを(既にある)他のディレクトリに作ることも
できます:

    $ perl -pi'old/*.orig' -e 's/bar/baz/' fileA # backup to 'old/fileA.orig'

=begin original

These sets of one-liners are equivalent:

=end original

以下の一行スクリプトは全て等価です:

    $ perl -pi -e 's/bar/baz/' fileA		# overwrite current file
    $ perl -pi'*' -e 's/bar/baz/' fileA		# overwrite current file

    $ perl -pi'.orig' -e 's/bar/baz/' fileA	# backup to 'fileA.orig'
    $ perl -pi'*.orig' -e 's/bar/baz/' fileA	# backup to 'fileA.orig'

=begin original

From the shell, saying

=end original

シェルから以下のように起動すると:

    $ perl -p -i.orig -e "s/foo/bar/; ... "

=begin original

is the same as using the program:

=end original

プログラムで以下のようにするのと同じで:

    #!/usr/bin/perl -pi.orig
    s/foo/bar/;

=begin original

which is equivalent to

=end original

以下とほぼ等価です:

    #!/usr/bin/perl
    $extension = '.orig';
    LINE: while (<>) {
	if ($ARGV ne $oldargv) {
	    if ($extension !~ /\*/) {
		$backup = $ARGV . $extension;
	    }
	    else {
		($backup = $extension) =~ s/\*/$ARGV/g;
	    }
	    rename($ARGV, $backup);
	    open(ARGVOUT, ">$ARGV");
	    select(ARGVOUT);
	    $oldargv = $ARGV;
	}
	s/foo/bar/;
    }
    continue {
	print;	# this prints to original filename
    }
    select(STDOUT);

=begin original

except that the B<-i> form doesn't need to compare $ARGV to $oldargv to
know when the filename has changed.  It does, however, use ARGVOUT for
the selected filehandle.  Note that STDOUT is restored as the default
output filehandle after the loop.

=end original

違うのは、B<-i> の形式が、いつファイル名が変わったかを知るために、
$ARGV と $oldargv を比較する必要がないことです。
しかしながら、選択するファイルハンドルとして ARGVOUT は使用します。
ループのあとは、STDOUT がデフォルトのファイルハンドルとして再設定されます。

=begin original

As shown above, Perl creates the backup file whether or not any output
is actually changed.  So this is just a fancy way to copy files:

=end original

上述の通り、Perl はバックアップファイルを実際に出力が変更されたかどうかに
関わらず作成します。
従って、以下はファイルをコピーする変わった方法となります:

    $ perl -p -i'/some/file/path/*' -e 1 file1 file2 file3...
or
    $ perl -p -i'.orig' -e 1 file1 file2 file3...

=begin original

You can use C<eof> without parentheses to locate the end of each input
file, in case you want to append to each file, or reset line numbering
(see example in L<perlfunc/eof>).

=end original

個々のファイルの終わりに何かを付け加えたいときや、行番号を
リセットしたいような場合に、個々の入力ファイルの終わりを知るために、
括弧の無い C<eof> を使うことができます。
(L<perlfunc/eof> の例を参照してください。)

=begin original

If, for a given file, Perl is unable to create the backup file as
specified in the extension then it will skip that file and continue on
with the next one (if it exists).

=end original

与えられたファイルに対して、Perl が指定された拡張子でバックアップファイルを
作れない場合、そのファイルはスキップされて(もしあれば)次のファイルに
移って継続します。

=begin original

For a discussion of issues surrounding file permissions and B<-i>,
see L<perlfaq5/Why does Perl let me delete read-only files?  Why does -i clobber protected files?  Isn't this a bug in Perl?>.

=end original

ファイルのパーミッションと B<-i> に関する議論については、
L<perlfaq5/Why does Perl let me delete read-only files?  Why does -i clobber protected files?  Isn't this a bug in Perl?> を
参照して下さい。

=begin original

You cannot use B<-i> to create directories or to strip extensions from
files.

=end original

B<-i> は、ディレクトリを作ったり、ファイルの拡張子を取り除いたりは
できません。

=begin original

Perl does not expand C<~> in filenames, which is good, since some
folks use it for their backup files:

=end original

Perl は C<~> を展開しません。
これはバックアップファイルを以下のようにして作る人々のためにはよいことです。

    $ perl -pi~ -e 's/foo/bar/' file1 file2 file3...

=begin original

Note that because B<-i> renames or deletes the original file before
creating a new file of the same name, UNIX-style soft and hard links will
not be preserved.

=end original

B<-i> は同じ名前で新しいファイルを作る前に元のファイルをリネームまたは
削除するので、UNIX 形式のソフトリンクやハードリンクは保存されないことに
注意してください。

=begin original

Finally, the B<-i> switch does not impede execution when no
files are given on the command line.  In this case, no backup is made
(the original file cannot, of course, be determined) and processing
proceeds from STDIN to STDOUT as might be expected.

=end original

最後に、B<-i> スイッチは、コマンドラインでファイルが指定されなくても
実行を妨げません。
この場合、バックアップファイルは作成されず(もちろん、元のファイルが
決定できません)、予想通り、STDIN から STDOUT に処理が行われます。

=item B<-I>I<directory>
X<-I> X<@INC>

=begin original

Directories specified by B<-I> are prepended to the search path for
modules (C<@INC>), and also tells the C preprocessor where to search for
include files.  The C preprocessor is invoked with B<-P>; by default it
searches /usr/include and /usr/lib/perl.

=end original

B<-I> で指定されたディレクトリはモジュールの検索パス(C<@INC>)に
加えられ、また C プリプロセッサにインクルードファイルを探す場所を示します。
C プリプロセッサは B<-P> で起動されます。
デフォルトでは /usr/include と /usr/lib/perl を探します。

=item B<-l>[I<octnum>]
X<-l> X<$/> X<$\>

=begin original

enables automatic line-ending processing.  It has two separate
effects.  First, it automatically chomps C<$/> (the input record
separator) when used with B<-n> or B<-p>.  Second, it assigns C<$\>
(the output record separator) to have the value of I<octnum> so
that any print statements will have that separator added back on.
If I<octnum> is omitted, sets C<$\> to the current value of
C<$/>.  For instance, to trim lines to 80 columns:

=end original

自動の行末処理を行なうようにします。
これには、2 つの独立した機能があります。
1 つには、B<-n> や B<-p> を使ったときに、自動的に C<$/>(入力レコード
セパレータ)を chomp します。
2 つめに octnum を C<$\>(出力レコードセパレータ) に代入し、print 文で
セパレータを追加できるようにします。
octnum を指定しなかった場合には、その時点の C<$/> の値をC<$\> に
設定します。
たとえば、行を 80 カラムに切り詰めるには以下のようにします:

    perl -lpe 'substr($_, 80) = ""'

=begin original

Note that the assignment C<$\ = $/> is done when the switch is processed,
so the input record separator can be different than the output record
separator if the B<-l> switch is followed by a B<-0> switch:

=end original

C<$\ = $/> という代入は、B<-l> スイッチが処理されるときに
実行されるときに行なわれますので、B<-l> スイッチの後に
B<-0> スイッチを置くようにすれば、入力レコードセパレータを、
出力レコードセパレータと違うようにもできます:

    gnufind / -print0 | perl -ln0e 'print "found $_" if -p'

=begin original

This sets C<$\> to newline and then sets C<$/> to the null character.

=end original

これはまず、C<$\> に改行 (C<$/> のデフォルト値) を設定し、
それから C<$/> にヌル文字を設定します。

=item B<-m>[B<->]I<module>
X<-m> X<-M>

=item B<-M>[B<->]I<module>

=item B<-M>[B<->]I<'module ...'>

=item B<-[mM]>[B<->]I<module=arg[,arg]...>

=begin original

B<-m>I<module> executes C<use> I<module> C<();> before executing your
program.

=end original

B<-m>I<module> はプログラムの実行前に C<use> I<module> C<();> を
実行します。

=begin original

B<-M>I<module> executes C<use> I<module> C<;> before executing your
program.  You can use quotes to add extra code after the module name,
e.g., C<'-Mmodule qw(foo bar)'>.

=end original

B<-M>I<module> はプログラムの実行前に C<use> I<module> C<;> を実行します。
モジュール名の後ろに追加のコードを加えるためにクォートを使うこともできます。
つまり C<'-Mmodule qw(foo bar)'> などです。

=begin original

If the first character after the B<-M> or B<-m> is a dash (C<->)
then the 'use' is replaced with 'no'.

=end original

B<-M> または B<-m> の後の最初の文字がダッシュ(C<->)の場合、
'use' の代わりに 'no' が使われます。

=begin original

A little builtin syntactic sugar means you can also say
B<-mmodule=foo,bar> or B<-Mmodule=foo,bar> as a shortcut for
C<'-Mmodule qw(foo bar)'>.  This avoids the need to use quotes when
importing symbols.  The actual code generated by B<-Mmodule=foo,bar> is
C<use module split(/,/,q{foo,bar})>.  Note that the C<=> form
removes the distinction between B<-m> and B<-M>.

=end original

小さい組み込みの文法的シュガーとして、 C<'-Mmodule qw(foo bar)'> の
代わりに B<-mmodule=foo,bar> または B<-Mmodule=foo,bar> と
書くことができます。
これで、インポートするシンボルにクォートを使わなくてもよいようになります。
B<-Mmodule=foo,bar> で生成される実際のコードは
C<use module split(/,/,q{foo,bar})> です。
C<=> の形は B<-m> と B<-M> の間の違いを取り除くことに注意してください。

=begin original

A consequence of this is that B<-MFoo=number> never does a version check
(unless C<Foo::import()> itself is set up to do a version check, which
could happen for example if Foo inherits from Exporter.)

=end original

この結果、(例えば Foo が Exporter を継承していたりして、
C<Foo::import()> 自身がバージョンチェックを行うように設定されていない限り)
B<-MFoo=number> は決してバージョンチェックは行いません。

=item B<-n>
X<-n>

=begin original

causes Perl to assume the following loop around your program, which
makes it iterate over filename arguments somewhat like B<sed -n> or
B<awk>:

=end original

以下のようなループが、実際のプログラムの回りにあるかのように Perl に
指示します。
B<sed -n> や B<awk> のようにファイル名引数上で繰り返しを
行なうことになります:

  LINE:
    while (<>) {
	...		# your program goes here
    }

=begin original

Note that the lines are not printed by default.  See B<-p> to have
lines printed.  If a file named by an argument cannot be opened for
some reason, Perl warns you about it and moves on to the next file.

=end original

デフォルトでは、各行が印字されることはありません。
各行の印字を行なうには B<-p> を参照してください。
引数で指定されたファイルがなんらかの理由でオープンできなかった場合、
Perl は警告を出して次のファイルに移ります。

=begin original

Here is an efficient way to delete all files that haven't been modified for
at least a week:

=end original

以下にあげるのは、少なくとも 1 週間以上更新されていないァイルを効率的に
削除するものです:

    find . -mtime +7 -print | perl -nle unlink

=begin original

This is faster than using the B<-exec> switch of B<find> because you don't
have to start a process on every filename found.  It does suffer from
the bug of mishandling newlines in pathnames, which you can fix if
you follow the example under B<-0>.

=end original

これは、ファイル名が見つかるごとにプロセスを起動しなくて済みますので、
B<find> の B<-exec> スイッチを使うよりも速くなります。
これはパス名に改行コードがあるとうまく扱えないバグの影響を受けますので、
B<-O> の例に従うことで修正できます。

=begin original

C<BEGIN> and C<END> blocks may be used to capture control before or after
the implicit program loop, just as in B<awk>.

=end original

B<awk> と同じように、暗黙に実行されるプログラムループの前後に実行される
コードを指定するために、C<BEGIN> ブロックと C<END> ブロックを
使うことができます。

=item B<-p>
X<-p>

=begin original

causes Perl to assume the following loop around your program, which
makes it iterate over filename arguments somewhat like B<sed>:

=end original

以下のようなループが、実際のプログラムの回りにあるかのように
Perl に指示します。
B<sed> のようにファイル名引数上で繰り返しを行なうことになります:


  LINE:
    while (<>) {
	...		# your program goes here
    } continue {
	print or die "-p destination: $!\n";
    }

=begin original

If a file named by an argument cannot be opened for some reason, Perl
warns you about it, and moves on to the next file.  Note that the
lines are printed automatically.  An error occurring during printing is
treated as fatal.  To suppress printing use the B<-n> switch.  A B<-p>
overrides a B<-n> switch.

=end original

引数で指定されたファイルが何らかの理由でオープンできない場合、
Perl は警告を出し、次のファイルに移ります。
各行は、自動的に印字されることになります。
印字中のエラーは致命的とみなされます。
印字を抑制するには、B<-n> スイッチを使ってください。
B<-p> は B<-n> スイッチを無効にします。

=begin original

C<BEGIN> and C<END> blocks may be used to capture control before or after
the implicit loop, just as in B<awk>.

=end original

B<awk> と同じように、暗黙に実行されるループの前後に実行されるコードを
指定するために、C<BEGIN> ブロックと C<END> ブロックを使うことができます。

=item B<-P>
X<-P>

=begin original

B<NOTE: Use of -P is strongly discouraged because of its inherent
problems, including poor portability. It is deprecated and will be
removed in a future version of Perl.>

=end original

B<注意: -P の使用は全く薦められません。
なぜなら低い移植性を含む、先天的な問題があるからです。
これは非推奨であり、将来のバージョンの Perl では取り除かれます。>

=begin original

This option causes your program to be run through the C preprocessor before
compilation by Perl.  Because both comments and B<cpp> directives begin
with the # character, you should avoid starting comments with any words
recognized by the C preprocessor such as C<"if">, C<"else">, or C<"define">.

=end original

Perl によるコンパイルを行なう前に、スクリプトを C プリプロセッサに
かけるようにします。
コメントも cpp のディレクティブも # で始まりますから、コメントの最初を
C プリプロセッサが認識してしまう C<"if">, C<"else">, C<"define">といった
単語で始めるべきではありません。

=begin original

If you're considering using C<-P>, you might also want to look at the
Filter::cpp module from CPAN.

=end original

C<-P> を使うことを考えているなら、CPAN にある Filter::cpp も
参照したほうがよいでしょう。

=begin original

The problems of -P include, but are not limited to:

=end original

-P が持つ問題は以下のようなものがあります(これだけではありません):

=over 10

=item *

=begin original

The C<#!> line is stripped, so any switches there don't apply.

=end original

C<#!> 行が取り除かれるので、全てのスイッチは適用されません。

=item *

=begin original

A C<-P> on a C<#!> line doesn't work.

=end original

C<#!> 行に C<-P> を書いても動作しません。

=item *

=begin original

B<All> lines that begin with (whitespace and) a C<#> but
do not look like cpp commands, are stripped, including anything
inside Perl strings, regular expressions, and here-docs .

=end original

(空白と) C<#> で始まり、cpp コマンドでない B<全ての> 行は取り除かれます。
Perl 文字列や正規表現やヒヤドキュメントのと途中でも、です。

=item *

=begin original

In some platforms the C preprocessor knows too much: it knows about
the C++ -style until-end-of-line comments starting with C<"//">.
This will cause problems with common Perl constructs like

=end original

また、C プロセッサが知りすぎているプラットフォームもあります。
C++ スタイルの C<"//"> という「行末までのコメント」を知っている場合です。
この場合、以下のような良くある Perl の構造で問題が起こり得ます:

    s/foo//;

=begin original

because after -P this will became illegal code

=end original

なぜなら -P 適用後以下のような不正なコードになるからです。

    s/foo

=begin original

The workaround is to use some other quoting separator than C<"/">,
like for example C<"!">:

=end original

回避策としては、クオート文字を C<"/"> 以外にする方法があります。
以下では C<"!"> にしています:

    s!foo!!;

=item *

=begin original

It requires not only a working C preprocessor but also a working
F<sed>.  If not on UNIX, you are probably out of luck on this.

=end original

これは C プリプロセッサだけでなく、F<sed> も動作する必要があります。
UNIX でない場合、そのような幸運に恵まれないかもしれません。

=item *

=begin original

Script line numbers are not preserved.

=end original

スクリプトの行番号は保存されません。

=item *

=begin original

The C<-x> does not work with C<-P>.

=end original

C<-x> は C<-P> と同時には動作しません。

=back

=item B<-s>
X<-s>

=begin original

enables rudimentary switch parsing for switches on the command
line after the program name but before any filename arguments (or before
an argument of B<-->).  Any switch found there is removed from @ARGV and sets the
corresponding variable in the Perl program.  The following program
prints "1" if the program is invoked with a B<-xyz> switch, and "abc"
if it is invoked with B<-xyz=abc>.

=end original

コマンドライン上のプログラム名の後から、ファイル名引数
(または引数 B<-->) の前までのスイッチのための、原始的な解析を
行なえるようにします。
ここで見つかったスイッチは、@ARGV から取り除かれ、対応する Perl プログラムの
変数に設定されます。
以下のプログラムは、B<-xyz> というスイッチを付けて実行された時にだけ、
"1" と表示し、B<-xyz=abc> と起動された時に "abc" と表示します。

    #!/usr/bin/perl -s
    if ($xyz) { print "$xyz\n" }

=begin original

Do note that a switch like B<--help> creates the variable ${-help}, which is not compliant
with C<strict refs>.  Also, when using this option on a script with
warnings enabled you may get a lot of spurious "used only once" warnings.

=end original

B<--help> のようなスイッチは変数 ${-help} を作成するので、C<strict refs> を
満たさないことに注意してください。
また、警告を有効にしたスクリプトでこのオプションを使うと、大量の
"used only once" という偽警告がでることになります。

=item B<-S>
X<-S>

=begin original

makes Perl use the PATH environment variable to search for the
program (unless the name of the program contains directory separators).

=end original

Perl がプログラムを探すときに環境変数 PATH を参照するようにします
(プログラム名がディレクトリセパレータを含むときを除きます)。

=begin original

On some platforms, this also makes Perl append suffixes to the
filename while searching for it.  For example, on Win32 platforms,
the ".bat" and ".cmd" suffixes are appended if a lookup for the
original name fails, and if the name does not already end in one
of those suffixes.  If your Perl was compiled with DEBUGGING turned
on, using the -Dp switch to Perl shows how the search progresses.

=end original

プラットフォームによっては、Perl はファイルを探すときに拡張子を
追加します。
例えば Win32 プラットフォームでは、元々のファイル名で検索が失敗した場合、
".bat" と ".cmd" の拡張子が追加されます。
但し既にそのような拡張子がついていない場合だけです。
Perl が DEBUGGING を有効にしてコンパイルされていた場合、-Dp スイッチを
使うことでどのように検索が行われているかを表示させることができます。

=begin original

Typically this is used to emulate #! startup on platforms that don't
support #!.  Its also convenient when debugging a script that uses #!,
and is thus normally found by the shell's $PATH search mechanism.

=end original

これは、#! をサポートしていないプラットフォームで、#! による実行を
エミュレートするために使います。
また、#! を使ったスクリプトで、通常はシェルの $PATH 検索メカニズムで
見つけられるようなスクリプトをデバッグするのにも便利です。

=begin original

This example works on many platforms that have a shell compatible with
Bourne shell:

=end original

この例は Bourne shell 互換のシェルを持つ多くのプラットフォームで動きます:

    #!/usr/bin/perl
    eval 'exec /usr/bin/perl -wS $0 ${1+"$@"}'
	    if $running_under_some_shell;

=begin original

The system ignores the first line and feeds the program to F</bin/sh>,
which proceeds to try to execute the Perl program as a shell script.
The shell executes the second line as a normal shell command, and thus
starts up the Perl interpreter.  On some systems $0 doesn't always
contain the full pathname, so the B<-S> tells Perl to search for the
program if necessary.  After Perl locates the program, it parses the
lines and ignores them because the variable $running_under_some_shell
is never true.  If the program will be interpreted by csh, you will need
to replace C<${1+"$@"}> with C<$*>, even though that doesn't understand
embedded spaces (and such) in the argument list.  To start up sh rather
than csh, some systems may have to replace the #! line with a line
containing just a colon, which will be politely ignored by Perl.  Other
systems can't control that, and need a totally devious construct that
will work under any of B<csh>, B<sh>, or Perl, such as the following:

=end original

システムは、最初の行を無視し、プログラムを F</bin/sh> に渡し、
F</bin/sh> は Perl プログラムをシェルプログラムとして実行しようとします。
シェルは 2 行目を通常のシェルコマンドとして実行し、Perl インタプリタを
起動することになります。
$0 にフルパス名が入っているとは限らないシステムもありますので、
B<-S> が Perl に必要に応じてプログラムを探すように指示します。
Perl がプログラムを見つけると、これらの行の解析を始めますが、
$running_under_some_shell が真になることがないため、
無視することになります。
プログラムが csh で解釈される場合には、たとえファイル名内に埋め込まれた
スペースなどを扱うことができなくても C<${1+"$@"}> を C<$*> で
置き換える必要があるかもしれません。
csh ではなく、sh を起動するように、いくつかのシステムでは、#! の行を
Perl も無視することになっている、コロンだけの行で置き換える必要が
あるかもしれません。
そういった制御が効かないシステムでは、B<csh> でも B<sh> でも
Perl でも使える、回りくどい方法を使うことが必要です:

	eval '(exit $?0)' && eval 'exec perl -wS $0 ${1+"$@"}'
	& eval 'exec /usr/bin/perl -wS $0 $argv:q'
		if $running_under_some_shell;

=begin original

If the filename supplied contains directory separators (i.e., is an
absolute or relative pathname), and if that file is not found,
platforms that append file extensions will do so and try to look
for the file with those extensions added, one by one.

=end original

ファイル名にディレクトリセパレータが含まれていた場合
(つまり絶対パスまたは相対パスだった場合)、そしてそのファイルが
なかった場合、ファイル拡張子を追加するプラットフォームでは
ひとつずつ拡張子を追加して、ファイルを探します。

=begin original

On DOS-like platforms, if the program does not contain directory
separators, it will first be searched for in the current directory
before being searched for on the PATH.  On Unix platforms, the
program will be searched for strictly on the PATH.

=end original

DOS 風のプラットフォームでは、プログラムにディレクトリセパレータが
含まれていなかった場合、PATH を探す前に最初にカレントディレクトリを
探します。
Unix プラットフォームでは、プログラムは厳密に PATH からのみ探されます。

=item B<-t>
X<-t>

=begin original

Like B<-T>, but taint checks will issue warnings rather than fatal
errors.  These warnings can be controlled normally with C<no warnings
qw(taint)>.

=end original

B<-T> と同様ですが、汚染チェックは致命的エラーではなく警告を発生させます。
この警告は通常通り C<no warnings qw(taint)> で制御できます。

=begin original

B<NOTE: this is not a substitute for -T.> This is meant only to be
used as a temporary development aid while securing legacy code:
for real production code and for new secure code written from scratch
always use the real B<-T>.

=end original

B<注意: これは -T の代用品ではありません。>
これは昔のコードを安全にするのを助けるために一時的に使用されるためだけの
ものです:
本当の製品版コードと最初から書く安全なコードのためには常に本当の
B<-T> を使ってください。

=item B<-T>
X<-T>

=begin original

forces "taint" checks to be turned on so you can test them.  Ordinarily
these checks are done only when running setuid or setgid.  It's a
good idea to turn them on explicitly for programs that run on behalf
of someone else whom you might not necessarily trust, such as CGI
programs or any internet servers you might write in Perl.  See
L<perlsec> for details.  For security reasons, this option must be
seen by Perl quite early; usually this means it must appear early
on the command line or in the #! line for systems which support
that construct.

=end original

「汚染」チェックをオンにして、テストできるようにします。
通常、このチェックは setuid や setgid のスクリプトを実行するときにだけ、
行なわれます。
CGI プログラムやインターネットサーバーを Perl で書くときのように、
信用できるとは限らない人が動かすようなプログラムではこれを明示的に
有効にするのはいい考えです。
詳細については L<perlsec> を参照してください。
セキュリティ上の理由から、このオプションは Perl にかなり早く
渡さなければなりません。
これは通常コマンドラインの最初の方につけるか、#! 構造に対応する
システムではここに書くかです。

=item B<-u>
X<-u>

=begin original

This obsolete switch causes Perl to dump core after compiling your
program.  You can then in theory take this core dump and turn it
into an executable file by using the B<undump> program (not supplied).
This speeds startup at the expense of some disk space (which you
can minimize by stripping the executable).  (Still, a "hello world"
executable comes out to about 200K on my machine.)  If you want to
execute a portion of your program before dumping, use the dump()
operator instead.  Note: availability of B<undump> is platform
specific and may not be available for a specific port of Perl.

=end original

この古いスイッチはプログラムのコンパイル後、コアダンプを
行なうようにします。
理論的には、このコアダンプを持ってきて(Perl の配布では提供されていませんが)
B<undump> プログラムを使って、実行ファイルに変換することができます。
これは多少ディスク容量を食いますが (実行ファイルを sprit することで
少しは減ります)、実行開始を速くすることができます。
(減らしても、"hello world" の実行ファイルは、私のマシンで 200K 程に
なります。)
ダンプする前に部分的にプログラムを実行しておきたい場合には、
このスイッチの代わりに dump() 演算子を使ってください。
注意:B<undump> が実行できるのは特定の環境下ですし、
これが使えない移植バージョンの Perl もあるでしょう。

=item B<-U>
X<-U>

=begin original

allows Perl to do unsafe operations.  Currently the only "unsafe"
operations are attempting to unlink directories while running as 
superuser, and running setuid programs with fatal taint checks turned
into warnings.  Note that the B<-w> switch (or the C<$^W> variable) 
must be used along with this option to actually I<generate> the
taint-check warnings.  

=end original

Perl に安全でない操作を許可します。
現在のところ、「安全でない」操作には、スーパーユーザとして実行中に
ディレクトリを削除しようとすることと、致命的な汚染チェックを警告に替えて、
setuid プログラムを実行することです。
B<-w> スイッチ(あるいは C<$^W> 変数)は汚染チェックの警告が実際に
I<生成される> ためにこのオプションと共に使われなければなりません。

=item B<-v>
X<-v>

=begin original

prints the version and patchlevel of your perl executable.

=end original

Perl 実行ファイルのバージョンとパッチレベルを表示します。

=item B<-V>
X<-V>

=begin original

prints summary of the major perl configuration values and the current
values of @INC.

=end original

Perl の主な設定値と @INC の現在の値を表示します。

=item B<-V:>I<configvar>

=begin original

Prints to STDOUT the value of the named configuration variable(s),
with multiples when your configvar argument looks like a regex (has
non-letters).  For example:

=end original

指定された設定変数の値を STDOUT に表示します;
configvar 引数が正規表現のように見えるもの(英字以外を含んでいる)の場合は
複数表示します。
例えば:

    $ perl -V:libc
	libc='/lib/libc-2.2.4.so';
    $ perl -V:lib.
	libs='-lnsl -lgdbm -ldb -ldl -lm -lcrypt -lutil -lc';
	libc='/lib/libc-2.2.4.so';
    $ perl -V:lib.*
	libpth='/usr/local/lib /lib /usr/lib';
	libs='-lnsl -lgdbm -ldb -ldl -lm -lcrypt -lutil -lc';
	lib_ext='.a';
	libc='/lib/libc-2.2.4.so';
	libperl='libperl.a';
	....

=begin original

Additionally, extra colons can be used to control formatting.  A
trailing colon suppresses the linefeed and terminator ';', allowing
you to embed queries into shell commands.  (mnemonic: PATH separator
':'.)

=end original

さらに、追加のコロンはフォーマットの制御に使います。
末尾のコロンは改行と終端子 ';' を抑制し、シェルコマンド中にクエリを
組み込めるようにします。
(記憶法: PATH セパレータ ':'。)

    $ echo "compression-vars: " `perl -V:z.*: ` " are here !"
    compression-vars:  zcat='' zip='zip'  are here !

=begin original

A leading colon removes the 'name=' part of the response, this allows
you to map to the name you need.  (mnemonic: empty label)

=end original

先頭のコロンはレスポンスの 'name=' の部分を削除し、必要な名前に
マッピングできるようにします。
(記憶法: 空ラベル)

    $ echo "goodvfork="`./perl -Ilib -V::usevfork`
    goodvfork=false;

=begin original

Leading and trailing colons can be used together if you need
positional parameter values without the names.  Note that in the case
below, the PERL_API params are returned in alphabetical order.

=end original

もし位置パラメータの値を名前なしで必要なら、先頭のコロンと末尾のコロンを
両方使えます。
以下の場合、PERL_API パラメータはアルファベット順に返されることに
注意してください。

    $ echo building_on `perl -V::osname: -V::PERL_API_.*:` now
    building_on 'linux' '5' '1' '9' now

=item B<-w>
X<-w>

=begin original

prints warnings about dubious constructs, such as variable names
that are mentioned only once and scalar variables that are used
before being set, redefined subroutines, references to undefined
filehandles or filehandles opened read-only that you are attempting
to write on, values used as a number that don't look like numbers,
using an array as though it were a scalar, if your subroutines
recurse more than 100 deep, and innumerable other things.

=end original

1 度しか使われない変数名、設定される前に使われている変数、サブルーチンの
再定義、未定義のファイルハンドルの参照や、読み込み専用でオープンした
ファイルハンドルへの書き込み、数値に見えない値を数値として使った場合、
配列をスカラであるかのように使った場合、100 段階以上のサブルーティンの再帰、
その他たくさんの疑わしい事に警告を出します。

=begin original

This switch really just enables the internal C<$^W> variable.  You
can disable or promote into fatal errors specific warnings using
C<__WARN__> hooks, as described in L<perlvar> and L<perlfunc/warn>.
See also L<perldiag> and L<perltrap>.  A new, fine-grained warning
facility is also available if you want to manipulate entire classes
of warnings; see L<warnings> or L<perllexwarn>.

=end original

このスイッチは実際には内部の C<$^W> 変数を有効にするだけです。
C<__WARN__> フックを使って特定の警告を無効にしたり致命的エラーに
したりできます。
これについては L<perlvar> と L<perlfunc/warn> を参照して下さい。
L<perldiag> と L<perltrap> も参照して下さい。
もし警告のクラス全体を操作したいなら、新しく粒度の細かい
警告機能もあります。
L<warnings> や L<perllexwarn> を参照して下さい。

=item B<-W>
X<-W>

=begin original

Enables all warnings regardless of C<no warnings> or C<$^W>.
See L<perllexwarn>.

=end original

C<no warnings> や C<$^W> の設定に関わらず全ての警告を有効にします。
L<perllexwarn> を参照して下さい。

=item B<-X>
X<-X>

=begin original

Disables all warnings regardless of C<use warnings> or C<$^W>.
See L<perllexwarn>.

=end original

C<use warnings> や C<$^W> の設定に関わらず全ての警告を無効にします。
L<perllexwarn> を参照して下さい。

=item B<-x>
X<-x>

=item B<-x>I<directory>

=begin original

tells Perl that the program is embedded in a larger chunk of unrelated
ASCII text, such as in a mail message.  Leading garbage will be
discarded until the first line that starts with #! and contains the
string "perl".  Any meaningful switches on that line will be applied.
If a directory name is specified, Perl will switch to that directory
before running the program.  The B<-x> switch controls only the
disposal of leading garbage.  The program must be terminated with
C<__END__> if there is trailing garbage to be ignored (the program
can process any or all of the trailing garbage via the DATA filehandle
if desired).

=end original

メールのような大きな無関係のASCII テキストのかたまりの中にプログラムが
埋め込まれている事を Perl に伝えます。
最初の #! で始まり、"perl" という文字列を含む行までの、先行するゴミは
捨てられます。
その行にある意味を持つスイッチは適用されます。
directory が指定されると、Perl はプログラムの実行前に、そのディレクトリに
移ります。
C<-x> スイッチは先行するゴミの処分を制御するだけです。
プログラムの後に無視すべきゴミがある場合には、C<__END__> でプログラムを
終了する必要があります (その、後に続くゴミの一部または全部は、必要に応じて
DATA ファイルハンドルを通して、そのプログラムで処理する事ができます)。

=begin original

The directory, if specified, must appear immediately following the B<-x>
with no intervening whitespace.

=end original

ディレクトリが指定される場合は、これは B<-x> の直後、空白なしに
引き続かなければなりません。

=back

=head1 ENVIRONMENT
X<perl, environment variables>

(環境変数)

=over 12

=item HOME
X<HOME>

=begin original

Used if chdir has no argument.

=end original

chdir の引数がないときに使われます。

=item LOGDIR
X<LOGDIR>

=begin original

Used if chdir has no argument and HOME is not set.

=end original

chdir の引数がなく、HOME がセットされていないときに使われます。

=item PATH
X<PATH>

=begin original

Used in executing subprocesses, and in finding the program if B<-S> is
used.

=end original

サブプロセスを実行するときと、B<-S> が指定されたときにプログラムを
探すのに使われます。

=item PERL5LIB
X<PERL5LIB>

=begin original

A list of directories in which to look for Perl library
files before looking in the standard library and the current
directory.  Any architecture-specific directories under the specified
locations are automatically included if they exist (this lookup
being done at interpreter startup time.)

=end original

Perl のライブラリファイルを探すときに標準ライブラリディレクトリと
カレントディレクトリを探す前に探すディレクトリのリストです。
特定の場所におけるアーキテクチャ依存のディレクトリは、もしあれば自動的に
追加されます(この検索はインタプリタ起動時に行われます)。

=begin original

If PERL5LIB is not defined, PERLLIB is used.  Directories are separated
(like in PATH) by a colon on unixish platforms and by a semicolon on
Windows (the proper path separator being given by the command C<perl
-V:path_sep>).

=end original

PERL5LIB が定義されていなければ、PERLLIB が使われます。
ディレクトリは(PATH と同様に)unix 風のプラットフォームではコロンで区切られ、
Windows ではセミコロンで区切られます(適切なパス区切り文字は
C<perl -V:path_sep> コマンドでわかります)。

=begin original

When running taint checks (either because the program was running setuid
or setgid, or the B<-T> or B<-t> switch was specified), neither variable
is used. The program should instead say:

=end original

(プログラムが setuid または setgid で実行されているか、B<-T> か B<-t> の
スイッチが指定されて)汚染チェック付きで動作している場合、どちらの環境変数も
使われません。
代わりにプログラム中で以下のようにするべきです:

    use lib "/my/directory";

=item PERL5OPT
X<PERL5OPT>

=begin original

Command-line options (switches).  Switches in this variable are taken
as if they were on every Perl command line.  Only the B<-[CDIMUdmtw]>
switches are allowed.  When running taint checks (because the program
was running setuid or setgid, or the B<-T> switch was used), this
variable is ignored.  If PERL5OPT begins with B<-T>, tainting will be
enabled, and any subsequent options ignored.

=end original

コマンドラインオプション(スイッチ)です。
この変数のスイッチは全ての Perl コマンドラインで指定されたかのように
扱われます。
B<-[CDIMUdmtw]> オプションのみが有効です。
(プログラムが setuid または setgid で実行されているか、B<-T> スイッチが
指定されて)汚染チェック付きで動作している場合、この変数は無視されます。
PERL5OPT が B<-T> で始まっている場合、汚染チェックが有効となり、残りの
オプションは無視されます。

=item PERLIO
X<PERLIO>

=begin original

A space (or colon) separated list of PerlIO layers. If perl is built
to use PerlIO system for IO (the default) these layers effect perl's IO.

=end original

空白(またはコロン)で区切られた PerlIO 層のリストです。
perl が IO に PerlIO システムを使うようにコンパイルされている場合
(これがデフォルトです)、これらの層が perl の IO に影響を与えます。

=begin original

It is conventional to start layer names with a colon e.g. C<:perlio> to
emphasise their similarity to variable "attributes". But the code that parses
layer specification strings (which is also used to decode the PERLIO
environment variable) treats the colon as a separator.

=end original

変数"属性"との類似性を強調するために層名を C<:perlio> のようにコロンで
始める慣習があります。
しかしプログラムは層を定義する文字列のパースする
(PERLIO 環境変数のデコードにも使われます)ときにコロンをセパレータとして
扱います。

=begin original

An unset or empty PERLIO is equivalent to the default set of layers for
your platform, for example C<:unix:perlio> on UNIX-like systems
and C<:unix:crlf> on Windows and other DOS-like systems.

=end original

PERLIO をセットしない、または空文字列をセットすると、プラットフォームの
デフォルトの層の組み合わせと等価です; 
例えば、UNIX 風のシステムでは C<:unix:perlio> で、Windows やその他の
DOS 風のシステムは C<:unix:crlf> です。

=begin original

The list becomes the default for I<all> perl's IO. Consequently only built-in
layers can appear in this list, as external layers (such as :encoding()) need
IO in  order to load them!. See L<"open pragma"|open> for how to add external
encodings as defaults.

=end original

このリストは I<全ての> perl の IO のデフォルトとなります。
従って組み込みの層のみがこのリストに記述可能です。
なぜなら(:encoding() のような)外部読み込みの層はロードするために
IO が必要だからです。
デフォルトとして外部エンコーディングを追加する方法については
L<"open pragma"|open> を参照してください。

=begin original

The layers that it makes sense to include in the PERLIO environment
variable are briefly summarised below. For more details see L<PerlIO>.

=end original

PERLIO 環境変数に加えることが妥当な層の簡単な一覧を以下に示します。
詳細については L<PerlIO> を参照してください。

=over 8

=item :bytes
X<:bytes>

=begin original

A pseudolayer that turns I<off> the C<:utf8> flag for the layer below.
Unlikely to be useful on its own in the global PERLIO environment variable.
You perhaps were thinking of C<:crlf:bytes> or C<:perlio:bytes>.

=end original

以下に示す C<:utf8> フラグを I<無効にする> ための擬似層です。
グローバルな PERLIO 環境変数にこれを含めるのが有用な場合は
ありそうもないです。
おそらく C<:crlf:bytes> か C<:perlio:bytes> のことを考えているのでしょう。

=item :crlf
X<:crlf>

=begin original

A layer which does CRLF to "\n" translation distinguishing "text" and
"binary" files in the manner of MS-DOS and similar operating systems.
(It currently does I<not> mimic MS-DOS as far as treating of Control-Z
as being an end-of-file marker.)

=end original

"テキスト"と"バイナリ"ファイルを識別する CRLF から "\n" への変換を
MS-DOS 及び似たようなオペレーティングシステムの方式で行う層です。
(現在のところ Control-Z をファイルの終わりと見なすところまで MS-DOS を
まねてはいません。)

=item :mmap
X<:mmap>

=begin original

A layer which implements "reading" of files by using C<mmap()> to
make (whole) file appear in the process's address space, and then
using that as PerlIO's "buffer".

=end original

ファイルの"読み込み"に C<mmap()> を使ってファイル(全体)をプロセスの
アドレス空間に割り当て、それを PerlIO の"バッファ"として使うための層です。

=item :perlio
X<:perlio>

=begin original

This is a re-implementation of "stdio-like" buffering written as a
PerlIO "layer".  As such it will call whatever layer is below it for
its operations (typically C<:unix>).

=end original

これは"stdio風"のバッファリングを PerlIO "層" として再実装したものです。
従ってどのような層からも操作時に呼び出されます(典型的には C<:unix>)。

=item :pop
X<:pop>

=begin original

An experimental pseudolayer that removes the topmost layer.
Use with the same care as is reserved for nitroglycerin.

=end original

先頭の層を除去するための実験的な擬似層です。
ニトログリセリンに対するのと同様の慎重さを持って使ってください。

=item :raw
X<:raw>

=begin original

A pseudolayer that manipulates other layers.  Applying the C<:raw>
layer is equivalent to calling C<binmode($fh)>.  It makes the stream
pass each byte as-is without any translation.  In particular CRLF
translation, and/or :utf8 intuited from locale are disabled.

=end original

他の層を操作するための擬似層です。
 C<:raw> 層を適用することは C<binmode($fh)> を呼び出すのと等価です。
これはストリームの各バイトを何の変換もなしに通過させます。
特に CRLF 変換やロケールからの :utf8 が無効になります。

=begin original

Unlike in the earlier versions of Perl C<:raw> is I<not>
just the inverse of C<:crlf> - other layers which would affect the
binary nature of the stream are also removed or disabled.

=end original

昔のバージョンの Perl と異なり、C<:raw> は C<:crlf> の逆
I<ではありません> - ストリームのバイナリの性質に影響を与える
その他の層も除去されるか無効になります。

=item :stdio
X<:stdio>

=begin original

This layer provides PerlIO interface by wrapping system's ANSI C "stdio"
library calls. The layer provides both buffering and IO.
Note that C<:stdio> layer does I<not> do CRLF translation even if that
is platforms normal behaviour. You will need a C<:crlf> layer above it
to do that.

=end original

この層はシステムの ANSI C "stdio" ライブラリコールをラップした
PerlIO インターフェースを提供します。
この層はバッファリングと IO の両方を提供します。
C<:stdio> 層は CRLF 変換を I<行わない> ことに注意してください。
たとえそれがプラットフォームの通常の振る舞いであっても、です。
これを行うためには C<:crlf> 層が必要です。

=item :unix
X<:unix>

=begin original

Low level layer which calls C<read>, C<write> and C<lseek> etc.

=end original

C<read>, C<write>, C<lseek> などを呼び出す低レベル層です。

=item :utf8
X<:utf8>

=begin original

A pseudolayer that turns on a flag on the layer below to tell perl
that output should be in utf8 and that input should be regarded as
already in valid utf8 form. It does not check for validity and as such
should be handled with caution for input. Generally C<:encoding(utf8)> is
the best option when reading UTF-8 encoded data.

=end original

出力が utf8 で、入力は既に妥当な utf8 の形になっていると下位の層に伝える
フラグをオンにする擬似層です。
妥当性についてはチェックされないので、入力については注意して扱うべきです。
一般的に、UTF-8 でエンコードされたデータを読むときには C<:encoding(utf8)> が
最善の選択肢です。

=item :win32
X<:win32>

=begin original

On Win32 platforms this I<experimental> layer uses native "handle" IO
rather than unix-like numeric file descriptor layer. Known to be
buggy in this release.

=end original

Win32 プラットフォームにおいて、この I<実験的> 層は unix 風の数値の
ファイル記述子層の代わりにネイティブな "ハンドル" IO を使用します。
このリリースではバグっぽいことがわかっています。

=back

=begin original

On all platforms the default set of layers should give acceptable results.

=end original

全てのプラットフォームでデフォルトの層の組み合わせは納得できる結果に
なっているはずです。

=begin original

For UNIX platforms that will equivalent of "unix perlio" or "stdio".
Configure is setup to prefer "stdio" implementation if system's library
provides for fast access to the buffer, otherwise it uses the "unix perlio"
implementation.

=end original

UNIX プラットフォームではこれは "unix perlio" または "stdio" と等価です。
configure スクリプトはシステムのライブラリがバッファへの高速アクセス方法を
提供する場合は"stdio"実装を使うよう設定し、そうでなければ"unix perlio"
実装を使います。

=begin original

On Win32 the default in this release is "unix crlf". Win32's "stdio"
has a number of bugs/mis-features for perl IO which are somewhat
C compiler vendor/version dependent. Using our own C<crlf> layer as
the buffer avoids those issues and makes things more uniform.
The C<crlf> layer provides CRLF to/from "\n" conversion as well as
buffering.

=end original

Win32 ではデフォルトは"unix crlf"です。
Win32 の"stdio" は perl IO にとって、C コンパイラのベンダー/バージョン依存の
大量のバグ/仕様漏れがあります。
バッファとして自身の C<crlf> 層を使うことでこれらの問題を回避し、
物事をより一貫したものにします。
C<crlf> 層はバッファリング時に CRLF と "\n" の変換を行います。

=begin original

This release uses C<unix> as the bottom layer on Win32 and so still uses C
compiler's numeric file descriptor routines. There is an experimental native
C<win32> layer which is expected to be enhanced and should eventually be
the default under Win32.

=end original

このリリースでは Win32 での基底層として C<unix> を使うことで、未だに
C コンパイラの数値のファイル記述子ルーチンを使います。
拡張を予定されている実験的なネイティブの C<win32> 層があり、最終的には
これが Win32 でのデフォルトとなる予定です。

=item PERLIO_DEBUG
X<PERLIO_DEBUG>

=begin original

If set to the name of a file or device then certain operations of PerlIO
sub-system will be logged to that file (opened as append). Typical uses
are UNIX:

=end original

ファイルまたはデバイスの名前をセットすると、PerlIO サブシステムのいくつかの
操作がそのファイルに(追記モードで)記録されます。
UNIX での典型的な使い方は以下の通りです:

   PERLIO_DEBUG=/dev/tty perl script ...

=begin original

and Win32 approximate equivalent:

=end original

Win32 では以下がほぼ等価です:

   set PERLIO_DEBUG=CON
   perl script ...

=begin original

This functionality is disabled for setuid scripts and for scripts run
with B<-T>.

=end original

この機能は、setuid されたスクリプトや B<-T> で実行されているスクリプトでは
無効になります。

=item PERLLIB
X<PERLLIB>

=begin original

A list of directories in which to look for Perl library
files before looking in the standard library and the current directory.
If PERL5LIB is defined, PERLLIB is not used.

=end original

Perl ライブラリを探すのに標準ライブラリとカレントディレクトリの前に
検索するディレクトリのリストです。
PERL5LIB が定義されていると、PERLLIB は使われません。

=item PERL5DB
X<PERL5DB>

=begin original

The command used to load the debugger code.  The default is:

=end original

デバッガコードを読み込むのに使われるコマンドです。
デフォルトは以下の通り:

	BEGIN { require 'perl5db.pl' }

=item PERL5DB_THREADED
X<PERL5DB_THREADED>

=begin original

If set to a true value, indicates to the debugger that the code being
debugged uses threads.

=end original

真の値にセットされると、デバッグするコードがスレッドを使うことをデバッガに
示します。

=item PERL5SHELL (specific to the Win32 port)
X<PERL5SHELL>

=begin original

May be set to an alternative shell that perl must use internally for
executing "backtick" commands or system().  Default is C<cmd.exe /x/d/c>
on WindowsNT and C<command.com /c> on Windows95.  The value is considered
to be space-separated.  Precede any character that needs to be protected
(like a space or backslash) with a backslash.

=end original

"バッククォート" コマンドや system() を実行するために Perl が内部的に
使わなければならない代替シェルを指定します。
デフォルトは WindowsNT では C<cmd.exe /x/d/c>、Windows95 では
C<command.com /c> です。
値はスペース区切りと考えられます。
(空白やバックスラッシュのような) 保護する必要がある文字の前には
バックスラッシュがつけられます。

=begin original

Note that Perl doesn't use COMSPEC for this purpose because
COMSPEC has a high degree of variability among users, leading to
portability concerns.  Besides, perl can use a shell that may not be
fit for interactive use, and setting COMSPEC to such a shell may
interfere with the proper functioning of other programs (which usually
look in COMSPEC to find a shell fit for interactive use).

=end original

COMSPEC の値はユーザーによってかなり様々で、移植性の問題を引き起こすので、
Perl はこの目的に COMSPEC は使わないことに注意してください。
さらに、Perl は対話的な用途には向かないシェルも利用できますが、
COMSPEC にそのようなシェルを指定すると他のプログラム
(普通は対話的な用途に適したシェルを探すのに COMSPEC を使います)の適切な
利用を邪魔するかもしれません。

=item PERL_ALLOW_NON_IFS_LSP (specific to the Win32 port)
X<PERL_ALLOW_NON_IFS_LSP>

=begin original

Set to 1 to allow the use of non-IFS compatible LSP's.
Perl normally searches for an IFS-compatible LSP because this is required
for its emulation of Windows sockets as real filehandles.  However, this may
cause problems if you have a firewall such as McAfee Guardian which requires
all applications to use its LSP which is not IFS-compatible, because clearly
Perl will normally avoid using such an LSP.
Setting this environment variable to 1 means that Perl will simply use the
first suitable LSP enumerated in the catalog, which keeps McAfee Guardian
happy (and in that particular case Perl still works too because McAfee
Guardian's LSP actually plays some other games which allow applications
requiring IFS compatibility to work).

=end original

1 にセットすると、IFS 非互換の LSP を使えるようにします。
Perl は普通 IFS 互換の LSP を探します; Windows のソケットを本当の
ファイルハンドルとしてエミュレートするために必要だからです。
しかし、これは全てのアプリケーションが IFS 非互換の自身の LSP を使うことを
求める McAfee Guardian のようなファイアウォールでは問題が起きます;
明らかに、Perl は普通そのような LSP を使うことを避けるからです。
この環境変数を 1 にセットすることで、 Perl は単にカタログに挙げられている
もののうち最初の適切な LSP を使用し、これにより McAfee Guardian は
幸せなままです (そしてこの特定の場合においては、McAfee Guardian の LSP は
実際には動作するために IFS 互換である必要があるアプリケーションのために
小細工をしているので、 Perl も正しく動きます)。

=item PERL_DEBUG_MSTATS
X<PERL_DEBUG_MSTATS>

=begin original

Relevant only if perl is compiled with the malloc included with the perl
distribution (that is, if C<perl -V:d_mymalloc> is 'define').
If set, this causes memory statistics to be dumped after execution.  If set
to an integer greater than one, also causes memory statistics to be dumped
after compilation.

=end original

Perl が Perl 配布パッケージに含まれる malloc ルーチンを使って
コンパイルされている場合(C<perl -V:d_mymalloc> が 'define' の場合)にのみ
有効です。
設定されると、実行後にメモリ状況が表示されます。
1 を超える数値が設定されると、コンパイル後にもメモリ状況を表示します。

=item PERL_DESTRUCT_LEVEL
X<PERL_DESTRUCT_LEVEL>

=begin original

Relevant only if your perl executable was built with B<-DDEBUGGING>,
this controls the behavior of global destruction of objects and other
references.  See L<perlhack/PERL_DESTRUCT_LEVEL> for more information.

=end original

Perl の実行ファイルが B<-DDEBUGGING> 付きで構築された場合にのみ有効です。
このオプションはオブジェクトやその他のリファレンスのグローバルな
デストラクタの振る舞いを制御します。
さらなる情報については L<perlhack/PERL_DESTRUCT_LEVEL> を参照してください。

=item PERL_DL_NONLAZY
X<PERL_DL_NONLAZY>

=begin original

Set to one to have perl resolve B<all> undefined symbols when it loads
a dynamic library.  The default behaviour is to resolve symbols when
they are used.  Setting this variable is useful during testing of
extensions as it ensures that you get an error on misspelled function
names even if the test suite doesn't call it.

=end original

1 にセットすると、 Perl は B<全ての> 未定義シンボルをダイナミック
ライブラリをロードしたときに解決します。
デフォルトの振る舞いは使われるときにシンボルを解決します。
この変数を設定することで、拡張機能のテスト時にたとえテストスイートが
呼び出さなくても関数名のスペルミスによるエラーを確実に受け取ることが
できるので便利です。

=item PERL_ENCODING
X<PERL_ENCODING>

=begin original

If using the C<encoding> pragma without an explicit encoding name, the
PERL_ENCODING environment variable is consulted for an encoding name.

=end original

C<encoding> プラグマを明示的なエンコーディング名を指定せずに使用した場合、
PERL_ENCODING 環境変数がエンコーディング名として使われます。

=item PERL_HASH_SEED
X<PERL_HASH_SEED>

=begin original

(Since Perl 5.8.1.)  Used to randomise perl's internal hash function.
To emulate the pre-5.8.1 behaviour, set to an integer (zero means
exactly the same order as 5.8.0).  "Pre-5.8.1" means, among other
things, that hash keys will always have the same ordering between
different runs of perl.

=end original

(Perl 5.8.1 から) perl の内部ハッシュ関数のランダム化に使われます。
5.8.1 以前の振る舞いをエミュレートするためには、整数を指定します
(ゼロは 5.8.0 と完全に同じ順序を意味します)。
"5.8.1 以前" というのは、その他のことも含めて、Perl を何度実行しても
ハッシュキーの並び順が常に同じであることを意味します。

=begin original

Most hashes return elements in the same order as Perl 5.8.0 by default.
On a hash by hash basis, if pathological data is detected during a hash
key insertion, then that hash will switch to an alternative random hash
seed.

=end original

Perl 5.8.0 ではデフォルトではほとんどのハッシュは同じ順序で要素を返します。
On a hash by hash basis,
ハッシュキー挿入中に異常なデータが検出されると、ハッシュは代替のランダム
ハッシュの種に切り替えます。

=begin original

The default behaviour is to randomise unless the PERL_HASH_SEED is set.
If perl has been compiled with C<-DUSE_HASH_SEED_EXPLICIT>, the default
behaviour is B<not> to randomise unless the PERL_HASH_SEED is set.

=end original

デフォルトの振る舞いは、 PERL_HASH_SEED がセットされない限り
ランダム化されます。
perl が C<-DUSE_HASH_SEED_EXPLICIT> 付きでコンパイルされた場合、
デフォルトの振る舞いは PERL_HASH_SEED がセットされない限り
ランダム化 B<されません>。

=begin original

If PERL_HASH_SEED is unset or set to a non-numeric string, perl uses
the pseudorandom seed supplied by the operating system and libraries.

=end original

PERL_HASH_SEED がセットされないか、数値でない文字列がセットされた場合、
Perl はオペレーティングシステムとライブラリが提供する擬似乱数の
種を使用します。

=begin original

B<Please note that the hash seed is sensitive information>. Hashes are
randomized to protect against local and remote attacks against Perl
code. By manually setting a seed this protection may be partially or
completely lost.

=end original

B<ハッシュの種は微妙な問題であることに注意してください>。
ハッシュは Perl コードに対するローカル・リモート攻撃から守るために
ランダム化されます。
手動で種を設定することによりこの守りは部分的に、あるいは完全に失われます。

=begin original

See L<perlsec/"Algorithmic Complexity Attacks"> and
L</PERL_HASH_SEED_DEBUG> for more information.

=end original

さらなる情報については L<perlsec/"Algorithmic Complexity Attacks"> と
L</PERL_HASH_SEED_DEBUG> を参照してください。

=item PERL_HASH_SEED_DEBUG
X<PERL_HASH_SEED_DEBUG>

=begin original

(Since Perl 5.8.1.)  Set to one to display (to STDERR) the value of
the hash seed at the beginning of execution.  This, combined with
L</PERL_HASH_SEED> is intended to aid in debugging nondeterministic
behavior caused by hash randomization.

=end original

(Perl 5.8.1 から) これを 1 に設定すると、実行開始時にハッシュの種の
値を画面(STDERR)に出力します。
これは L</PERL_HASH_SEED> と組み合わせることでハッシュのランダム化に
よる非決定的な振る舞いのデバッグを助けることを目的としています。

=begin original

B<Note that the hash seed is sensitive information>: by knowing it one
can craft a denial-of-service attack against Perl code, even remotely,
see L<perlsec/"Algorithmic Complexity Attacks"> for more information.
B<Do not disclose the hash seed> to people who don't need to know it.
See also hash_seed() of L<Hash::Util>.

=end original

B<ハッシュの種は微妙な問題であることに注意してください>:
これを知ることで、リモートからでも Perl のコードに対してサービス拒否攻撃を
仕掛けることが出来ます。
さらなる情報については L<perlsec/"Algorithmic Complexity Attacks"> を
参照してください。
知る必要のない人々に対して B<ハッシュの種を公開しないでください>。
L<Hash::Util> の hash_seed() も参照してください。

=item PERL_ROOT (specific to the VMS port)
X<PERL_ROOT>

=begin original

A translation concealed rooted logical name that contains perl and the
logical device for the @INC path on VMS only.  Other logical names that
affect perl on VMS include PERLSHR, PERL_ENV_TABLES, and
SYS$TIMEZONE_DIFFERENTIAL but are optional and discussed further in
L<perlvms> and in F<README.vms> in the Perl source distribution.

=end original

Perl と VMS 専用の @INC のための論理デバイスを含む、
変換が隠されたルートとなる論理名です。
VMS の Perl に影響を与えるその他の論理名としては PERLSHR, PERL_ENV_TABLES,
SYS$TIMEZONE_DIFFERENTIAL がありますが、これらはオプションです。
詳細については Perl ソース配布パッケージの L<perlvms> と F<README.vms> で
議論されています。

=item PERL_SIGNALS
X<PERL_SIGNALS>

=begin original

In Perls 5.8.1 and later.  If set to C<unsafe> the pre-Perl-5.8.0
signals behaviour (immediate but unsafe) is restored.  If set to
C<safe> the safe (or deferred) signals are used.
See L<perlipc/"Deferred Signals (Safe Signals)">.

=end original

Perl 5.8.1 以降で有効です。
これに C<unsafe> をセットすると、Perl 5.8.0 以前のシグナルの振る舞い
(直接的ですが安全ではありません)が復元されます。
C<safe>をセットすると安全な(遅延する)シグナルが使われます。
L<perlipc/"Deferred Signals (Safe Signals)"> を参照してください。

=item PERL_UNICODE
X<PERL_UNICODE>

=begin original

Equivalent to the B<-C> command-line switch.  Note that this is not
a boolean variable-- setting this to C<"1"> is not the right way to
"enable Unicode" (whatever that would mean).  You can use C<"0"> to
"disable Unicode", though (or alternatively unset PERL_UNICODE in
your shell before starting Perl).  See the description of the C<-C>
switch for more information.

=end original

B<-C> コマンドラインスイッチと等価です。
これは真偽値変数ではないことに注意してください -- これを C<"1"> に
セットすることは(どんな意味においても)"Unicode を有効にする"ための
正しい方法ではありません。
しかし、"Unicode を無効にする"ために C<"0"> をセットすることは出来ます
(あるいは Perl の起動前にあなたのお使いのシェルで PERL_UNICODE を
未設定にすることでも出来ます)。
さらなる情報については C<-C> スイッチの説明を参照してください。

=item SYS$LOGIN (specific to the VMS port)
X<SYS$LOGIN>

=begin original

Used if chdir has no argument and HOME and LOGDIR are not set.

=end original

chdir の引数がなく、HOME と LOGDIR がセットされていないときに使われます。

=back

=begin original

Perl also has environment variables that control how Perl handles data
specific to particular natural languages.  See L<perllocale>.

=end original

特定の自然言語に特有のデータを Perl がどのように扱うかを制御する
環境変数もあります。
L<perllocale> を参照して下さい。

=begin original

Apart from these, Perl uses no other environment variables, except
to make them available to the program being executed, and to child
processes.  However, programs running setuid would do well to execute
the following lines before doing anything else, just to keep people
honest:

=end original

これらの他には、実行されているプログラムあるいは子プロセスがが有効に
しない限り、Perl は環境変数を使いません。
しかし、setuid で動作するプログラムは何かをする前に、単に人々に変な気を
起こさせないために以下のコードを入れておくのがよいです。

    $ENV{PATH}  = '/bin:/usr/bin';    # or whatever you need
    $ENV{SHELL} = '/bin/sh' if exists $ENV{SHELL};
    delete @ENV{qw(IFS CDPATH ENV BASH_ENV)};

=begin meta

Translate: 吉村 寿人 <JAE00534@niftyserve.or.jp>
Update: Kentaro Shirakata <argrath@ub32.org>
License: GPL or Artistic

=end meta

