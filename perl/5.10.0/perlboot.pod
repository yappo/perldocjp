
=encoding euc-jp

=head1 NAME

=begin original

perlboot - Beginner's Object-Oriented Tutorial

=end original

perlboot - Perl オブジェクト指向導入編

=head1 DESCRIPTION

=begin original

If you're not familiar with objects from other languages, some of the
other Perl object documentation may be a little daunting, such as
L<perlobj>, a basic reference in using objects, and L<perltoot>, which
introduces readers to the peculiarities of Perl's object system in a
tutorial way.

=end original

他の言語でオブジェクトに親しんでいたのでなければ、
他の Perl オブジェクトのドキュメントのいくつかは気力をくじかせるでしょう。
オブジェクトを使うための基本的なリファレンス L<perlobj>、
Perl のオブジェクトシステムの特性のチュートリアル的な紹介 L<perltoot> 
等のように。

=begin original

So, let's take a different approach, presuming no prior object
experience. It helps if you know about subroutines (L<perlsub>),
references (L<perlref> et. seq.), and packages (L<perlmod>), so become
familiar with those first if you haven't already.

=end original

そこで、別のアプローチをとって、
オブジェクトの経験がないことを前提にしましょう。
もし、サブルーチン(L<perlsub>)や、リファレンス(L<perlref>等)、
パッケージ(L<perlmod>) を知っているのならそれが役に立ちますので、
もしまだわからなければまずそちらを先に知っておくべきでしょう。

=head2 If we could talk to the animals...

(もし動物と会話できたら…)

=begin original

Let's let the animals talk for a moment:

=end original

動物さんたちにちょっとしゃべってもらいましょう。

    sub Cow::speak {
      print "a Cow goes moooo!\n";
    }
    sub Horse::speak {
      print "a Horse goes neigh!\n";
    }
    sub Sheep::speak {
      print "a Sheep goes baaaah!\n";
    }

    Cow::speak;
    Horse::speak;
    Sheep::speak;

=begin original

This results in:

=end original

これは次の結果を得ます:

    a Cow goes moooo!
    a Horse goes neigh!
    a Sheep goes baaaah!

=begin original

Nothing spectacular here.  Simple subroutines, albeit from separate
packages, and called using the full package name.  So let's create
an entire pasture:

=end original

目新しいコトはありません。
別々のパッケージに分かれていて完全なパッケージ名を使って
呼び出していますが、単なるサブルーチンです。
では、牧場を作ってみましょう。

    # Cow::speak, Horse::speak, Sheep::speak as before
    @pasture = qw(Cow Cow Horse Sheep Sheep);
    foreach $animal (@pasture) {
      &{$animal."::speak"};
    }

=begin original

This results in:

=end original

これは次の結果を得ます:

    a Cow goes moooo!
    a Cow goes moooo!
    a Horse goes neigh!
    a Sheep goes baaaah!
    a Sheep goes baaaah!

=begin original

Wow.  That symbolic coderef de-referencing there is pretty nasty.
We're counting on C<no strict subs> mode, certainly not recommended
for larger programs.  And why was that necessary?  Because the name of
the package seems to be inseparable from the name of the subroutine we
want to invoke within that package.

=end original

うわ。
ここにあるシンボリックcoderefのデリファレンスはかなり粗雑です。
C<no strict subs> モードも考えてみると、大きなプログラムには全然向きません。
なぜその様なものが必要とされるのでしょう？
それはパッケージ名を、そのパッケージの呼び出そうとしている
サブルーチンの名前から分離できないからです。
("Cow::speek" というメソッド名が必要だから。)

=begin original

Or is it?

=end original

ではどうしましょう?

=head2 Introducing the method invocation arrow

(メソッド呼び出しの矢印)

=begin original

For now, let's say that C<< Class->method >> invokes subroutine
C<method> in package C<Class>.  (Here, "Class" is used in its
"category" meaning, not its "scholastic" meaning.) That's not
completely accurate, but we'll do this one step at a time.  Now let's
use it like so:

=end original

いまのところ、C<< Class->method >> は C<Class> パッケージの C<method> 
サブルーチンを呼び出すとだけ言っておきましょう。
(ここで "Class" は "カテゴリ" の意味です。
"学級" ではありません。)
完全に厳密ではありませんが、少しずつ進めていきましょう。
これは次のように使います:

    # Cow::speak, Horse::speak, Sheep::speak as before
    Cow->speak;
    Horse->speak;
    Sheep->speak;

=begin original

And once again, this results in:

=end original

そしてこれは次の結果を得ます:

    a Cow goes moooo!
    a Horse goes neigh!
    a Sheep goes baaaah!

=begin original

That's not fun yet.  Same number of characters, all constant, no
variables.  But yet, the parts are separable now.  Watch:

=end original

別におもしろくもありませんね。
同じ文字数ですし全て定数で変数もありません。
でも、今度はパッケージ名を分離できるのです。
次を見てください:

    $a = "Cow";
    $a->speak; # invokes Cow->speak

=begin original

Ahh!  Now that the package name has been parted from the subroutine
name, we can use a variable package name.  And this time, we've got
something that works even when C<use strict refs> is enabled.

=end original

関数名からパッケージ名を分けれるので、
パッケージ名に変数を使うことができるのです!
そして今度は C<use strict refs> が有効であってもちゃんと機能するのです。

=head2 Invoking a barnyard

(裏庭の呼び出し)

=begin original

Let's take that new arrow invocation and put it back in the barnyard
example:

=end original

新しい矢印呼び出しを使って、裏庭の例に戻ってみましょう:

    sub Cow::speak {
      print "a Cow goes moooo!\n";
    }
    sub Horse::speak {
      print "a Horse goes neigh!\n";
    }
    sub Sheep::speak {
      print "a Sheep goes baaaah!\n";
    }

    @pasture = qw(Cow Cow Horse Sheep Sheep);
    foreach $animal (@pasture) {
      $animal->speak;
    }

=begin original

There!  Now we have the animals all talking, and safely at that,
without the use of symbolic coderefs.

=end original

みんなちゃんとしゃべってくれます!
また今度はシンボリック coderef を使っていなくて安全です。

=begin original

But look at all that common code.  Each of the C<speak> routines has a
similar structure: a C<print> operator and a string that contains
common text, except for two of the words.  It'd be nice if we could
factor out the commonality, in case we decide later to change it all
to C<says> instead of C<goes>.

=end original

でも、コードをよく見てみると、各 C<speak> 関数はよく似た構造を持っています。
C<print> 演算子と、2 語を除くと同一のテキストを含んでいるだけです。
共通箇所を分解するのはよいことです;
例えば、後で全ての C<goes> を C<says> に変えることもできるようになります。

=begin original

And we actually have a way of doing that without much fuss, but we
have to hear a bit more about what the method invocation arrow is
actually doing for us.

=end original

また、大騒ぎすることなくそれを行う方法も実際ありますが、
メソッド呼び出しの矢印が何を行ってくれているのかについて
ここで少し知っておかなければなりません。

=head2 The extra parameter of method invocation

(メソッド呼び出しの追加パラメータ)

=begin original

The invocation of:

=end original

メソッド呼び出し:

    Class->method(@args)

=begin original

attempts to invoke subroutine C<Class::method> as:

=end original

は、C<Class::Method> 関数を次のように呼び出そうとします:

    Class::method("Class", @args);

=begin original

(If the subroutine can't be found, "inheritance" kicks in, but we'll
get to that later.)  This means that we get the class name as the
first parameter (the only parameter, if no arguments are given).  So
we can rewrite the C<Sheep> speaking subroutine as:

=end original

(もし関数を見つけることができなかったときには、「継承」が走査されます。
これに関してはあとで説明します。) 
これは最初のパラメータとしてクラス名を得ることを意味します
(もし引数がなければそれがただ1 つのパラメータになります)。 
このことから C<Sheep> のおしゃべり関数を次のように書き改めることが
できます:

    sub Sheep::speak {
      my $class = shift;
      print "a $class goes baaaah!\n";
    }

=begin original

And the other two animals come out similarly:

=end original

また他の動物たちも同様になります:

    sub Cow::speak {
      my $class = shift;
      print "a $class goes moooo!\n";
    }
    sub Horse::speak {
      my $class = shift;
      print "a $class goes neigh!\n";
    }

=begin original

In each case, C<$class> will get the value appropriate for that
subroutine.  But once again, we have a lot of similar structure.  Can
we factor that out even further?  Yes, by calling another method in
the same class.

=end original

それぞれにおいて C<$class> にはその関数の特定の値を得ます。
しかしもう一度考え直してみると、かなりよく似た構造になっています。
さらに分離することはできないでしょうか?
それは同じクラスの別のメソッドを呼ぶことで可能です。

=head2 Calling a second method to simplify things

(簡単に 2 つ目のメソッドを呼び出す)

=begin original

Let's call out from C<speak> to a helper method called C<sound>.
This method provides the constant text for the sound itself.

=end original

C<speak> から補助メソッド C<sound> を呼び出してみましょう。
このメソッドはその鳴き声として固定文字列を提供します。

    { package Cow;
      sub sound { "moooo" }
      sub speak {
	my $class = shift;
	print "a $class goes ", $class->sound, "!\n";
      }
    }

=begin original

Now, when we call C<< Cow->speak >>, we get a C<$class> of C<Cow> in
C<speak>.  This in turn selects the C<< Cow->sound >> method, which
returns C<moooo>.  But how different would this be for the C<Horse>?

=end original

さて、C<< Cow->speak >> を呼び出すと C<speak> では C<$class> として
C<Cow> を得ました。
これをつかって C<moooo> を返す C<< Cow->sound >> メソッドを選択します。
では C<Horse> の時はどこが変わるでしょう。

    { package Horse;
      sub sound { "neigh" }
      sub speak {
	my $class = shift;
	print "a $class goes ", $class->sound, "!\n";
      }
    }

=begin original

Only the name of the package and the specific sound change.  So can we
somehow share the definition for C<speak> between the Cow and the
Horse?  Yes, with inheritance!

=end original

パッケージ名と鳴き声の指定だけが変わりました。
ところで Cow と Horse で C<speak> の定義を共有する方法はないでしょうか?
それが継承です!

=head2 Inheriting the windpipes

(気管を継承する)

=begin original

We'll define a common subroutine package called C<Animal>, with the
definition for C<speak>:

=end original

共通の関数のパッケージとして C<Animal> を作ります;
ここで C<speak> を定義します

    { package Animal;
      sub speak {
	my $class = shift;
	print "a $class goes ", $class->sound, "!\n";
      }
    }

=begin original

Then, for each animal, we say it "inherits" from C<Animal>, along
with the animal-specific sound:

=end original

次に各動物たちに対して、それぞれの鳴き声の定義と一緒に、
C<Animal> から「継承」します:

    { package Cow;
      @ISA = qw(Animal);
      sub sound { "moooo" }
    }

=begin original

Note the added C<@ISA> array.  We'll get to that in a minute.

=end original

ここで、C<@ISA> 配列が加えられていることに注意してください。
少々これについて説明します。

=begin original

But what happens when we invoke C<< Cow->speak >> now?

=end original

ところで、ここで C<< Cow->speak >> を呼び出すとなにが起こるのでしょう?

=begin original

First, Perl constructs the argument list.  In this case, it's just
C<Cow>.  Then Perl looks for C<Cow::speak>.  But that's not there, so
Perl checks for the inheritance array C<@Cow::ISA>.  It's there,
and contains the single name C<Animal>.

=end original

まず、Perl が引数リストを構築します。
今回は単純に C<Cow> だけです。
それから Perl は C<Cow::speak> を探します。
しかしそれはありません。
そのため Perl は継承配列 C<@Cow::ISA> を調べます。
それは存在し、名前を 1 つ C<Animal> を格納しています。

=begin original

Perl next checks for C<speak> inside C<Animal> instead, as in
C<Animal::speak>.  And that's found, so Perl invokes that subroutine
with the already frozen argument list.

=end original

Perl は次に C<Animal> の C<speak> を C<Animal::speak> の様に調べます。
今度は見つかりました。
そこで Perl はこの関数をさっき作っておいた引数リストで呼び出します。

=begin original

Inside the C<Animal::speak> subroutine, C<$class> becomes C<Cow> (the
first argument).  So when we get to the step of invoking
C<< $class->sound >>, it'll be looking for C<< Cow->sound >>, which
gets it on the first try without looking at C<@ISA>.  Success!

=end original

C<Animal::speak> 関数においては、C<$class> は C<Cow> になります
(これが 1 つめの引数です)。
そのため C<< $class->sound >> の呼び出しにおいて C<< Cow->sound >> を
得ます。
最初は C<@ISA> を探すことなく調べます。
そしてこれは成功します。

=head2 A few notes about @ISA

(@ISA に関して追記)

=begin original

This magical C<@ISA> variable (pronounced "is a" not "ice-uh"), has
declared that C<Cow> "is a" C<Animal>.  Note that it's an array,
not a simple single value, because on rare occasions, it makes sense
to have more than one parent class searched for the missing methods.

=end original

この魔法の C<@ISA> 変数 ( "アイサ"ではなく"イズ-ア") は、
C<Cow> が C<Animal> の「一種である(is-a)」と宣言しています。
これが単なる 1 つの値ではなく配列であることに注意してください。
稀ではありますが、メソッドが見つからなかったときに探す親クラスを
1 つ以上もつこともあるためです。

=begin original

If C<Animal> also had an C<@ISA>, then we'd check there too.  The
search is recursive, depth-first, left-to-right in each C<@ISA> by
default (see L<mro> for alternatives).  Typically, each C<@ISA> has
only one element (multiple elements means multiple inheritance and
multiple headaches), so we get a nice tree of inheritance.

=end original

もし C<Animal> も C<@ISA> をもっていたらそれも同様に調べられます。
デフォルトでは、検索は C<@ISA> の中を再帰的に、深さ優先、左から右に
行われます(代替案については L<mro> を参照してください)。
典型的に、各 C<@ISA> がただ１つのみ要素を持っています。
そのため良好な継承ツリーを得ます。
(複数の要素を持っていれば複数の継承、複数の難問を持っています。)

=begin original

When we turn on C<use strict>, we'll get complaints on C<@ISA>, since
it's not a variable containing an explicit package name, nor is it a
lexical ("my") variable.  We can't make it a lexical variable though
(it has to belong to the package to be found by the inheritance mechanism),
so there's a couple of straightforward ways to handle that.

=end original

C<use strict> を有効にしたとき、C<@ISA> は明示的なパッケージ名を
持っていないため、そしてレキシカル変数 ("my") でもないため警告を受けます。
この変数はレキシカル変数にはできません。
(継承メカニズムが探索できるように、パッケージに属していなければなりません。)
これに対処する方法は 2 つあります。

=begin original

The easiest is to just spell the package name out:

=end original

一番簡単な方法はパッケージ名をつけて使うことです:

    @Cow::ISA = qw(Animal);

=begin original

Or allow it as an implicitly named package variable:

=end original

もしくは暗黙に名付けられたパッケージ変数を許可することです:

    package Cow;
    use vars qw(@ISA);
    @ISA = qw(Animal);

=begin original

If you're bringing in the class from outside, via an object-oriented
module, you change:

=end original

もしオブジェクト指向モジュールを通して外部からクラスに持ち込むのなら:

    package Cow;
    use Animal;
    use vars qw(@ISA);
    @ISA = qw(Animal);

=begin original

into just:

=end original

これを次のように変更します:

    package Cow;
    use base qw(Animal);

=begin original

And that's pretty darn compact.

=end original

ずいぶんコンパクトになります。

=head2 Overriding the methods

(メソッドのオーバーライド)

=begin original

Let's add a mouse, which can barely be heard:

=end original

ねずみを追加してみましょう。
その声は微かでしょう。

    # Animal package from before
    { package Mouse;
      @ISA = qw(Animal);
      sub sound { "squeak" }
      sub speak {
        my $class = shift;
	print "a $class goes ", $class->sound, "!\n";
	print "[but you can barely hear it!]\n";
      }
    }

    Mouse->speak;

=begin original

which results in:

=end original

これは次のようになります。

    a Mouse goes squeak!
    [but you can barely hear it!]

=begin original

Here, C<Mouse> has its own speaking routine, so C<< Mouse->speak >>
doesn't immediately invoke C<< Animal->speak >>.  This is known as
"overriding".  In fact, we didn't even need to say that a C<Mouse> was
an C<Animal> at all, since all of the methods needed for C<speak> are
completely defined with C<Mouse>.

=end original

ここでは C<Mouse> は C<< Animal->speak >> を呼ぶのではなく
自分用のおしゃべりルーティン C<< Mouse->speak >> を持っています。
これは、「オーバーライド」と呼ばれています。
事実、C<Mouse> が C<Animal> の一種であるという必要はまったくありません。
おしゃべり(C<speak>)に必要なメソッドは全て C<Mouse> に定義されています。

=begin original

But we've now duplicated some of the code from C<< Animal->speak >>,
and this can once again be a maintenance headache.  So, can we avoid
that?  Can we say somehow that a C<Mouse> does everything any other
C<Animal> does, but add in the extra comment?  Sure!

=end original

しかしそれでもいくらかのコードを C<< Animal->speak >> から写しています。
これはまたメンテナンスの悩みを再現させています。
この悩みを回避することはできないでしょうか?
C<Animal> が行っていることを C<Mouse> でも、少々コメントを追加して
行う方法はないでしょうか？
もちろんあります!

=begin original

First, we can invoke the C<Animal::speak> method directly:

=end original

まず C<Animal::speak> メソッドを直接呼び出してみましょう:

    # Animal package from before
    { package Mouse;
      @ISA = qw(Animal);
      sub sound { "squeak" }
      sub speak {
        my $class = shift;
        Animal::speak($class);
	print "[but you can barely hear it!]\n";
      }
    }

=begin original

Note that we have to include the C<$class> parameter (almost surely
the value of C<"Mouse">) as the first parameter to C<Animal::speak>,
since we've stopped using the method arrow.  Why did we stop?  Well,
if we invoke C<< Animal->speak >> there, the first parameter to the
method will be C<"Animal"> not C<"Mouse">, and when time comes for it
to call for the C<sound>, it won't have the right class to come back
to this package.

=end original

メソッド矢印をやめたために、C<Animal::speak> の 1 つめの引数として 
C<$class> パラメータ(おそらくは C<"Mouse"> という値 )を含めなければ
いけないことに注意してください。
なぜやめてしまったのでしょう?
ええ、もしここで C<< Animal->speak >> と呼び出せば最初のパラメータは
C<"Mouse"> ではなく C<"Animal"> になってしまいます。
そして C<sound> が呼び出されたときに正しくこのクラスに戻ってくることが
できなくなってしまうのです。

=begin original

Invoking C<Animal::speak> directly is a mess, however.  What if
C<Animal::speak> didn't exist before, and was being inherited from a
class mentioned in C<@Animal::ISA>?  Because we are no longer using
the method arrow, we get one and only one chance to hit the right
subroutine.

=end original

しかし C<Animal::speak> を直接呼び出すのはいまいちです。
もし C<Animal::speak> が存在せず、C<@Animal::ISA> に
指定されるクラスから継承していたらどうなるのでしょう?
メソッド矢印をすでに使っていないために正しくサブルーチンを探し当てる
チャンスはこの方法しかなくなってしまっているのです。

=begin original

Also note that the C<Animal> classname is now hardwired into the
subroutine selection.  This is a mess if someone maintains the code,
changing C<@ISA> for C<Mouse> and didn't notice C<Animal> there in
C<speak>.  So, this is probably not the right way to go.

=end original

C<Animal> クラス名が関数の中に書き込まれていることにも注意してください。
もしだれかがコードを修正し、C<speal> のにある C<Animal> に気付かないまま
C<Mouse> の C<@ISA> を書き換えてしまったらまずいことになります。
結局、これは適切な方法ではないのです。

=head2 Starting the search from a different place

(異なる場所から探索を始める)

=begin original

A better solution is to tell Perl to search from a higher place
in the inheritance chain:

=end original

より望ましい解法は Perl に継承ツリーのより高位から探索することを
Perl に伝えることです:

    # same Animal as before
    { package Mouse;
      # same @ISA, &sound as before
      sub speak {
        my $class = shift;
        $class->Animal::speak;
        print "[but you can barely hear it!]\n";
      }
    }

=begin original

Ahh.  This works.  Using this syntax, we start with C<Animal> to find
C<speak>, and use all of C<Animal>'s inheritance chain if not found
immediately.  And yet the first parameter will be C<$class>, so the
found C<speak> method will get C<Mouse> as its first entry, and
eventually work its way back to C<Mouse::sound> for the details.

=end original

これはちゃんと動作します。
この構文を使うことで、C<speak> の探索を C<Animal> から開始することが
できます。
そして C<Animal> に直接見つからなくても C<Animal> の全ての継承連鎖を使う
ことができます。
さらに、1 つめのパラメータは C<$class> になるため、
見つかった C<speak> メソッドでは 1 つめのエントリに C<Mouse> を得て、
ついに C<Mouse::sound> に戻って動作する様になります。

=begin original

But this isn't the best solution.  We still have to keep the C<@ISA>
and the initial search package coordinated.  Worse, if C<Mouse> had
multiple entries in C<@ISA>, we wouldn't necessarily know which one
had actually defined C<speak>.  So, is there an even better way?

=end original

しかしこれはまだ最良の解ではありません。
C<@ISA> と同等の最初の探索パッケージを維持しなければなりません。
さらに悪いことに C<Mouse> が C<@ISA> に複数のエントリを持っていたら
実際に C<speak> を定義しているのがどれなのかわかりません。
もっと良い方法はないでしょうか?

=head2 The SUPER way of doing things

(SUPER 解答)

=begin original

By changing the C<Animal> class to the C<SUPER> class in that
invocation, we get a search of all of our super classes (classes
listed in C<@ISA>) automatically:

=end original

呼び出し時の C<Animal> クラスを C<SUPER> クラスに変えることで
検索を自動的に全ての基底クラス群(C<@ISA> に記述されているクラス群)
に対して行うことができます。

    # same Animal as before
    { package Mouse;
      # same @ISA, &sound as before
      sub speak {
        my $class = shift;
        $class->SUPER::speak;
        print "[but you can barely hear it!]\n";
      }
    }

=begin original

So, C<SUPER::speak> means look in the current package's C<@ISA> for
C<speak>, invoking the first one found. Note that it does I<not> look in
the C<@ISA> of C<$class>.

=end original

つまり、C<SUPER::speak> は現在のパッケージの C<@ISA> から C<speak> を探し、
最初に見つかったものを呼び出します。
これは C<$class> の C<@ISA> は I<見ない> 点に注意してください。

=head2 Where we're at so far...

(現在地点)

=begin original

So far, we've seen the method arrow syntax:

=end original

これまでに見てきたものは、メソッド矢印構文:

  Class->method(@args);

=begin original

or the equivalent:

=end original

その等価な文:

  $a = "Class";
  $a->method(@args);

=begin original

which constructs an argument list of:

=end original

構築される引数リスト:

  ("Class", @args)

=begin original

and attempts to invoke

=end original

呼び出され方

  Class::method("Class", @Args);

=begin original

However, if C<Class::method> is not found, then C<@Class::ISA> is examined
(recursively) to locate a package that does indeed contain C<method>,
and that subroutine is invoked instead.

=end original

しかし、C<Class:method> が見つからなければ C<@Class::ISA> が(再帰的に)
実際 C<method> を含んでいるパッケージを探すために使われます。

=begin original

Using this simple syntax, we have class methods, (multiple)
inheritance, overriding, and extending.  Using just what we've seen so
far, we've been able to factor out common code, and provide a nice way
to reuse implementations with variations.  This is at the core of what
objects provide, but objects also provide instance data, which we
haven't even begun to cover.

=end original

この簡単な構文を使うことでクラスメソッド、(複数の)継承、オーバーライド、
そして拡張を行えるようになりました。
これまでに見てきたもの丈で共通処理を抽出し、様々な実装に再利用する
良好な方法を提供することができます。
これはオブジェクトが提供するものの核心です。
とはいえオブジェクトはこれ以外にもまだ説明していませんが
インスタンスデータも提供します。

=head2 A horse is a horse, of course of course -- or is it?

(馬は馬、もちろん -- ですか？)

=begin original

Let's start with the code for the C<Animal> class
and the C<Horse> class:

=end original

C<Animal> クラスと C<Horse> クラスを書いてみましょう。

  { package Animal;
    sub speak {
      my $class = shift;
      print "a $class goes ", $class->sound, "!\n";
    }
  }
  { package Horse;
    @ISA = qw(Animal);
    sub sound { "neigh" }
  }

=begin original

This lets us invoke C<< Horse->speak >> to ripple upward to
C<Animal::speak>, calling back to C<Horse::sound> to get the specific
sound, and the output of:

=end original

C<< Horse->speak >> を呼び出すことで C<Animal::speak> に渡り、
そこから C<Horse::sound> に鳴き声を作りに戻ります。
結果は次のようになります:

  a Horse goes neigh!

=begin original

But all of our Horse objects would have to be absolutely identical.
If I add a subroutine, all horses automatically share it.  That's
great for making horses the same, but how do we capture the
distinctions about an individual horse?  For example, suppose I want
to give my first horse a name.  There's got to be a way to keep its
name separate from the other horses.

=end original

しかしこのすべての Horse オブジェクトは完全に同一です。
サブルーチンを追加しても、全ての馬が自動的にそれを共有します。
同じ馬を作るが目的ならすばらしいことですが、
個々の馬を識別したい時にはどうすれば良いのでしょうか?
例えば最初の馬に名前を付けたい時にはどうすれば良いのでしょう。
もちろん、それぞれの馬の名前を分離して維持する方法があります。

=begin original

We can do that by drawing a new distinction, called an "instance".
An "instance" is generally created by a class.  In Perl, any reference
can be an instance, so let's start with the simplest reference
that can hold a horse's name: a scalar reference.

=end original

「インスタンス」と呼ばれる新しい区別を使うことでそれを行うことができます。
「インスタンス」 は一般的にクラスに生成されます。
Perl では任意のリファレンスならインスタンスになることができます。
そこでまず単純なリファレンスとして、馬の名前を保持するスカラリファレンス
を使ってみましょう。

  my $name = "Mr. Ed";
  my $talking = \$name;

=begin original

So now C<$talking> is a reference to what will be the instance-specific
data (the name).  The final step in turning this into a real instance
is with a special operator called C<bless>:

=end original

これで C<$talking> はインスタンス指向のデータ(名前)のリファレンスに
なりました。
これを実際のインスタンスにする最後のステップは C<bless> と呼ばれる
特別な操作です。

  bless $talking, Horse;

=begin original

This operator stores information about the package named C<Horse> into
the thing pointed at by the reference.  At this point, we say
C<$talking> is an instance of C<Horse>.  That is, it's a specific
horse.  The reference is otherwise unchanged, and can still be used
with traditional dereferencing operators.

=end original

これはパッケージ名 C<Horse> に関する情報を
リファレンスに指されているものに格納する操作を行います。
これにより、C<$talking> が C<Horse> のインスタンスになったといいます。
これで、個々の馬を識別できます。
リファレンスはそれ以外に変化はありませんし、
伝統的なデリファレンス操作を使うこともできます。

=head2 Invoking an instance method

(インスタンスメソッドの呼び出し)

=begin original

The method arrow can be used on instances, as well as names of
packages (classes).  So, let's get the sound that C<$talking> makes:

=end original

メソッド矢印はパッケージ(クラス)名の時と同じように、
インスタンスに対しても使うことができます。
では、C<$talking> の作り出す音を取り出してみましょう:

  my $noise = $talking->sound;

=begin original

To invoke C<sound>, Perl first notes that C<$talking> is a blessed
reference (and thus an instance).  It then constructs an argument
list, in this case from just C<($talking)>.  (Later we'll see that
arguments will take their place following the instance variable,
just like with classes.)

=end original

C<sound> を呼び出すために、Perl は始めに C<$talking> が
bless されたリファレンス(つまりインスタンス)であることを確認します。
それから引数リストを構成します、
今回は C<($talking)> だけです。
(後ほど、クラスの時と同様にインスタンス変数に続けて引数を置くのも
説明します。)

=begin original

Now for the fun part: Perl takes the class in which the instance was
blessed, in this case C<Horse>, and uses that to locate the subroutine
to invoke the method.  In this case, C<Horse::sound> is found directly
(without using inheritance), yielding the final subroutine invocation:

=end original

さて、ここがおもしろいところです: 
Perl はインスタンスが bless されているクラス、今回は C<Horse> を取り出し、
メソッド呼び出しを行うための関数の場所を特定するためにそれを使います。
今回は、C<Horse::sound> が直接に(継承を使うことなしに)
みつかり、最終的に次の関数呼び出しとなります:

  Horse::sound($talking)

=begin original

Note that the first parameter here is still the instance, not the name
of the class as before.  We'll get C<neigh> as the return value, and
that'll end up as the C<$noise> variable above.

=end original

この最初のパラメータは、先ほどのようなクラス名ではなく
インスタンスのままである点に注意してください。
この結果 C<neigh> を復帰値として受け取り、
これが C<$noise> 変数に代入されます。

=begin original

If Horse::sound had not been found, we'd be wandering up the
C<@Horse::ISA> list to try to find the method in one of the
superclasses, just as for a class method.  The only difference between
a class method and an instance method is whether the first parameter
is an instance (a blessed reference) or a class name (a string).

=end original

もし Horse::sound が見つからなかったときには、
クラスメソッドの時と同じように、スーパークラスの
中でメソッドが見つかるかどうか C<@Horse::ISA> 
リストをたどります。
クラスメソッドとインスタンスメソッドとの違いは
その最初の引数がインスタンス(bless されたリファレンス)
なのかクラス名(文字列)なのかという点だけです。

=head2 Accessing the instance data

(インスタンスのデータへのアクセス)

=begin original

Because we get the instance as the first parameter, we can now access
the instance-specific data.  In this case, let's add a way to get at
the name:

=end original

最初の引数としてインスタンスを得ることができるので、
インスタンス固有のデータにアクセスすることができます。
今回は、名前にアクセスする方法を追加してみましょう:

  { package Horse;
    @ISA = qw(Animal);
    sub sound { "neigh" }
    sub name {
      my $self = shift;
      $$self;
    }
  }

=begin original

Now we call for the name:

=end original

これでその名前を呼ぶことができます:

  print $talking->name, " says ", $talking->sound, "\n";

=begin original

Inside C<Horse::name>, the C<@_> array contains just C<$talking>,
which the C<shift> stores into C<$self>.  (It's traditional to shift
the first parameter off into a variable named C<$self> for instance
methods, so stay with that unless you have strong reasons otherwise.)
Then, C<$self> gets de-referenced as a scalar ref, yielding C<Mr. Ed>,
and we're done with that.  The result is:

=end original

C<Horse::name> の内側では、C<@_> 配列には C<shift> で C<$self> に
代入される C<$talking> のみが含まれています。
(インスタンスメソッドにおいて、その最初のパラメータを C<$self> という名前の
変数に shift して代入するのはお約束なので、ここでは
あまり理由を追い求めないでください。)
それから、C<$self> はスカラリファレンスとして
デリファレンスされ、C<Mr. Ed> が取り出され、
それでおしまいです。
結果は次のようになります:

  Mr. Ed says neigh.

=head2 How to build a horse

(馬の作り方)

=begin original

Of course, if we constructed all of our horses by hand, we'd most
likely make mistakes from time to time.  We're also violating one of
the properties of object-oriented programming, in that the "inside
guts" of a Horse are visible.  That's good if you're a veterinarian,
but not if you just like to own horses.  So, let's let the Horse class
build a new horse:

=end original

もちろん、すべての馬を手で作っていては時々失敗することもあるでしょう。
また馬の「内臓」が外から見えてしまうのはオブジェクト指向
プログラミングの約束事を 1 つ破っています。
もしあなたが獣医であればそれもよいでしょうが、
自分の馬を持ちたいだけであればそうではありません。
なので Horse クラスに新しい馬を作ってもらいましょう:

  { package Horse;
    @ISA = qw(Animal);
    sub sound { "neigh" }
    sub name {
      my $self = shift;
      $$self;
    }
    sub named {
      my $class = shift;
      my $name = shift;
      bless \$name, $class;
    }
  }

=begin original

Now with the new C<named> method, we can build a horse:

=end original

この新しく作った C<named> メソッドで馬を作ることができます:

  my $talking = Horse->named("Mr. Ed");

=begin original

Notice we're back to a class method, so the two arguments to
C<Horse::named> are C<Horse> and C<Mr. Ed>.  The C<bless> operator
not only blesses C<$name>, it also returns the reference to C<$name>,
so that's fine as a return value.  And that's how to build a horse.

=end original

ここで私たちはクラスメソッドに戻っていることに注意してください;
また C<Horse::named> の2つの引数は C<Horse> および
C<Mr. Ed> になります。
C<bless> 演算子は C<$name> を bless するだけでなく、
C<$name> へのリファレンスを返します、それによって
これは適切な復帰値となります。
これが馬の作り方です。

=begin original

We've called the constructor C<named> here, so that it quickly denotes
the constructor's argument as the name for this particular C<Horse>.
You can use different constructors with different names for different
ways of "giving birth" to the object (like maybe recording its
pedigree or date of birth).  However, you'll find that most people
coming to Perl from more limited languages use a single constructor
named C<new>, with various ways of interpreting the arguments to
C<new>.  Either style is fine, as long as you document your particular
way of giving birth to an object.  (And you I<were> going to do that,
right?)

=end original

ここではコンストラクタを C<named> としたので、このコンストラクタの引数が
特定の C<Horse> の名前ということを示しています。
(家系や誕生日を記録するといった)違った方法でオブジェクトに
「命を吹き込む」別のコンストラクタには
また違った名前をつけることができます。
しかし、もっと制限の課せられていた言語から Perl へと来たほとんどの人々は
C<new> という 1 つのコンストラクタに、様々な引数の処理方法を
加えて使います。
どちらの方法でも、オブジェクトを作り出すあなたの特定のやり方をあなたが
ドキュメント化している限りは問題ありません。
(そしてそれを行ってI<きている>、そうですよね?)

=head2 Inheriting the constructor

(コンストラクタの継承)

=begin original

But was there anything specific to C<Horse> in that method?  No.  Therefore,
it's also the same recipe for building anything else that inherited from
C<Animal>, so let's put it there:

=end original

でもこのメソッドに C<Horse> 特有のことってありますか?
答えは No です。
従って、C<Animal> から継承して何かを構築するのと
同じレシピを使うことができます、やってみましょう:

  { package Animal;
    sub speak {
      my $class = shift;
      print "a $class goes ", $class->sound, "!\n";
    }
    sub name {
      my $self = shift;
      $$self;
    }
    sub named {
      my $class = shift;
      my $name = shift;
      bless \$name, $class;
    }
  }
  { package Horse;
    @ISA = qw(Animal);
    sub sound { "neigh" }
  }

=begin original

Ahh, but what happens if we invoke C<speak> on an instance?

=end original

あぁ、でもインスタンスに対して C<speak> を呼び出したら
どうなるのでしょう?

  my $talking = Horse->named("Mr. Ed");
  $talking->speak;

=begin original

We get a debugging value:

=end original

これはデバッグ情報になってしまいます:

  a Horse=SCALAR(0xaca42ac) goes neigh!

=begin original

Why?  Because the C<Animal::speak> routine is expecting a classname as
its first parameter, not an instance.  When the instance is passed in,
we'll end up using a blessed scalar reference as a string, and that
shows up as we saw it just now.

=end original

なぜこうなってしまうのでしょう? 
それは、この C<Animal::speak> ルーチンはその最初の引数には
インスタンスではなくクラス名が来ると思っているからです。
インスタンスが渡されるとブレスされたスカラリファレンスを
文字列として使うことになってしまい、それが先ほどみたものに
なってしまうのです。

=head2 Making a method work with either classes or instances

(メソッドをクラスでもインスタンスでも動作できるようにする)

=begin original

All we need is for a method to detect if it is being called on a class
or called on an instance.  The most straightforward way is with the
C<ref> operator.  This returns a string (the classname) when used on a
blessed reference, and an empty string when used on a string (like a
classname).  Let's modify the C<name> method first to notice the change:

=end original

今必要なことは、クラスに対して呼ばれたのか
それともインスタンスに対して呼ばれたのかを区別する方法です。
一番率直な方法は C<ref> 演算子を使うことです。
これは bless されたリファレンスに対して使うと文字列(クラス名)を返し、
(クラス名のような)文字列に対して使うと空文字列を返します。
ではまず変わったことがわかるように C<name> メソッドを
変更してみましょう。

  sub name {
    my $either = shift;
    ref $either
      ? $$either # it's an instance, return name
      : "an unnamed $either"; # it's a class, return generic
  }

=begin original

Here, the C<?:> operator comes in handy to select either the
dereference or a derived string.  Now we can use this with either an
instance or a class.  Note that I've changed the first parameter
holder to C<$either> to show that this is intended:

=end original

ここで C<?:> 演算子はでリファレンスするか派生された文字列かを
簡単に選択するために使っています。
さてこれでこのメソッドをインスタンスでもクラスでも使えるようにできました。
最初のパラメータを保持する変数の名前を使う意図に合わせて
C<$either> に変更しています:

  my $talking = Horse->named("Mr. Ed");
  print Horse->name, "\n"; # prints "an unnamed Horse\n"
  print $talking->name, "\n"; # prints "Mr Ed.\n"

=begin original

and now we'll fix C<speak> to use this:

=end original

そして C<speak> もこれを使うように直してみましょう:

  sub speak {
    my $either = shift;
    print $either->name, " goes ", $either->sound, "\n";
  }

=begin original

And since C<sound> already worked with either a class or an instance,
we're done!

=end original

そして C<sound> は既にクラスでもインスタンスでも動作する
ようになっているので、これで完了です!

=head2 Adding parameters to a method

(メソッドにパラメータを追加する)

=begin original

Let's train our animals to eat:

=end original

次は私たちの動物に食べることをしつけてみましょう:

  { package Animal;
    sub named {
      my $class = shift;
      my $name = shift;
      bless \$name, $class;
    }
    sub name {
      my $either = shift;
      ref $either
	? $$either # it's an instance, return name
	: "an unnamed $either"; # it's a class, return generic
    }
    sub speak {
      my $either = shift;
      print $either->name, " goes ", $either->sound, "\n";
    }
    sub eat {
      my $either = shift;
      my $food = shift;
      print $either->name, " eats $food.\n";
    }
  }
  { package Horse;
    @ISA = qw(Animal);
    sub sound { "neigh" }
  }
  { package Sheep;
    @ISA = qw(Animal);
    sub sound { "baaaah" }
  }

=begin original

And now try it out:

=end original

そして試してみます:

  my $talking = Horse->named("Mr. Ed");
  $talking->eat("hay");
  Sheep->eat("grass");

=begin original

which prints:

=end original

これは次のように出力します:

  Mr. Ed eats hay.
  an unnamed Sheep eats grass.

=begin original

An instance method with parameters gets invoked with the instance,
and then the list of parameters.  So that first invocation is like:

=end original

パラメータを持ったインスタンスメソッドは、そのインスタンスと
パラメータのリストとともに呼び出されます。
そのため最初の呼び出しは次のようになります:

  Animal::eat($talking, "hay");

=head2 More interesting instances

(もっと面白いインスタンス)

=begin original

What if an instance needs more data?  Most interesting instances are
made of many items, each of which can in turn be a reference or even
another object.  The easiest way to store these is often in a hash.
The keys of the hash serve as the names of parts of the object (often
called "instance variables" or "member variables"), and the
corresponding values are, well, the values.

=end original

インスタンスにもっとデータがほしくなったらどうすればよいでしょう?
たいていの面白いインスタンスはそれぞれがリファレンスや
ほかのオブジェクトだったりする多くの要素で構成されています。
これらを格納する一番簡単な方法はハッシュを使うことです。
ハッシュのキーはオブジェクトの部品(「インスタンス変数」若しくは
「メンバ変数」と呼ばれます)の名前として提供され、
それに対応する値は、まぁ、その値です。

=begin original

But how do we turn the horse into a hash?  Recall that an object was
any blessed reference.  We can just as easily make it a blessed hash
reference as a blessed scalar reference, as long as everything that
looks at the reference is changed accordingly.

=end original

でも馬をハッシュにするにはどうしたらよいでしょう?
オブジェクトはブレスされた任意のリファレンスであるということを
思い出してください。
リファレンスを参照している箇所を適切に修正すれば、bless された
スカラリファレンスと同じように簡単に、それを bless された
ハッシュリファレンスで作ることができます。

=begin original

Let's make a sheep that has a name and a color:

=end original

では羊を名前と色を持つようにしてみましょう:

  my $bad = bless { Name => "Evil", Color => "black" }, Sheep;

=begin original

so C<< $bad->{Name} >> has C<Evil>, and C<< $bad->{Color} >> has
C<black>.  But we want to make C<< $bad->name >> access the name, and
that's now messed up because it's expecting a scalar reference.  Not
to worry, because that's pretty easy to fix up:

=end original

これで C<< $bad->{Name} >> は C<Evil> になり、
C<< $bad->{Color} >> は C<black> になります。
でも C<< $bad->name >> でその名前にアクセスできるようにしたい
ですが、それはスカラリファレンスを前提にしているので台無しにされています。
でも心配しないでください、これはとっても簡単に直ります:

  ## in Animal
  sub name {
    my $either = shift;
    ref $either ?
      $either->{Name} :
      "an unnamed $either";
  }

=begin original

And of course C<named> still builds a scalar sheep, so let's fix that
as well:

=end original

そしてもちろん C<named> はスカラの羊を作っているので
これも同じようになおしましょう。

  ## in Animal
  sub named {
    my $class = shift;
    my $name = shift;
    my $self = { Name => $name, Color => $class->default_color };
    bless $self, $class;
  }

=begin original

What's this C<default_color>?  Well, if C<named> has only the name,
we still need to set a color, so we'll have a class-specific initial color.
For a sheep, we might define it as white:

=end original

この C<default_color> って何でしょう?
C<named> が名前だけで呼ばれても色を設定する必要があります、
そこでクラス毎に初期値となる色を持てるようにしています。
羊には白を定義しておきましょう:

  ## in Sheep
  sub default_color { "white" }

=begin original

And then to keep from having to define one for each additional class,
we'll define a "backstop" method that serves as the "default default",
directly in C<Animal>:

=end original

そして追加したそれぞれのクラスで色を定義する必要がないように、
「デフォルトのデフォルト」を提供する
「安全ネット」メソッドを C<Animal> で直接定義しておきます:

  ## in Animal
  sub default_color { "brown" }

=begin original

Now, because C<name> and C<named> were the only methods that
referenced the "structure" of the object, the rest of the methods can
remain the same, so C<speak> still works as before.

=end original

そして、C<name> と C<named> だけがオブジェクトの「構造」を
参照していたので、残りのメソッドはそのままに
しておくことができます、C<speak> は前のままでそのまま動作します。

=head2 A horse of a different color

(違った色の馬)

=begin original

But having all our horses be brown would be boring.  So let's add a
method or two to get and set the color.

=end original

でも私たちの馬の全部が全部茶色では飽きてしまいます。
なので色を取得/設定するためのメソッドを 1 つか 2 つ作ってみましょう。

  ## in Animal
  sub color {
    $_[0]->{Color}
  }
  sub set_color {
    $_[0]->{Color} = $_[1];
  }

=begin original

Note the alternate way of accessing the arguments: C<$_[0]> is used
in-place, rather than with a C<shift>.  (This saves us a bit of time
for something that may be invoked frequently.)  And now we can fix
that color for Mr. Ed:

=end original

引数にアクセスするための別の方法に関する補足: 
C<$_[0]> は C<shift> の代わりに in-place に
使うことができます。
(これは頻繁に呼び出される箇所で時間を節約することができます。)
さてこれで Mr. Ed の色を変えることができます:

  my $talking = Horse->named("Mr. Ed");
  $talking->set_color("black-and-white");
  print $talking->name, " is colored ", $talking->color, "\n";

=begin original

which results in:

=end original

これは次の結果になります:

  Mr. Ed is colored black-and-white

=head2 Summary

(まとめ)

=begin original

So, now we have class methods, constructors, instance methods,
instance data, and even accessors.  But that's still just the
beginning of what Perl has to offer.  We haven't even begun to talk
about accessors that double as getters and setters, destructors,
indirect object notation, subclasses that add instance data, per-class
data, overloading, "isa" and "can" tests, C<UNIVERSAL> class, and so
on.  That's for the rest of the Perl documentation to cover.
Hopefully, this gets you started, though.

=end original

さて、これまでにクラスメソッド、コンストラクタ、
インスタンスメソッド、インスタンスデータ、そして
アクセッサをも見てきました。
しかしこれらは Perl の提供しているもののまだ始まりにすぎません。
まだゲッター(getter)でありセッター(setter)でもある
アクセッサやデストラクタ、間接オブジェクト表記、
インスタンスデータを追加するサブクラス、クラス毎のデータ、
オーバーロード、"isa" および "can" によるテスト、
C<UNIVERSAL> クラス、等々についてはまだ話し始めてもいません。
これらは他の Perl ドキュメントでカバーされています。
願わくば、これがあなたの一歩となりますように。

=head1 SEE ALSO

=begin original

For more information, see L<perlobj> (for all the gritty details about
Perl objects, now that you've seen the basics), L<perltoot> (the
tutorial for those who already know objects), L<perltooc> (dealing
with class data), L<perlbot> (for some more tricks), and books such as
Damian Conway's excellent I<Object Oriented Perl>.

=end original

もっと詳しい情報は、
L<perlobj> (ここで基礎を見た、Perl オブジェクトに関するすべての強固な詳細)、
L<perltoot> (オブジェクトを知っている人のためのチュートリアル)、
L<perltooc> (クラスデータの取り扱い)、
L<perlbot> (もっとトリッキーなこととか)、
そして Damian Conway の優秀な I<Object Oriented Perl> 等の書籍を
参照してください。

=begin original

Some modules which might prove interesting are Class::Accessor,
Class::Class, Class::Contract, Class::Data::Inheritable,
Class::MethodMaker and Tie::SecureHash

=end original

おもしろさを垣間見れるモジュールとして、
Class::Accessor、Class::Class、Class::Contract,
Class::Data::Inheritable、Class::MethodMaker そして Tie::SecureHash。

=head1 COPYRIGHT

Copyright (c) 1999, 2000 by Randal L. Schwartz and Stonehenge
Consulting Services, Inc.  Permission is hereby granted to distribute
this document intact with the Perl distribution, and in accordance
with the licenses of the Perl distribution; derived documents must
include this copyright notice intact.

Portions of this text have been derived from Perl Training materials
originally appearing in the I<Packages, References, Objects, and
Modules> course taught by instructors for Stonehenge Consulting
Services, Inc. and used with permission.

Portions of this text have been derived from materials originally
appearing in I<Linux Magazine> and used with permission.

=begin meta

Created: 山科 氷魚 (YAMASHINA Hio) <hio@hio.jp>
Updated: Kentaro Shirakata <argrath@ub32.org>

=end meta

