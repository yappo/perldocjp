
=encoding euc-jp

=head1 NAME

=begin original

perlfaq3 - Programming Tools ($Revision: 10127 $)

=end original

perlfaq3 - プログラミングツール ($Revision: 10127 $)

=head1 DESCRIPTION

=begin original

This section of the FAQ answers questions related to programmer tools
and programming support.

=end original

FAQ のこのセクションでは、プログラマーツールやプログラミングサポートに
関する質問に回答しています。

=head2 How do I do (anything)?

(○○をするにはどうすればいいの?)

=begin original

Have you looked at CPAN (see L<perlfaq2>)?  The chances are that
someone has already written a module that can solve your problem.
Have you read the appropriate manpages?  Here's a brief index:

=end original

CPAN (L<perlfaq2> を参照して下さい)はもう見ましたか? 
あなたの問題を解決してくれるような
モジュールを誰かがすでに作っているのを見つけられるかもしれません。
適切なマニュアルページは見ましたか?
簡単なインデックスを挙げておきます:

=begin original

	Basics	        perldata, perlvar, perlsyn, perlop, perlsub
	Execution	perlrun, perldebug
	Functions	perlfunc
	Objects		perlref, perlmod, perlobj, perltie
	Data Structures	perlref, perllol, perldsc
	Modules		perlmod, perlmodlib, perlsub
	Regexes		perlre, perlfunc, perlop, perllocale
	Moving to perl5	perltrap, perl
	Linking w/C	perlxstut, perlxs, perlcall, perlguts, perlembed
	Various 	http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz
			(not a man-page but still useful, a collection
			 of various essays on Perl techniques)

=end original

	基礎		perldata, perlvar, perlsyn, perlop, perlsub
	実行		perlrun, perldebug
	関数		perlfunc
	オブジェクト	perlref, perlmod, perlobj, perltie
	データ構造	perlref, perllol, perldsc
	モジュール	perlmod, perlmodlib, perlsub
	正規表現	perlre, perlfunc, perlop, perllocale
	perl5への移行	perltrap, perl
	Cとのリンク	perlxstut, perlxs, perlcall, perlguts, perlembed
	その他  	http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz
			(man-page ではありませんが有用な、Perl のテクニックに
			関するコラム集です)

=begin original

A crude table of contents for the Perl manpage set is found in L<perltoc>.

=end original

無加工の Perl のマニュアルページセットの目次の一覧が L<perltoc> にあります。

=head2 How can I use Perl interactively?

(対話的に Perl を使うには?)

=begin original

The typical approach uses the Perl debugger, described in the
perldebug(1) manpage, on an "empty" program, like this:

=end original

典型的なやり方は、perldebug(1) マニュアルページにあるような Perl
デバッガを以下の例のように「空の」プログラムに対して使うことです:

    perl -de 42

=begin original

Now just type in any legal Perl code, and it will be immediately
evaluated.  You can also examine the symbol table, get stack
backtraces, check variable values, set breakpoints, and other
operations typically found in symbolic debuggers.

=end original

これで、正しい Perl コードをタイプするだけで即座にそれが評価されます。
同様に、シンボルテーブルの検査やスタックのバックトレースを得ること、
変数の値の確認、ブレークポイントの設定、そしてシンボリックデバッガで
行える典型的な操作が可能です。

=head2 Is there a Perl shell?

(Perl シェルはありますか?)

=begin original

The psh (Perl sh) is currently at version 1.8. The Perl Shell is a shell
that combines the interactive nature of a Unix shell with the power of
Perl. The goal is a full featured shell that behaves as expected for
normal shell activity and uses Perl syntax and functionality for
control-flow statements and other things. You can get psh at
http://sourceforge.net/projects/psh/ .

=end original

psh(Perl sh) は現在バージョン 1.8 です。
Perl Shell は Unix シェルの対話性と Perl の力を融合したものです。
目標は通常のシェルのような機能および、フロー制御やその他のことに
Perl の文法と機能を使う完全な機能を持ったシェルです。
psh は http://www.focusresearch.com/gregor/psh/ で入手できます。

=begin original

Zoidberg is a similar project and provides a shell written in perl,
configured in perl and operated in perl. It is intended as a login shell
and development environment. It can be found at http://zoidberg.sf.net/
or your local CPAN mirror.

=end original

Zoidberg は似たようなプロジェクトで perl で書かれたシェルを提供します。
これは perl で設定され、perl で動作します。
これはログインシェルと開発環境を意図しています。
http://zoidberg.sf.net/ またはお近くの CPAN ミラーにあります。

=begin original

The Shell.pm module (distributed with Perl) makes Perl try commands
which aren't part of the Perl language as shell commands.  perlsh from
the source distribution is simplistic and uninteresting, but may still
be what you want.

=end original

(Perl と一緒に配布されている) Shell.pm モジュールは、Perl が Perl 言語の
一部ではないコマンドをシェルコマンドのように試してみるようにさせます。
ソース配布と一緒にある perlsh は単純で、面白みに欠けるものかも
しれませんが、あなたの要求には十分かもしれません。

=head2 How do I find which modules are installed on my system?

(自分のシステムに入っているモジュールを知るには?)

=begin original

You can use the ExtUtils::Installed module to show all installed
distributions, although it can take awhile to do its magic.  The
standard library which comes with Perl just shows up as "Perl" (although
you can get those with Module::CoreList).

=end original

ExtUtils::Installed モジュールを使うことで全てのインストールされた
ディストリビューションを知ることが出来ますが、この魔法を使うには
少し時間がかかります。
Perl と共に入る標準ライブラリは単に "Perl" として表示されます
(しかしこれらのリストは Module::CoreList で得ることが出来ます)。

	use ExtUtils::Installed;

	my $inst    = ExtUtils::Installed->new();
	my @modules = $inst->modules();

=begin original

If you want a list of all of the Perl module filenames, you
can use File::Find::Rule.

=end original

全ての Perl モジュールファイル名の一覧を知りたいなら、
File::Find::Rule が利用できます。

	use File::Find::Rule;

	my @files = File::Find::Rule->file()->name( '*.pm' )->in( @INC );

=begin original

If you do not have that module, you can do the same thing
with File::Find which is part of the standard library.

=end original

このモジュールがない場合、標準ライブラリの一部である
File::Find を使って同じことが出来ます。

    use File::Find;
    my @files;

    find(
      sub {
      	push @files, $File::Find::name
      		if -f $File::Find::name && /\.pm$/
      	},

      @INC
      );

	print join "\n", @files;

=begin original

If you simply need to quickly check to see if a module is
available, you can check for its documentation.  If you can
read the documentation the module is most likely installed.
If you cannot read the documentation, the module might not
have any (in rare cases).

=end original

単にあるモジュールが使えるかどうかを知りたいだけなら、
ドキュメントをチェックするという方法があります。
もしそのモジュールに関するドキュメントが読めるなら、
そのモジュールはきっとインストールされています。
ドキュメントが読めない場合、(まれに)モジュールにドキュメントが
ないという可能性もあります。

	prompt% perldoc Module::Name

=begin original

You can also try to include the module in a one-liner to see if
perl finds it.

=end original

一行野郎でモジュールを読み込めるか試すという手もあります。

	perl -MModule::Name -e1

=head2 How do I debug my Perl programs?

(私の Perl プログラムをデバッグするには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

Before you do anything else, you can help yourself by ensuring that
you let Perl tell you about problem areas in your code. By turning
on warnings and strictures, you can head off many problems before
they get too big. You can find out more about these in L<strict>
and L<warnings>.

=end original

他の事をする前に、あなたのコードの問題を Perl に調べさせることで
あなたへの助けとすることが出来ます。
警告と厳密性をオンにすることによって、多くの問題を大事になる前に
阻止できます。
これらに関する詳細は L<strict> と L<warnings> にあります。

	#!/usr/bin/perl
	use strict;
	use warnings;

=begin original

Beyond that, the simplest debugger is the C<print> function. Use it
to look at values as you run your program:

=end original

その他に、もっとも単純なデバッガは C<print> 関数です。
プログラム実行中に値を見るために使います:

	print STDERR "The value is [$value]\n";

=begin original

The C<Data::Dumper> module can pretty-print Perl data structures:

=end original

C<Data::Dumper> モジュールは Perl のデータ構造をきれいに表示します:

	use Data::Dumper qw( Dumper );
	print STDERR "The hash is " . Dumper( \%hash ) . "\n";

=begin original

Perl comes with an interactive debugger, which you can start with the
C<-d> switch. It's fully explained in L<perldebug>.

=end original

Perl には対話的デバッガが同梱されていて、C<-d> スイッチを付けることで
起動できます。
L<perldebug> で完全に説明されています。

=begin original

If you'd like a graphical user interface and you have Tk, you can use
C<ptkdb>. It's on CPAN and available for free.

=end original

もし GUI がほしくて、Tk がある場合、C<ptkdb> が使えます。
これは CPAN にあり、自由に使えます。

=begin original

If you need something much more sophisticated and controllable, Leon
Brocard's Devel::ebug (which you can call with the -D switch as -Debug)
gives you the programmatic hooks into everything you need to write your
own (without too much pain and suffering).

=end original

もっと洗練されていて制御可能なものが必要なら、Leon Brocard の
Devel::ebug (-D オプションを使って -Debug として呼び出せます)を使うと、
なんでもあなたが自分で書いたものを使って(それほどの苦痛なしに)プログラム上の
フックを作れます。

=begin original

You can also use a commercial debugger such as Affrus (Mac OS X), Komodo
from Activestate (Windows and Mac OS X), or EPIC (most platforms).

=end original

Affrus (Mac OS X), Activestate Komodo (Windows と Mac OS X), EPIC
(ほとんどのプラットフォーム) といった商用デバッガも使えます。

=head2 How do I profile my Perl programs?

(私の Perl プログラムのプロファイルを取るには?)

=begin original

You should get the Devel::DProf module from the standard distribution
(or separately on CPAN) and also use Benchmark.pm from the standard
distribution.  The Benchmark module lets you time specific portions of
your code, while Devel::DProf gives detailed breakdowns of where your
code spends its time.

=end original

標準配付キットにある(CPAN にも分離して置いてあります)
Devel::DProf モジュールを入手して、標準配布キットにある
Benchmark.pm も使ってみるべきでしょう。
ベンチマークは、あなたのプログラムの特定の部分の所要時間を取るのに対して、
Devel::DProf はあなたのプログラムのどこがどのくらい時間を
消費しているのかの詳細を報告します。

=begin original

Here's a sample use of Benchmark:

=end original

以下は Benchmark の使い方の例です:

  use Benchmark;

  @junk = `cat /etc/motd`;
  $count = 10_000;

  timethese($count, {
            'map' => sub { my @a = @junk;
			   map { s/a/b/ } @a;
			   return @a },
            'for' => sub { my @a = @junk;
			   for (@a) { s/a/b/ };
			   return @a },
           });

=begin original

This is what it prints (on one machine--your results will be dependent
on your hardware, operating system, and the load on your machine):

=end original

これは以下のような出力を行います
(あるマシン上の例。ハードウェア、オペレーティングシステム、その時点での
マシンの使用状況によって結果は変わります):

  Benchmark: timing 10000 iterations of for, map...
         for:  4 secs ( 3.97 usr  0.01 sys =  3.98 cpu)
         map:  6 secs ( 4.97 usr  0.00 sys =  4.97 cpu)

=begin original

Be aware that a good benchmark is very hard to write.  It only tests the
data you give it and proves little about the differing complexities
of contrasting algorithms.

=end original

良いベンチマークを書くのは非常に大変だということに注意してください。
ベンチマークはあなたが与えたデータのみをテストし、複雑なアルゴリズムが
使われたときの複雑さとは異なっているものなのです。

=head2 How do I cross-reference my Perl programs?

(私の Perl プログラムのクロスリファレンスをとるには?)

=begin original

The B::Xref module can be used to generate cross-reference reports
for Perl programs.

=end original

B::Xref モジュールが Perl プログラムに対する
クロスリファレンスの報告を生成するのに使えます。

    perl -MO=Xref[,OPTIONS] scriptname.plx

=head2 Is there a pretty-printer (formatter) for Perl?

(Perl 用のプリティプリンター(フォーマッター)はありますか?)

=begin original

Perltidy is a Perl script which indents and reformats Perl scripts
to make them easier to read by trying to follow the rules of the
L<perlstyle>. If you write Perl scripts, or spend much time reading
them, you will probably find it useful.  It is available at
http://perltidy.sourceforge.net

=end original

Perltidy は Perl スクリプトを L<perlstyle> のルールに従って
読みやすくしようとする Perl スクリプトです。
Perl スクリプトを書いたとき、あるいは多くの時間を Perl スクリプトを
読むのに費やすとき、多分これが有用です。
http://perltidy.sourceforge.net で入手できます。

=begin original

Of course, if you simply follow the guidelines in L<perlstyle>,
you shouldn't need to reformat.  The habit of formatting your code
as you write it will help prevent bugs.  Your editor can and should
help you with this.  The perl-mode or newer cperl-mode for emacs
can provide remarkable amounts of help with most (but not all)
code, and even less programmable editors can provide significant
assistance.  Tom Christiansen and many other VI users  swear by
the following settings in vi and its clones:

=end original

もちろん、あなたが L<perlstyle> に従っているのであれば、
リフォーマットする必要はないでしょう。
自分のプログラムの書式を統一しておく習慣はバグ対策になります。
あなたの使っているエディターはソースのフォーマッティングを
助けてくれるかもしれません。
emacs の perl モードやより新しい cperl モードは、コードの
ほとんど(が、全部ではありません)に対して驚くほどたくさんの手助けを
提供してくれるでしょうし、そしてそれよりも非力なプログラム可能な
エディターでさえも明らかな手助けを提供してくれるかもしれません。
Tom Christiansen とその他の多くの vi 使いは vi (とそのクローン)で
以下のような設定を使っています:

    set ai sw=4
    map! ^O {^M}^[O^T

=begin original

Put that in your F<.exrc> file (replacing the caret characters
with control characters) and away you go.  In insert mode, ^T is
for indenting, ^D is for undenting, and ^O is for blockdenting--as
it were.  A more complete example, with comments, can be found at
http://www.cpan.org/authors/id/TOMC/scripts/toms.exrc.gz

=end original

これをあなたの F<.exrc> というファイル(キャレット文字はコントロール文字で
置き換えます)に書き込めば OK です。
挿入モードでは ^T はインデントを行い、^D はアンインデントを、
^Oは blockdent をします。
コメント付きの、より完全な例は
http://www.perl.com/CPAN-local/authors/id/TOMC/scripts/toms.exrc.gz
にあります。

=begin original

The a2ps http://www-inf.enst.fr/%7Edemaille/a2ps/black+white.ps.gz does
lots of things related to generating nicely printed output of
documents.

=end original

http://www-inf.enst.fr/%7Edemaille/a2ps/black+white.ps.gz にある a2ps は
奇麗なドキュメントを出力するということに関して多くのことを行います。

=head2 Is there a ctags for Perl?

(Perl 用の ctags はありますか?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

Ctags uses an index to quickly find things in source code, and many
popular editors support ctags for several different languages,
including Perl.

=end original

ctags はソースコード内のものを素早く探すためにインデックスを使い、多くの
有名なエディタは Perl を含むいくつかの言語に対して ctags に対応しています。

=begin original

Exuberent ctags supports Perl: http://ctags.sourceforge.net/

=end original

Exuberent ctags は Perl に対応しています: http://ctags.sourceforge.net/

=begin original

You might also try pltags: http://www.mscha.com/pltags.zip

=end original

pltags も試してみてください: http://www.mscha.com/pltags.zip

=head2 Is there an IDE or Windows Perl Editor?

(Perl の統合開発環境とか Windows Perl Editor はありますか?)

=begin original

Perl programs are just plain text, so any editor will do.

=end original

Perl プログラムは単なるテキストなので、どんなエディタでも作成できます。

=begin original

If you're on Unix, you already have an IDE--Unix itself.  The UNIX
philosophy is the philosophy of several small tools that each do one
thing and do it well.  It's like a carpenter's toolbox.

=end original

あなたが Unix を使っているなら、あなたはすでに統合開発環境を
手にしています--それは Unix 自身です。
Unix の哲学は、一つのことをうまくこなせる小さなツールを複数
組み合わせることです。
これは大工の道具箱に似ています。

=begin original

If you want an IDE, check the following (in alphabetical order, not
order of preference):

=end original

統合開発環境がほしいなら、以下をチェックしてください
(アルファベット順であって、有用な順ではありません):

=over 4

=item Eclipse

http://e-p-i-c.sf.net/

=begin original

The Eclipse Perl Integration Project integrates Perl
editing/debugging with Eclipse.

=end original

The Eclipse Perl Integration Project は Perl の編集/デバッグを Eclipse に
統合します。

=item Enginsite

http://www.enginsite.com/

=begin original

Perl Editor by EngInSite is a complete integrated development
environment (IDE) for creating, testing, and  debugging  Perl scripts;
the tool runs on Windows 9x/NT/2000/XP or later.

=end original

EngInSite の Perl Editor Perl スクリプトを作成・テスト・デバッグするための
完全な統合開発環境(IDE)です; ツールは Windows 9x/NT/2000/XP 移行で
動作します。

=item Komodo

http://www.ActiveState.com/Products/Komodo/

=begin original

ActiveState's cross-platform (as of October 2004, that's Windows, Linux,
and Solaris), multi-language IDE has Perl support, including a regular expression
debugger and remote debugging.

=end original

ActiveState のクロスプラットフォーム(2004 年 10 月現在
Windows, Linux, Solaris) 多言語 IDE は、
正規表現デバッガ、リモートデバッグを含む Perl サポートがあります。

=item Open Perl IDE

http://open-perl-ide.sourceforge.net/

=begin original

Open Perl IDE is an integrated development environment for writing
and debugging Perl scripts with ActiveState's ActivePerl distribution
under Windows 95/98/NT/2000.

=end original

Open Perl IDE は Windows 95/98/NT/2000 で動作する ActiveState の
ActivePerl で Perl スクリプトを書いたりデバッグしたりするための
統合開発環境です。

=item OptiPerl

http://www.optiperl.com/

=begin original

OptiPerl is a Windows IDE with simulated CGI environment, including
debugger and syntax highlighting editor.

=end original

OptiPerl は擬似 CGI 環境を持つ Windows 用 IDE で、
デバッガと文法によって色付けされるエディタを含みます。

=item PerlBuilder

http://www.solutionsoft.com/perl.htm

=begin original

PerlBuidler is an integrated development environment for Windows that
supports Perl development.

=end original

PerlBuilder は Windows 用統合開発環境で、Perl の開発にも対応しています。

=item visiPerl+

http://helpconsulting.net/visiperl/

=begin original

From Help Consulting, for Windows.

=end original

Help Consulting 製で、Windows 用です。

=item Visual Perl

http://www.activestate.com/Products/Visual_Perl/

=begin original

Visual Perl is a Visual Studio.NET plug-in from ActiveState.

=end original

Visual Perl は ActiveState 製で、Visual Studio.NET へのプラグインです。

=item Zeus

http://www.zeusedit.com/lookmain.html

=begin original

Zeus for Window is another Win32 multi-language editor/IDE
that comes with support for Perl:

=end original

Zeus for Window は Perl にも対応した、もう一つの Win32 複数言語
エディタ/IDEです。

=back

=begin original

For editors: if you're on Unix you probably have vi or a vi clone
already, and possibly an emacs too, so you may not need to download
anything. In any emacs the cperl-mode (M-x cperl-mode) gives you
perhaps the best available Perl editing mode in any editor.

=end original

エディタ使いへ: あなたが Unix を使っているなら、おそらく vi か
vi クローンがすでにあるはずで、emacs もあるかもしれません。
それで、あなたは何もダウンロードする必要はないかもしれません。
あらゆるバージョンの emacs で使える cperl-mode (M-x cperl-mode) は
おそらくエディタでの Perl 編集モードの中で最高のものでしょう。

=begin original

If you are using Windows, you can use any editor that lets you work
with plain text, such as NotePad or WordPad.  Word processors, such as
Microsoft Word or WordPerfect, typically do not work since they insert
all sorts of behind-the-scenes information, although some allow you to
save files as "Text Only". You can also download text editors designed
specifically for programming, such as Textpad (
http://www.textpad.com/ ) and UltraEdit ( http://www.ultraedit.com/ ),
among others.

=end original

Windows を使っているのなら、NotePad や WordPad といった
プレーンテキストを扱えるエディタを使うことが出来ます。
Microsoft Word や WordPerfect といったワードプロセッサは
一般的には使えません。なぜなら色々な「裏方の」情報を追加するからです。
ただし、"Text Only" としてファイルをセーブできるものもあります。
また、Textpad ( http://www.textpad.com/ ) や UltraEdit
( http://www.ultraedit.com/ ) といったプログラミングに特化した
テキストエディタをダウンロードすることもできます。

=begin original

If you are using MacOS, the same concerns apply.  MacPerl (for Classic
environments) comes with a simple editor. Popular external editors are
BBEdit ( http://www.bbedit.com/ ) or Alpha (
http://www.his.com/~jguyer/Alpha/Alpha8.html ). MacOS X users can use
Unix editors as well.

=end original

MacOS を使っているなら、同様の考え方が適用されます。
(Classic 環境用の)MacPerl にはシンプルなエディタが付いています。
有名な外部エディタとしては BBEdit ( http://www.bbedit.com/ ) や
Alpha ( http://www.his.com/~jguyer/Alpha/Alpha8.html ) があります。
MacOS X ユーザーは Unix エディタも使えます。

=over 4

=item GNU Emacs

http://www.gnu.org/software/emacs/windows/ntemacs.html

=item MicroEMACS

http://www.microemacs.de/

=item XEmacs

http://www.xemacs.org/Download/index.html

=item Jed

http://space.mit.edu/~davis/jed/

=back

=begin original

or a vi clone such as

=end original

あるいは以下のような vi クローンもあります:

=over 4

=item Elvis

ftp://ftp.cs.pdx.edu/pub/elvis/ http://www.fh-wedel.de/elvis/

=item Vile

http://dickey.his.com/vile/vile.html

=item Vim

http://www.vim.org/

=back

=begin original

For vi lovers in general, Windows or elsewhere:

=end original

一般的な、Windows やその他の vi 愛好者のために:

	http://www.thomer.com/thomer/vi/vi.html

=begin original

nvi ( http://www.bostic.com/vi/ , available from CPAN in src/misc/) is
yet another vi clone, unfortunately not available for Windows, but in
UNIX platforms you might be interested in trying it out, firstly because
strictly speaking it is not a vi clone, it is the real vi, or the new
incarnation of it, and secondly because you can embed Perl inside it
to use Perl as the scripting language.  nvi is not alone in this,
though: at least also vim and vile offer an embedded Perl.

=end original

nvi (http://www.bostic.com/vi/ , CPAN の src/misc/ にもあります)は
vi クローンの一つで、残念ながら Windows では動作しませんが、
UNIX プラットフォームを使っているなら試してみるべきです。
第一の理由としては、厳密には vi クローンではないものの、
実際は vi、あるいは vi の子孫であるからです。
第二の理由としては、Perl を内蔵していて、Perl をスクリプト言語として
使えるからです。
しかし、nvi はこれらの機能をもつ唯一のものではありません。
少なくとも vim と vile も内蔵 Perl を提供しています。

=begin original

The following are Win32 multilanguage editor/IDESs that support Perl:

=end original

以下は Perl をサポートしている Win32 多言語エディタ/IDE です。

=over 4

=item Codewright

http://www.borland.com/codewright/

=item MultiEdit

http://www.MultiEdit.com/

=item SlickEdit

http://www.slickedit.com/

=back

=begin original

There is also a toyedit Text widget based editor written in Perl
that is distributed with the Tk module on CPAN.  The ptkdb
( http://ptkdb.sourceforge.net/ ) is a Perl/tk based debugger that
acts as a development environment of sorts.  Perl Composer
( http://perlcomposer.sourceforge.net/ ) is an IDE for Perl/Tk
GUI creation.

=end original

CPAN で Tk モジュールと共に配布されている、Perl で書かれた
toyedit Text ウィジェットベースのエディタがあります。
ptkdb( http://ptkdb.sourceforge.net/ ) は 開発環境として振舞う
Perl/tk ベースのデバッガです。
Perl Composer ( http://perlcomposer.sourceforge.net/vperl.html )は
Perl/Tk GUI を使った IDE です。

=begin original

In addition to an editor/IDE you might be interested in a more
powerful shell environment for Win32.  Your options include

=end original

エディタ/統合開発環境に加えて、Win32 環境でのより強力な
シェル環境に興味があるかもしれません。
選択肢としては以下のものがあります:

=over 4

=item Bash

=begin original

from the Cygwin package ( http://sources.redhat.com/cygwin/ )

=end original

Cygwin パッケージ ( http://sources.redhat.com/cygwin/ ) から。

=item Ksh

=begin original

from the MKS Toolkit ( http://www.mks.com/ ), or the Bourne shell of
the U/WIN environment ( http://www.research.att.com/sw/tools/uwin/ )

=end original

MKS ツールキット ( http://www.mks.com/ )か、
U/WIN 環境 ( http://www.research.att.com/sw/tools/uwin/ ) の
Bourne shell から。

=item Tcsh

=begin original

ftp://ftp.astron.com/pub/tcsh/ , see also
http://www.primate.wisc.edu/software/csh-tcsh-book/

=end original

ftp://ftp.astron.com/pub/tcsh/ ;
http://www.primate.wisc.edu/software/csh-tcsh-book/ も参照してください。

=item Zsh

http://www.zsh.org/

=back

=begin original

MKS and U/WIN are commercial (U/WIN is free for educational and
research purposes), Cygwin is covered by the GNU Public License (but
that shouldn't matter for Perl use).  The Cygwin, MKS, and U/WIN all
contain (in addition to the shells) a comprehensive set of standard
UNIX toolkit utilities.

=end original

MKS とU/WIN は商用(U/WIN は教育・研究目的には無料)で、
Cygwin は GNU Public License で配布されています
(しかしこれは Perl の使用には関係ないはずです)。
Cygwin, MSK, U/WIN は全て(シェルに加えて)広範囲な標準 UNIX
ツールキットを含んでいます。

=begin original

If you're transferring text files between Unix and Windows using FTP
be sure to transfer them in ASCII mode so the ends of lines are
appropriately converted.

=end original

Unix と Windows の間でテキストファイルを FTP で転送する場合、
改行コードを適切に変更するために ASCII モードにしてください。

=begin original

On Mac OS the MacPerl Application comes with a simple 32k text editor
that behaves like a rudimentary IDE.  In contrast to the MacPerl Application
the MPW Perl tool can make use of the MPW Shell itself as an editor (with
no 32k limit).

=end original

Mac OS では MacPerl Application は基本的な IDE のように振舞う
シンプルな 32k テキストエディタがついています。
MacPerl Application と対照的に、MPW Perl tool は MPW Shell 自身を
(32k の制限なしに)エディタとして使えます。

=over 4

=item Affrus

=begin original

is a full Perl development environment with full debugger support
( http://www.latenightsw.com ).

=end original

は、完全なデバッガサポート付きの完全な Perl 開発環境です
( http://www.latenightsw.com )。

=item Alpha

=begin original

is an editor, written and extensible in Tcl, that nonetheless has
built in support for several popular markup and programming languages
including Perl and HTML ( http://www.his.com/~jguyer/Alpha/Alpha8.html ).

=end original

これはエディタで、Tcl で書かれており、拡張可能です。
それでもいくつかの有名なマークアップ言語とプログラミング言語
( Perl と HTML を含みます)への対応を内蔵しています
( http://www.his.com/~jguyer/Alpha/Alpha8.html )。

=item BBEdit and BBEdit Lite

=begin original

are text editors for Mac OS that have a Perl sensitivity mode
( http://web.barebones.com/ ).

=end original

これは Mac OS で動作するテキストエディタで、
Perl 用のモードがあります( http://web.barebones.com/ )。

=back

=begin original

Pepper and Pe are programming language sensitive text editors for Mac
OS X and BeOS respectively ( http://www.hekkelman.com/ ).

=end original

Pepper と Pe はそれぞれ Mac OS X と BeOS 用のプログラミング言語向け
テキストエディタです( http://www.hekkelman.com/ )。

=head2 Where can I get Perl macros for vi?

(vi 用の Perl マクロはどこで入手できますか?)

=begin original

For a complete version of Tom Christiansen's vi configuration file,
see http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz ,
the standard benchmark file for vi emulators.  The file runs best with nvi,
the current version of vi out of Berkeley, which incidentally can be built
with an embedded Perl interpreter--see http://www.cpan.org/src/misc/ .

=end original

Tom Christiansen の vi コンフィグレーションファイルの完全なものは
vi エミュレータの標準ベンチマークファイルである 
http://www.cpan.org/authors/Tom_Christiansen/scripts/toms.exrc.gz
を参照してください。
これは Berkeley の外にあるviのカレントバージョンである nvi で
最もうまく実行されます。
nvi は組み込みの Perl インタプリタをつけてビルドすることもできます。
http://www.cpan.org/src/misc/ を参照してください。

=head2 Where can I get perl-mode for emacs?

(emacs の perl-mode はどこで入手できますか?)

=begin original

Since Emacs version 19 patchlevel 22 or so, there have been both a
perl-mode.el and support for the Perl debugger built in.  These should
come with the standard Emacs 19 distribution.

=end original

Emacs のバージョン 19 パッチレベル 22 から、perl-mode.el と組み込みの Perl
デバッガをサポートしています。
これらは標準の Emacs19 配布セットと一緒にあるはずです。

=begin original

In the Perl source directory, you'll find a directory called "emacs",
which contains a cperl-mode that color-codes keywords, provides
context-sensitive help, and other nifty things.

=end original

Perlのソースディレクトリには、"emacs" というディレクトリがあって、
そこにはキーワードをカラー表示したり、コンテキスト依存な
ヘルプなどのご機嫌なことを提供する cperl-mode があります。

=begin original

Note that the perl-mode of emacs will have fits with C<"main'foo">
(single quote), and mess up the indentation and highlighting.  You
are probably using C<"main::foo"> in new Perl code anyway, so this
shouldn't be an issue.

=end original

emacs の perl-mode は C<"main'foo">(シングルクォート)スタイルを扱うもので、
インデントやハイライトをおかしくしてしまうことに注意してください。
いずれにしろ、C<"main::foo">を使うべきでしょう。

=head2 How can I use curses with Perl?

(Perl で curses を使うには?)

=begin original

The Curses module from CPAN provides a dynamically loadable object
module interface to a curses library.  A small demo can be found at the
directory http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz ;
this program repeats a command and updates the screen as needed, rendering
B<rep ps axu> similar to B<top>.

=end original

CPAN にある Curses モジュールは、curses ライブラリに対する動的に
ロード可能なオブジェクトモジュールインターフェースを提供します。
ちょっとしたデモが
http://www.cpan.org/authors/Tom_Christiansen/scripts/rep.gz
にあります。
このプログラムはコマンドを繰り返し、必要に応じて
画面を更新し、B<top> と同じく B<rep ps axu> をレンダリングします。

=head2 How can I write a GUI (X, Tk, Gtk, etc.) in Perl?
X<GUI> X<Tk> X<Wx> X<WxWidgets> X<Gtk> X<Gtk2> X<CamelBones> X<Qt>

(Perl で GUI (X, Tk, Gtk など) を書くには?)

=begin original

(contributed by Ben Morrow)

=end original

(Ben Morrow によって寄贈されました)

=begin original

There are a number of modules which let you write GUIs in Perl. Most
GUI toolkits have a perl interface: an incomplete list follows.

=end original

Perl で GUI を書くための多くのモジュールがあります。
ほとんどの GUI ツールキットには perl インターフェースがあります:
以下に不完全なリストを示します。

=over 4

=item Tk

=begin original

This works under Unix and Windows, and the current version doesn't
look half as bad under Windows as it used to. Some of the gui elements
still don't 'feel' quite right, though. The interface is very natural
and 'perlish', making it easy to use in small scripts that just need a
simple gui. It hasn't been updated in a while.

=end original

これは Unix と Windows で動作し、現在のバージョンは Windows でも以前のように
悪くはないです。
しかし、GUI 要素には完全に正しい「感じ」ではないものもあります。
インターフェースはとても自然で「perl っぽい」もので、単純な GUI が
ほしいだけの小さいスクリプトで簡単に使えます。
これはしばらくの間更新されていません。

=item Wx

=begin original

This is a Perl binding for the cross-platform wxWidgets toolkit 
L<http://www.wxwidgets.org>. It works under Unix, Win32 and Mac OS X,
using native widgets (Gtk under Unix). The interface follows the C++
interface closely, but the documentation is a little sparse for someone
who doesn't know the library, mostly just referring you to the C++
documentation.

=end original

これは クロスプラットフォーム wxWidgets ツールキット
L<http://www.wxwidgets.org> の Perl バインディングです。
これは ネイティブなウィジェット(Unix では Gtk) を使って、
Unix, Win32, Mac OS X で動作します。
インターフェースは C++ インターフェースに近いですが、
ドキュメントはライブラリを知らない人にとっては少々手薄なので、
たいていは単に C++ ドキュメントを参照することになるでしょう。

=item Gtk and Gtk2

=begin original

These are Perl bindings for the Gtk toolkit L<http://www.gtk.org>. The
interface changed significantly between versions 1 and 2 so they have
separate Perl modules. It runs under Unix, Win32 and Mac OS X (currently
it requires an X server on Mac OS, but a 'native' port is underway), and
the widgets look the same on every plaform: i.e., they don't match the
native widgets. As with Wx, the Perl bindings follow the C API closely,
and the documentation requires you to read the C documentation to
understand it.

=end original

Gtk ツールキット L<http://www.gtk.org> の Perl バインディングがあります。
バージョン 1 と 2 でインターフェースが大きく変わったので、個別の Perl
モジュールになっています。
これは Unix, Win32, Mac OS X で動作し(現在のところ Mac OS X では
X サーバーが必要ですが、「ネイティブ」ポートも進行中です)、ウィジェットは
どのプラットフォームでも同じような見た目になります(つまり、ネイティブの
ウィジェットとは一致しません)。
Wx と同様、Perl バインディングは C API に似ていて、これを理解するためには
C のドキュメントを読む必要があります。

=item Win32::GUI

=begin original

This provides access to most of the Win32 GUI widgets from Perl.
Obviously, it only runs under Win32, and uses native widgets. The Perl
interface doesn't really follow the C interface: it's been made more
Perlish, and the documentation is pretty good. More advanced stuff may
require familiarity with the C Win32 APIs, or reference to MSDN.

=end original

これは Perl から Win32 GUI ウィジェットのほとんどへのアクセスを提供します。
明らかに、これは Win32 でのみ動作し、ネイティブなウィジェットを使います。
Perl のインターフェースは C のインターフェースに本当に従ってはいません:
これはより Perl っぽく、ドキュメントもかなりよく出来ています。
より高度な機能を使うためには C Win32 API に親しんでいるか、MSDN を
参照する必要があります。

=item CamelBones

=begin original

CamelBones L<http://camelbones.sourceforge.net> is a Perl interface to
Mac OS X's Cocoa GUI toolkit, and as such can be used to produce native
GUIs on Mac OS X. It's not on CPAN, as it requires frameworks that
CPAN.pm doesn't know how to install, but installation is via the
standard OSX package installer. The Perl API is, again, very close to
the ObjC API it's wrapping, and the documentation just tells you how to
translate from one to the other.

=end original

CamelBones L<http://camelbones.sourceforge.net> は Mac OS X の Cocoa GUI への
Perl のインターフェースで、Mac OS X でのネイティブな GUI の生成に使えます。
これは CPAN.pm がどのようにインストールすればよいか知らないフレームワークを
必要とするので CPAN にはありませんが、標準 OSX パッケージインストーラ経由で
インストールします。
再び、Perl API はそれがラッピングしている ObjC API ととても近いので、
ドキュメントは単にお互いをどう変換すればいいかについて書いています。

=item Qt

=begin original

There is a Perl interface to TrollTech's Qt toolkit, but it does not
appear to be maintained.

=end original

TrollTech の Qt toolkit への Perl インターフェースはありますが、
保守されていないようです。

=item Athena

=begin original

Sx is an interface to the Athena widget set which comes with X, but
again it appears not to be much used nowadays.

=end original

Sx は X に同梱されている Athena ウィジェットセットへのインターフェースですが、
やはり最近ではほとんど使われていないようです。

=back

=head2 How can I make my Perl program run faster?

(私の Perl プログラムをもっと速くするには?)

=begin original

The best way to do this is to come up with a better algorithm.  This
can often make a dramatic difference.  Jon Bentley's book
I<Programming Pearls> (that's not a misspelling!)  has some good tips
on optimization, too.  Advice on benchmarking boils down to: benchmark
and profile to make sure you're optimizing the right part, look for
better algorithms instead of microtuning your code, and when all else
fails consider just buying faster hardware.  You will probably want to
read the answer to the earlier question "How do I profile my Perl
programs?" if you haven't done so already.

=end original

その最善の方法とは、よりよいアルゴリズムを使うということです。
ラクダ本の第八章にはあなたが感心をよせるかもしれない幾つかの効率的な
tips があります。
Jon Bentleyの著作 "Programming Pearls" (ミススペルではありません!)
(邦訳「珠玉のプログラミング」)にも最適化に関するいくつかの Tips があります。
ベンチマークとプロファイルによって、
あなたのプログラムのどこに手を入れて最適化するのが正しいのかを
はっきりさせ、ちまちまと高速化を行うのではなくより良いアルゴリズムを
探す手掛かりになります。
そして、どうしようもなくなったときには
いつ新しいハードウェアを買うかということを知る手掛かりともなります。
まだ読んでいないなら、前述した "How do I profile my Perl programs?" という
質問の答えも読みたいと思うでしょう。

=begin original

A different approach is to autoload seldom-used Perl code.  See the
AutoSplit and AutoLoader modules in the standard distribution for
that.  Or you could locate the bottleneck and think about writing just
that part in C, the way we used to take bottlenecks in C code and
write them in assembler.  Similar to rewriting in C, modules that have
critical sections can be written in C (for instance, the PDL module
from CPAN).

=end original

別のアプローチには、時々使う Perl コードをオートローディングすると
いうものがあります。
このために標準配布キットにある AutoSplit モジュールと
AutoLoader モジュールを参照してください。
あるいは、ボトルネックとなっているところを特定し、その部分を
C で書くことを考えるかもしれません。
ちょうど C で書かれたプログラムのボトルネックをアセンブラで
書くのと同じことです。
C で書き直すという意味では、クリティカルセクションを持ったモジュールを
C で書き直すというのも同様です(例えば、CPAN にある
PDL モジュールがそうです)。

=begin original

If you're currently linking your perl executable to a shared
I<libc.so>, you can often gain a 10-25% performance benefit by
rebuilding it to link with a static libc.a instead.  This will make a
bigger perl executable, but your Perl programs (and programmers) may
thank you for it.  See the F<INSTALL> file in the source distribution
for more information.

=end original

もしあなたが今、perl の実行ファイルと共有ライブラリ C<libc.so> を
リンクしているのであれば、スタティックに libc.a とリンクして perl を
再ビルドすることによって、しばしば 10-25% 性能を
向上させることが可能です。
これは perl の実行ファイルを大きなものにしてしまいますが、
あなたの Perl プログラム(とプログラマー)はスタティックリンクされたことを
感謝するでしょう。
より詳しい情報は、ソース配布にある F<INSTALL> というファイルを
参照してください。

=begin original

The undump program was an ancient attempt to speed up Perl program by
storing the already-compiled form to disk.  This is no longer a viable
option, as it only worked on a few architectures, and wasn't a good
solution anyway.

=end original

undump プログラムは、コンパイル済みの形式でディスクに格納することで
Perlプログラムを高速化するのに古くは使われていました。
これはほんの一部のアーキテクチャーでのみ働くものであって、
最早価値ある選択肢ではなく、かつ、よい解決策ではありません。

=head2 How can I make my Perl program take less memory?

(私の Perl プログラムのメモリ消費量を少なくするには?)

=begin original

When it comes to time-space tradeoffs, Perl nearly always prefers to
throw memory at a problem.  Scalars in Perl use more memory than
strings in C, arrays take more than that, and hashes use even more.  While
there's still a lot to be done, recent releases have been addressing
these issues.  For example, as of 5.004, duplicate hash keys are
shared amongst all hashes using them, so require no reallocation.

=end original

時間と空間とを天秤に掛けたとき、Perl はほとんど常にメモリに関する
問題を放棄します。
Perl におけるスカラーは C の文字列よりもメモリを消費し、
配列も同様です。
ハッシュは更にメモリを使います。
まだ行うことは残ってはいるものの、最近のリリースではこの問題に
対処しています。
たとえば 5.004 にあるように、重複したハッシュキーは全てのハッシュで
共有されます。
このため、(そのハッシュキーの格納のための)再割り付けの必要はありません。

=begin original

In some cases, using substr() or vec() to simulate arrays can be
highly beneficial.  For example, an array of a thousand booleans will
take at least 20,000 bytes of space, but it can be turned into one
125-byte bit vector--a considerable memory savings.  The standard
Tie::SubstrHash module can also help for certain types of data
structure.  If you're working with specialist data structures
(matrices, for instance) modules that implement these in C may use
less memory than equivalent Perl modules.

=end original

substr() や vec() を使って配列をシミュレートすることで大幅に効率を
上げられることがあるでしょう。
たとえば 1000 個のブール値を持った配列は、
少なくとも 20000 バイトの空間を必要とします。
しかし、これを 125 バイトのビットベクターに置き換えることができます--
これで劇的にメモリを節約できます。
標準の Tie::SubstrHash モジュールもデータ構造の幾つかの型に対する助けを
してくれるでしょう。
あなたがデータ構造のスペシャリスト(例えば行列など)モジュールとともに
仕事をしようとしているのなら、
C で実装されたモジュールは Perl で実装された等価なモジュールよりも
少ないメモリしか使わないでしょう。

=begin original

Another thing to try is learning whether your Perl was compiled with
the system malloc or with Perl's builtin malloc.  Whichever one it
is, try using the other one and see whether this makes a difference.
Information about malloc is in the F<INSTALL> file in the source
distribution.  You can find out whether you are using perl's malloc by
typing C<perl -V:usemymalloc>.

=end original

試してみるべきもう一つの事柄は、あなたの使っている Perl がシステムの
malloc を使っているのか Perl 組み込みの malloc を使っているのかを
知ることです。
いずれを使っているにしろ、別のものを使うようにしてみて
それによる差を確かめます。
malloc に関する情報はソース配布にある F<INSTALL> というファイルにあります。
C<perl -V:usemymalloc> とタイプすれば perl が使っている
malloc がどちらであるかを知ることができます。

=begin original

Of course, the best way to save memory is to not do anything to waste
it in the first place. Good programming practices can go a long way
toward this:

=end original

もちろん、メモリを節約する一番の方法はまず無駄なことをしないことです。
よいプログラミングプラクティスは以下のようなものを通じて得られています。

=over 4

=item * Don't slurp!

(ファイル全体を読み込まない!)

=begin original

Don't read an entire file into memory if you can process it line
by line. Or more concretely, use a loop like this:

=end original

ファイルを行単位で処理するときにファイル全体をメモリに読み込んでは
いけません。
より具体的には、以下のようなループを使います:

	#
	# Good Idea
	#
	while (<FILE>) {
	   # ...
	}

=begin original

instead of this:

=end original

以下のような方式はよくないです:

	#
	# Bad Idea
	#
	@data = <FILE>;
	foreach (@data) {
	    # ...
	}

=begin original

When the files you're processing are small, it doesn't much matter which
way you do it, but it makes a huge difference when they start getting
larger.

=end original

処理するファイルサイズが小さいなら、どちらの方法をとっても大きな
違いはありません。
しかし、ファイルが大きくなるにつれてその差は大きいものとなります。

=item * Use map and grep selectively

(map と grep をうまく選んで使う)

=begin original

Remember that both map and grep expect a LIST argument, so doing this:

=end original

map と grep はどちらも LIST 引数を取るので、以下のようにすると:

        @wanted = grep {/pattern/} <FILE>;

=begin original

will cause the entire file to be slurped. For large files, it's better
to loop:

=end original

ファイル全体を読み込むことになります。
大きなファイルでは以下のようにループしたほうがよいです:

        while (<FILE>) {
                push(@wanted, $_) if /pattern/;
        }

=item * Avoid unnecessary quotes and stringification

(不必要なクォートと文字列化を避ける)

=begin original

Don't quote large strings unless absolutely necessary:

=end original

本当に必要でないかぎりは大きな文字列をクォートしてはいけません。

        my $copy = "$large_string";

=begin original

makes 2 copies of $large_string (one for $copy and another for the
quotes), whereas

=end original

このように書くと、$large_string のコピーを二つ($copy とクォートと)
作ります。一方以下のようにすると:

        my $copy = $large_string;

=begin original

only makes one copy.

=end original

コピーは一つしか作られません。

=begin original

Ditto for stringifying large arrays:

=end original

大きな配列の文字列かでも同じことが言えます:

        {
                local $, = "\n";
                print @big_array;
        }

=begin original

is much more memory-efficient than either

=end original

これは次のものや

        print join "\n", @big_array;

=begin original

or

=end original

次のものよりメモリ効率がよいです:

        {
                local $" = "\n";
                print "@big_array";
        }


=item * Pass by reference

(リファレンスで渡す)

=begin original

Pass arrays and hashes by reference, not by value. For one thing, it's
the only way to pass multiple lists or hashes (or both) in a single
call/return. It also avoids creating a copy of all the contents. This
requires some judgement, however, because any changes will be propagated
back to the original data. If you really want to mangle (er, modify) a
copy, you'll have to sacrifice the memory needed to make one.

=end original

配列とハッシュは値ではなく、リファレンスで渡します。
これは一つの呼び出し/返り値で複数のリストやハッシュ(やその両方)を
渡す唯一の方法です。
また、これにより内容全てのコピーを作成しなくてすみます。
しかし、これにはいくばくかの判断が必要です。なぜならあらゆる変更が
元のデータに伝播するからです。
もし本当にコピーをいじりたい(修正したい)のなら、
コピーを作るためのメモリを犠牲にする必要があります。

=item * Tie large variables to disk.

(大きな変数をディスクに tie する)

=begin original

For "big" data stores (i.e. ones that exceed available memory) consider
using one of the DB modules to store it on disk instead of in RAM. This
will incur a penalty in access time, but that's probably better than
causing your hard disk to thrash due to massive swapping.

=end original

「大きな」データストア(利用可能なメモリ量を超えるようなもの)を
扱う時には RAM の代わりにディスクに保存するために DB モジュールの
どれかを使うことを考えてください。
これはアクセス時間の低下を招きますが、おそらくは大量の
スワッピングによってハードディスクが激しく動くよりましです。

=back

=head2 Is it safe to return a reference to local or lexical data?

(ローカルやレキシカルなデータへのポインターを返すことは安全ですか?)

=begin original

Yes. Perl's garbage collection system takes care of this so
everything works out right.

=end original

はい。
Perl のガベージコレクションシステムは全てがうまくいくように
考慮されています。

    sub makeone {
	my @a = ( 1 .. 10 );
	return \@a;
    }

    for ( 1 .. 10 ) {
        push @many, makeone();
    }

    print $many[4][5], "\n";

    print "@many\n";

=head2 How can I free an array or hash so my program shrinks?

(配列やハッシュを解放して私のプログラムを小さくするには?)

=begin original

(contributed by Michael Carman)

=end original

(Michael Carman によって寄贈されました)

=begin original

You usually can't. Memory allocated to lexicals (i.e. my() variables)
cannot be reclaimed or reused even if they go out of scope. It is
reserved in case the variables come back into scope. Memory allocated
to global variables can be reused (within your program) by using
undef()ing and/or delete().

=end original

それは通常できません。
レキシカル(例えば my() 変数) に割り当てられたメモリは、たとえスコープから
外れても再請求や再利用されません。
これは変数がスコープ内に戻ってくる場合のために保存されます。
グローバル変数に割り当てられたメモリは undef() や delete() を使うことで
(あなたのプログラム内で)再利用されます。

=begin original

On most operating systems, memory allocated to a program can never be
returned to the system. That's why long-running programs sometimes re-
exec themselves. Some operating systems (notably, systems that use
mmap(2) for allocating large chunks of memory) can reclaim memory that
is no longer used, but on such systems, perl must be configured and
compiled to use the OS's malloc, not perl's.

=end original

ほとんどのシステムでは、プログラムのために
割り付けたメモリは、決してシステムに返されることはありません。
これは、長期間動作しているプログラムが時々自分自身を
再起動する理由でもあります。
一部のオペレーティングシステム(特に大きなメモリの塊を
割り付けるときに mmap(2) を使うシステム)では、
最早使われていないメモリの塊を回収できますが、
そのようなシステムでは、perl を perl 自身ではなく OS の
malloc を使うように設定し、コンパイルしなければなりません。

=begin original

In general, memory allocation and de-allocation isn't something you can
or should be worrying about much in Perl.

=end original

一般的に、メモリの確保と解放の問題は Perl においてはあまり気にする必要がある
問題ではありません。

=begin original

See also "How can I make my Perl program take less memory?"

=end original

"How can I make my Perl program take less memory?" も参照してください。

=head2 How can I make my CGI script more efficient?

(私の CGI スクリプトをもっと効率よくするには?)

=begin original

Beyond the normal measures described to make general Perl programs
faster or smaller, a CGI program has additional issues.  It may be run
several times per second.  Given that each time it runs it will need
to be re-compiled and will often allocate a megabyte or more of system
memory, this can be a killer.  Compiling into C B<isn't going to help
you> because the process start-up overhead is where the bottleneck is.

=end original

普通の Perl プログラムを速くしたり小さくしたりするための基準とは別に、
CGI プログラムには更に別の基準があります。
CGI プログラムは一秒に数回実行される可能性があります。
実行する度毎にスクリプトの再コンパイルとシステムメモリを
一メガバイト以上割りつけることが必要となります。
これは問題点となり得ます。
C へコンパイルすることは B<助けにはなりません>。
なぜなら、プロセスのスタートアップ時のオーバーヘッドが
ボトルネックだからです。

=begin original

There are two popular ways to avoid this overhead.  One solution
involves running the Apache HTTP server (available from
http://www.apache.org/ ) with either of the mod_perl or mod_fastcgi
plugin modules.

=end original

このオーバーヘッドを避けるためのポピュラーな手段が二つあります。
解決策の一つは Apache HTTP サーバー(http://www.apache.org/ から入手可能)に
mod_perl か mod_fastcgi のいずれかのプラグインモジュールを
取り込ませて実行させるというものです。

=begin original

With mod_perl and the Apache::Registry module (distributed with
mod_perl), httpd will run with an embedded Perl interpreter which
pre-compiles your script and then executes it within the same address
space without forking.  The Apache extension also gives Perl access to
the internal server API, so modules written in Perl can do just about
anything a module written in C can.  For more on mod_perl, see
http://perl.apache.org/

=end original

mod_perl と Apache::Registry モジュール(mod_perl と一緒に配布されて
います)と組み合わせることで、httpd は組み込みの Perl インタプリタと
共に実行させるようになります。
これで、あなたのスクリプトは事前にコンパイルされ、
それを fork 抜きで同じアドレス空間で実行されるようになります。
Apatche エクステンションはまた、
Perl に内部サーバー API をアクセスすることを許可するので、
Perl で記述されたモジュールは C で書かれたモジュールができることはなんでも
できるようになります。
mod_perl に関する詳細は http://perl.apache.org/ を参照してください。

=begin original

With the FCGI module (from CPAN) and the mod_fastcgi
module (available from http://www.fastcgi.com/ ) each of your Perl
programs becomes a permanent CGI daemon process.

=end original

FCGI モジュール(CPAN にあります)と
mod_fastcgi モジュール(http://www.fastcgi.com で入手できます)は
あなたの Perl プログラムのそれぞれを永続的 CGI デーモンプロセスにします。

=begin original

Both of these solutions can have far-reaching effects on your system
and on the way you write your CGI programs, so investigate them with
care.

=end original

これらの解決策は両方ともあなたの使うシステムで効果がない可能性があり、
また、あなたが書いた CGI プログラムに依存する方法なので、
注意して検査してください。

=begin original

See http://www.cpan.org/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/ .

=end original

http://www.cpan.org/modules/by-category/15_World_Wide_Web_HTML_HTTP_CGI/ を
参照してください。

=head2 How can I hide the source for my Perl program?

(私の Perl プログラムのソースを隠すには?)

=begin original

Delete it. :-) Seriously, there are a number of (mostly
unsatisfactory) solutions with varying levels of "security".

=end original

削除しましょう :-) まじめな話、様々な「セキュリティ」レベルを持った
幾つかの解決策があります(ほとんどは満足行くものではないでしょう)。

=begin original

First of all, however, you I<can't> take away read permission, because
the source code has to be readable in order to be compiled and
interpreted.  (That doesn't mean that a CGI script's source is
readable by people on the web, though--only by people with access to
the filesystem.)  So you have to leave the permissions at the socially
friendly 0755 level.

=end original

しかしながら、まず最初に、あなたは読み取り権限(read permission)を
落とすことはできません。
なぜなら、スクリプトのソースコードはコンパイルと解釈のために
読み取り可能でなければならない
からです(これは CGI スクリプトのソースコードが web 上で、
読み取り可能であることとは違います--
ファイルシステムに対してアクセスできる人だけが読み取り可能です)。
ですから、権限の設定を少なくとも socially friendly な 0755 の
レベルにしておく必要があります。

=begin original

Some people regard this as a security problem.  If your program does
insecure things and relies on people not knowing how to exploit those
insecurities, it is not secure.  It is often possible for someone to
determine the insecure things and exploit them without viewing the
source.  Security through obscurity, the name for hiding your bugs
instead of fixing them, is little security indeed.

=end original

中にはこれをセキュリティ上の問題であると考えている人もいます。
あなたのプログラムが安全でないことを行った場合、
そして、人々がそのような安全でないことを暴露する方法を知らないことに
頼っているのなら、安全ではないのです。
誰かが、安全でないことを見つけだすこととソースを見ることなしにそれを
暴露することはしばしば可能となるのです。
セキュリティバグを直すのではなくてそのバグを隠すといった、
知られていないことに頼るセキュリティ(security through obscurity)は
小さなセキュリティの傷です。

=begin original

You can try using encryption via source filters (Starting from Perl
5.8 the Filter::Simple and Filter::Util::Call modules are included in
the standard distribution), but any decent programmer will be able to
decrypt it.  You can try using the byte code compiler and interpreter
described later in L<perlfaq3>, but the curious might still be able to
de-compile it. You can try using the native-code compiler described
later, but crackers might be able to disassemble it.  These pose
varying degrees of difficulty to people wanting to get at your code,
but none can definitively conceal it (true of every language, not just
Perl).

=end original

ソースフィルタ(Perl 5.8 からは Filter::Simple と Filter::Util::Call は
標準配布物に含まれています)を使った暗号化を試すこともできます。
しかし、悪意在るプログラマーはそれを複号化できるかもしれません。
あなたは L<perlfaq3> で後述するバイトコードコンパイラとインタプリタを
使うことを試せるかもしれませんが、
探りたがりの人はそれを逆コンパイルできるかもしれません。
後述するネイティブコードコンパイラを試すこともできますが、
クラッカーはそれを逆アセンブルできるかもしれません。
これらの手段は、あなたのプログラムを手に入れようとする人達に様々な困難を
もたらしますが、誰もそれを決定的に防ぐ障壁にすることはできないのです
(Perl のみに限らず、あらゆる言語で真となります)。

=begin original

It is very easy to recover the source of Perl programs.  You simply
feed the program to the perl interpreter and use the modules in
the B:: hierarchy.  The B::Deparse module should be able to
defeat most attempts to hide source.  Again, this is not
unique to Perl.

=end original

Perl プログラムのソースを取り出すのはとても簡単です。
プログラムを perl インタプリタに渡して B:: 階層のモジュールを
使うだけです。
B::Deparse モジュールはソースを隠そうとするほとんどの試みを
打ち破るはずです。
繰り返しますが、これは Perl に限ったことではありません。

=begin original

If you're concerned about people profiting from your code, then the
bottom line is that nothing but a restrictive license will give you
legal security.  License your software and pepper it with threatening
statements like "This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah."  We are not lawyers, of course, so you should see a lawyer if
you want to be sure your license's wording will stand up in court.

=end original

あなたが、誰かがあなたのプログラムを元になにか利益を
得るのではないかということを考えているのなら、
プログラムの最後の行を制限付きライセンスとすれば、
あなたに法的な安全性 (legal security)をもたらすでしょう。
あなたのソフトウェアをライセンスし、
“This is unpublished proprietary software of XYZ Corp.
Your access to it does not give you permission to use it blah blah
blah.”
(本ソフトウェアは、XYZ コーポレイションにより作成された非公開の
独占的ソフトウェアです。
あなたがこれにアクセスすることは許されていません、云々)
のような文章で味付けします。
もちろん私たちは弁護士ではありませんから、
あなたが確実に自分のライセンスが有効なものになるようにしたいのなら、
弁護士に会っておくべきでしょう。

=head2 How can I compile my Perl program into byte code or C?

(私の Perl プログラムをバイトコードや C へコンパイルするには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

In general, you can't do this.  There are some things that may work
for your situation though.  People usually ask this question
because they want to distribute their works without giving away
the source code, and most solutions trade disk space for convenience.
You probably won't see much of a speed increase either, since most
solutions simply bundle a Perl interpreter in the final product
(but see L<How can I make my Perl program run faster?>).

=end original

一般的には、それはできません。
しかし、状況によっては可能な場合もあります。
人々は普通、ソースを提供することなく成果を配布したいためにこの質問をします;
そしてほとんどの解決法は便利さのためにディスクスペースを犠牲にします。
ほとんどの解決法は単に最終製品に Perl インタプリタを同梱しているので、
どれを使ってもおそらく大して速度は向上しないでしょう
(しかし L<How can I make my Perl program run faster?> を参照してください)。

=begin original

The Perl Archive Toolkit ( http://par.perl.org/ ) is Perl's
analog to Java's JAR.  It's freely available and on CPAN (
http://search.cpan.org/dist/PAR/ ).

=end original

The Perl Archive Toolkit ( http://par.perl.org/ ) は Java における
JAR のような Perl 版の類似物です。
自由に利用可能で、CPAN にあります ( http://search.cpan.org/dist/PAR/ )。

=begin original

There are also some commercial products that may work for you, although
you have to buy a license for them.

=end original

役に立つかもしれないいくつかの商用製品もありますが、それらのライセンスを
購入する必要があります。

=begin original

The Perl Dev Kit ( http://www.activestate.com/Products/Perl_Dev_Kit/ )
from ActiveState can "Turn your Perl programs into ready-to-run
executables for HP-UX, Linux, Solaris and Windows."

=end original

ActiveState の The Perl Dev Kit
( http://www.activestate.com/Products/Perl_Dev_Kit/ ) は
「あなたの Perl プログラムを HP-UX, Linux, Solaris, Windows 用の実行
ファイルに変換します。」

=begin original

Perl2Exe ( http://www.indigostar.com/perl2exe.htm ) is a command line
program for converting perl scripts to executable files.  It targets both
Windows and unix platforms.

=end original

Perl2Exe ( http://www.indigostar.com/perl2exe.htm ) は perl スクリプトを
実行可能ファイルに変換するコマンドラインプログラムです。
これは Windows と unix プラットフォームの両方を対象としています。

=head2 How can I get C<#!perl> to work on [MS-DOS,NT,...]?

(MS-DOS, NT, etc で '#!perl' が動作するようにするには?)

=begin original

For OS/2 just use

=end original

OS/2 では単に:

    extproc perl -S -your_switches

=begin original

as the first line in C<*.cmd> file (C<-S> due to a bug in cmd.exe's
"extproc" handling).  For DOS one should first invent a corresponding
batch file and codify it in C<ALTERNATE_SHEBANG> (see the
F<dosish.h> file in the source distribution for more information).

=end original

C<(*.cmd> ファイルの先頭をこのようにするだけです(C<-S> は、
cmd.exe の "extproc" に関するバグのためです)。
DOS の場合は、適切なバッチファイルを作って C<ALTERNATE_SHEBANG> を
行うべきでしょう(詳細は、ソース配布キットにある F<dosish.h> という
ファイルを参照してください)。

=begin original

The Win95/NT installation, when using the ActiveState port of Perl,
will modify the Registry to associate the C<.pl> extension with the
perl interpreter.  If you install another port, perhaps even building
your own Win95/NT Perl from the standard sources by using a Windows port
of gcc (e.g., with cygwin or mingw32), then you'll have to modify
the Registry yourself.  In addition to associating C<.pl> with the
interpreter, NT people can use: C<SET PATHEXT=%PATHEXT%;.PL> to let them
run the program C<install-linux.pl> merely by typing C<install-linux>.

=end original

Windows 95 や Windows NT で ActiveState の移植した Perl を使うのなら、
これは C<.pl> という拡張子を perl インタプリタに関連づけるように
レジストリを変更します。
その他の移植になる perl を使うか、あるいはあなた自身が Windows に
移植された gcc(cygwin や mingw)を使って標準ソースから Perl を
ビルドするというのであれば自分自身でレジストリを変更する必要があるでしょう。
C<.pl> とインタプリタを関連づけることによって、NT を使っている
人は C<install-linux.pl> を C<install-linux> のように起動することが
可能です。
NT では C<SET PATHEXT=%PATHEXT%;.PL> のようにします。

=begin original

Under "Classic" MacOS, a perl program will have the appropriate Creator and
Type, so that double-clicking them will invoke the MacPerl application.
Under Mac OS X, clickable apps can be made from any C<#!> script using Wil
Sanchez' DropScript utility: http://www.wsanchez.net/software/ .

=end original

"Classic" MacOS では、perl のプログラムは適切な Creator と Type とを
持っているでしょうから、ダブルクリックするだけで
MacPerl アプリケーションが起動するでしょう。
Mac OS X では、クリックできるアプリケーションは Wil Sanchez の DropScript
utility: http://www.wsanchez.net/software/ を使って任意の C<#!> 
スクリプトから作成できます。

=begin original

I<IMPORTANT!>: Whatever you do, PLEASE don't get frustrated, and just
throw the perl interpreter into your cgi-bin directory, in order to
get your programs working for a web server.  This is an EXTREMELY big
security risk.  Take the time to figure out how to do it correctly.

=end original

B<重要!>: あなたが何をするにしても、どうか不満を感じないでください。
そして、あなたのプログラムが web サーバのために動作するようにさせるために
perl インタプリタを cgi-bin ディレクトリに放り込むようなことは
しないでください。
これは B<非常に> 大きなセキュリティ上のリスクとなります。
正しく動作させるための方法を考えるための時間を取ってください。

=head2 Can I write useful Perl programs on the command line?

(コマンドライン上で便利な Perl プログラムを書けますか?)

=begin original

Yes.  Read L<perlrun> for more information.  Some examples follow.
(These assume standard Unix shell quoting rules.)

=end original

はい。
詳しくはL<perlrun>を読んでください。
幾つかのサンプルを以下に挙げておきます(ここでは標準のUNIX シェル引用規則に
従っていると仮定します)。

    # sum first and last fields
    perl -lane 'print $F[0] + $F[-1]' *

    # identify text files
    perl -le 'for(@ARGV) {print if -f && -T _}' *

    # remove (most) comments from C program
    perl -0777 -pe 's{/\*.*?\*/}{}gs' foo.c

    # make file a month younger than today, defeating reaper daemons
    perl -e '$X=24*60*60; utime(time(),time() + 30 * $X,@ARGV)' *

    # find first unused uid
    perl -le '$i++ while getpwuid($i); print $i'

    # display reasonable manpath
    echo $PATH | perl -nl -072 -e '
	s![^/+]*$!man!&&-d&&!$s{$_}++&&push@m,$_;END{print"@m"}'

=begin original

OK, the last one was actually an Obfuscated Perl Contest entry. :-)

=end original

そう、最後のは Obfuscated Perl コンテストにエントリーされてましたね :-)

=head2 Why don't Perl one-liners work on my DOS/Mac/VMS system?

(なぜ私の DOS/Mac/VMS システムでは一行野郎は動かないのでしょうか?)

=begin original

The problem is usually that the command interpreters on those systems
have rather different ideas about quoting than the Unix shells under
which the one-liners were created.  On some systems, you may have to
change single-quotes to double ones, which you must I<NOT> do on Unix
or Plan9 systems.  You might also have to change a single % to a %%.

=end original

この問題は、そういったシステムのコマンドインタプリタが、
一行野郎が作られた環境であるUNIXのシェルの引用規則とは異なるこということです。
一部のシステムでは、シングルクォートをダブルクォートに変更する必要が
あるかもしれません(これは UNIX や Plan9 といったシステムでは
B<してはいけません>)。
同様に、%を%%に変更する必要もあるかもしれません。

=begin original

For example:

=end original

例を挙げましょう:

    # Unix (including Mac OS X)
    perl -e 'print "Hello world\n"'

    # DOS, etc.
    perl -e "print \"Hello world\n\""

    # Mac Classic
    print "Hello world\n"
     (then Run "Myscript" or Shift-Command-R)

    # MPW
    perl -e 'print "Hello world\n"'

    # VMS
    perl -e "print ""Hello world\n"""

=begin original

The problem is that none of these examples are reliable: they depend on the
command interpreter.  Under Unix, the first two often work. Under DOS,
it's entirely possible that neither works.  If 4DOS was the command shell,
you'd probably have better luck like this:

=end original

問題は、これらの例の中に信頼できるものがないということです:
コマンドインタープリタに依存します。
UNIX では、最初の二つはほとんどの場合動作するでしょう。
DOS では、どれも働かないかもしれません。
4DOS をコマンドシェルとしているのなら、以下のようにするのがよいと思います:

  perl -e "print <Ctrl-x>"Hello world\n<Ctrl-x>""

=begin original

Under the Mac, it depends which environment you are using.  The MacPerl
shell, or MPW, is much like Unix shells in its support for several
quoting variants, except that it makes free use of the Mac's non-ASCII
characters as control characters.

=end original

Mac では、あなたが使っている環境に依存します。
MacPerl シェルや MPW は、制御キャラクターのような Mac の
非 ASCII キャラクターが自由に使えるという点を除いて、
UNIX シェルのように数種類の引用規則をサポートします。

=begin original

Using qq(), q(), and qx(), instead of "double quotes", 'single
quotes', and `backticks`, may make one-liners easier to write.

=end original

ダブルクォート(")、シングルクォート(')、バッククォート(`)の
代わりに qq(), q(), qx() をそれぞれ使います。
これによって一行野郎を書くことが簡単になるかもしれません。

=begin original

There is no general solution to all of this.  It is a mess.

=end original

この件全てに関する一般的な解決策はありません。
ごちゃごちゃです。

=begin original

[Some of this answer was contributed by Kenneth Albanowski.]

=end original

[この回答の一部はKenneth Albanowskiから寄せられました]

=head2 Where can I learn about CGI or Web programming in Perl?

(Perl による CGI や Web プログラミングについてどこで学べますか?)

=begin original

For modules, get the CGI or LWP modules from CPAN.  For textbooks,
see the two especially dedicated to web stuff in the question on
books.  For problems and questions related to the web, like "Why
do I get 500 Errors" or "Why doesn't it run from the browser right
when it runs fine on the command line", see the troubleshooting
guides and references in L<perlfaq9> or in the CGI MetaFAQ:

=end original

モジュールなら、CPAN から CGI モジュールや LWP モジュールを入手しましょう。
教科書なら、本にある web stuff の特に決定的な二つを参照しましょう。
“Why do I get 500 Errors” (なんで 500 Errors になるの)
“Why doesn't it run from the browser right when it runs fine on the command line”
(なぜコマンドラインからだとちゃんと動くのに、ブラウザーからだと
だめなんでしょうか)のように web に関連する問題や疑問は
L<perlfaq9> か CGI MetaFAQ を参照してください:

	http://www.perl.org/CGI_MetaFAQ.html

=head2 Where can I learn about object-oriented Perl programming?

(オブジェクト指向の Perl プログラミングはどこで学べますか?)

=begin original

A good place to start is L<perltoot>, and you can use L<perlobj>,
L<perlboot>, L<perltoot>, L<perltooc>, and L<perlbot> for reference.

=end original

始めるにはよい場所は L<perltoot>です。
リファレンスとしてL<perlobj>, L<perlboot>, <perltooc>,
<perlbot> が使えます。

=begin original

A good book on OO on Perl is the "Object-Oriented Perl"
by Damian Conway from Manning Publications, or "Intermediate Perl"
by Randal Schwartz, brian d foy, and Tom Phoenix from O'Reilly Media.

=end original

Perl でのオブジェクト指向に関するよい本は Manning Publications が
出版する Damian Conway による "Object-Oriented Perl" か、
O'Reilly Media が出版する Randal Schwartz, brian d foy,
Tom Phoenix による "Intermediate Perl" です。

=head2 Where can I learn about linking C with Perl?

(C と Perl のリンクについてはどこで学べますか?)

=begin original

If you want to call C from Perl, start with L<perlxstut>,
moving on to L<perlxs>, L<xsubpp>, and L<perlguts>.  If you want to
call Perl from C, then read L<perlembed>, L<perlcall>, and
L<perlguts>.  Don't forget that you can learn a lot from looking at
how the authors of existing extension modules wrote their code and
solved their problems.

=end original

もし Perl から C を呼び出したいのなら、L<perlxstut> から始めて L<perlxs>, 
L<xsubpp>, L<perlguts> へと進みます。
C から Perl を呼び出したいのなら、L<perlembed>, L<perlcall>, L<perlguts> を
読みましょう。
すでにあるエクステンションの作者がどのようにそれを記述し、
どのように彼らの問題を解決したのかを見ることで多くのことが
学べるのだということを忘れないでください。

=begin original

You might not need all the power of XS. The Inline::C module lets
you put C code directly in your Perl source. It handles all the
magic to make it work. You still have to learn at least some of
the perl API but you won't have to deal with the complexity of the
XS support files.

=end original

XS の力の全てが必要なわけではないかもしれません。
The Inline::C モジュールは Perl のソースの中に C のコードを直接書くことが
できます。
これはこれが動作するための全ての魔法を扱います。
それでも少なくとも perl API の一部は学習する必要がありますが、XS サポート
ファイルの複雑を扱う必要はありません。

=head2 I've read perlembed, perlguts, etc., but I can't embed perl in my C program; what am I doing wrong?

(perlembed や perlguts なんかを読んだのだけど、私の C プログラムに perl を組み込めません。何が悪いのでしょうか?)

=begin original

Download the ExtUtils::Embed kit from CPAN and run `make test'.  If
the tests pass, read the pods again and again and again.  If they
fail, see L<perlbug> and send a bug report with the output of
C<make test TEST_VERBOSE=1> along with C<perl -V>.

=end original

CPAN から ExtUtils::Embed キットをダウンロードして、`make test'を
実行してください。
もしこのテストに合格したのなら、pod を何度も何度もくり返しくり返し
読んでください。
テストに失敗したなら、L<perlbug> を読んで、C<perl -V> の出力と
C<make test TEST_VERBOSE=1> の出力を添付してバグレポートを送ってください。

=head2 When I tried to run my script, I got this message. What does it mean?

(私のスクリプトを実行したとき、こんなメッセージを受け取りました。これって何を意味しているのでしょうか?)

=begin original

A complete list of Perl's error messages and warnings with explanatory
text can be found in L<perldiag>. You can also use the splain program
(distributed with Perl) to explain the error messages:

=end original

perl のすべてのエラーメッセージ、警告メッセージの説明テキスト付きのリストが
L<perldiag> にあります。
エラーメッセージを説明するために、splain プログラムを
使うこともできます(これは Perl と一緒に配布されています)。

    perl program 2>diag.out
    splain [-v] [-p] diag.out

=begin original

or change your program to explain the messages for you:

=end original

あるいは、メッセージを説明的にするようにプログラムを変更します。

    use diagnostics;

=begin original

or

=end original

あるいはこう:

    use diagnostics -verbose;

=head2 What's MakeMaker?

(MakeMaker ってなんですか?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

The C<ExtUtils::MakeMaker> module, better known simply as "MakeMaker",
turns a Perl script, typically called C<Makefile.PL>, into a Makefile.
The unix tool C<make> uses this file to manage dependencies and actions
to process and install a Perl distribution.

=end original

C<ExtUtils::MakeMaker> モジュール(単に "MakeMaker" として知られています)は
Perl スクリプト(典型的には C<Makefile.PL> と呼ばれます) を Makefile に
変換します。
unix ツールの C<make> は、Perl 配布パッケージの処理とインストールのために
依存性と作業を管理するためにこのファイルを使います。

=head1 REVISION

Revision: $Revision: 10127 $

Date: $Date: 2007-10-27 21:40:20 +0200 (Sat, 27 Oct 2007) $

See L<perlfaq> for source control details and availability.

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples here are in the public
domain.  You are permitted and encouraged to use this code and any
derivatives thereof in your own programs for fun or for profit as you
see fit.  A simple comment in the code giving credit to the FAQ would
be courteous but is not required.
