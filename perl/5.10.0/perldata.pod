
=encoding euc-jp

=head1 NAME

=begin original

perldata - Perl data types

=end original

perldata - Perl のデータ型

=head1 DESCRIPTION

=head2 Variable names
X<variable, name> X<variable name> X<data type> X<type>

(変数名)

=begin original

Perl has three built-in data types: scalars, arrays of scalars, and
associative arrays of scalars, known as "hashes".  A scalar is a 
single string (of any size, limited only by the available memory),
number, or a reference to something (which will be discussed
in L<perlref>).  Normal arrays are ordered lists of scalars indexed
by number, starting with 0.  Hashes are unordered collections of scalar 
values indexed by their associated string key.

=end original

Perl には、スカラ、スカラの配列、「ハッシュ」とも呼ばれるスカラの
連想配列という 3 つの組み込みデータ型があります。
スカラは単一の(任意の長さの)文字列(利用可能メモリによってのみ制限されます)か、
数値か、何かへのリファレンス(これは L<perlref> で議論します)のいずれかです。
通常の配列は 0 を基点とする数値で添え字づけされるスカラの順序付き
リストです。
ハッシュ配列は、文字列のキーのインデックスと、それに結び付けられた
スカラ値の、順序のない集合です。

=begin original

Values are usually referred to by name, or through a named reference.
The first character of the name tells you to what sort of data
structure it refers.  The rest of the name tells you the particular
value to which it refers.  Usually this name is a single I<identifier>,
that is, a string beginning with a letter or underscore, and
containing letters, underscores, and digits.  In some cases, it may
be a chain of identifiers, separated by C<::> (or by the slightly
archaic C<'>); all but the last are interpreted as names of packages,
to locate the namespace in which to look up the final identifier
(see L<perlmod/Packages> for details).  It's possible to substitute
for a simple identifier, an expression that produces a reference
to the value at runtime.   This is described in more detail below
and in L<perlref>.
X<identifier>

=end original

値は通常、名前もしくは名前付きのリファレンスを通して参照されます。
名前の最初にある文字は、その名前がどのような構造のデータを
参照しているのかを区別します。
名前の残りの部分は、参照する値を特定するものです。
通常、この名前は一つの I<識別子>、つまり、英字か下線から始まって
それに英字、下線、数字が続く文字列のことです。
一部のケースにおいては C<::>(あるいはやや古風な C<'>) で分けられた
識別子の並びであってもかまいません。
これの最後のもの以外の名前は、最後の部分にある識別子を
その名前空間に置くためのパッケージの名前として解釈されます
(詳細は L<perlmod/Packages> を参照してください)。
リファレンスを生成する式の単純な識別子を、実行に値に置き換えることも
可能です。
これはこの文書の後の部分と、L<perlref> に詳細な説明があります。
X<identifier>

=begin original

Perl also has its own built-in variables whose names don't follow
these rules.  They have strange names so they don't accidentally
collide with one of your normal variables.  Strings that match
parenthesized parts of a regular expression are saved under names
containing only digits after the C<$> (see L<perlop> and L<perlre>).
In addition, several special variables that provide windows into
the inner working of Perl have names containing punctuation characters
and control characters.  These are documented in L<perlvar>.
X<variable, built-in>

=end original

Perl はこれらの規則に従っていない名前を持っている組み込みの変数も
持っています。
これらは変わった名前をもっているので、あなたが使った普通の
変数との間で間違って衝突することがありません。
正規表現の括弧づけされた部分(parenthesized parts)の文字列は C<$> の後に
数字だけが続いている名前で保存されます( L<perlop> と L<perlre> を
参照してください)。
それに加え、Perl の内部的な動作に対する窓を開けている幾つかの
特殊変数が、句読点文字と制御文字を含む名前を持っています。
これらは L<perlvar> で文書化されています。
X<variable, built-in>

=begin original

Scalar values are always named with '$', even when referring to a
scalar that is part of an array or a hash.  The '$' symbol works
semantically like the English word "the" in that it indicates a
single value is expected.
X<scalar>

=end original

スカラ値の参照は、配列やハッシュの一要素であるスカラを参照する場合でも、
常に名前に '$' を付けます。
シンボル '$' は文法的に英単語 "the" のように働き、単一の値が
想定されていることを示しています。
X<scalar>

    $days		# the simple scalar value "days"
    $days[28]		# the 29th element of array @days
    $days{'Feb'}	# the 'Feb' value from hash %days
    $#days		# the last index of array @days

=begin original

Entire arrays (and slices of arrays and hashes) are denoted by '@',
which works much like the word "these" or "those" does in English,
in that it indicates multiple values are expected.
X<array>

=end original

配列全体(および配列やハッシュのスライス)は '@' で示します;
これは英単語での "these" や "those" のように働き、複数の値が
想定されていることを示します。
X<array>

    @days		# ($days[0], $days[1],... $days[n])
    @days[3,4,5]	# same as ($days[3],$days[4],$days[5])
    @days{'a','c'}	# same as ($days{'a'},$days{'c'})

=begin original

Entire hashes are denoted by '%':
X<hash>

=end original

ハッシュ全体は '%' で示します:
X<hash>

    %days		# (key1, val1, key2, val2 ...)

=begin original

In addition, subroutines are named with an initial '&', though this
is optional when unambiguous, just as the word "do" is often redundant
in English.  Symbol table entries can be named with an initial '*',
but you don't really care about that yet (if ever :-).

=end original

さらに、サブルーチンは名前の前に '&' を付けて示しますが、英語でもほとんど
使われなくなった "do" のように、曖昧にならなければ、省略できます。
シンボルテーブルのエントリは、名前に '*' を付けて示すことができますが、
(気にする気があっても :-)まだ気にする必要はありません。

=begin original

Every variable type has its own namespace, as do several
non-variable identifiers.  This means that you can, without fear
of conflict, use the same name for a scalar variable, an array, or
a hash--or, for that matter, for a filehandle, a directory handle, a
subroutine name, a format name, or a label.  This means that $foo
and @foo are two different variables.  It also means that C<$foo[1]>
is a part of @foo, not a part of $foo.  This may seem a bit weird,
but that's okay, because it is weird.
X<namespace>

=end original

変数のすべての型には、いくつかの変数でない識別子と同様、
それぞれの名前空間があります。
これは、衝突を心配せずに、スカラ変数、配列、ハッシュ -- さらに
ファイルハンドル、ディレクトリハンドル、サブルーチン名、フォーマット名、
ラベルに、同じ名前を付けることができることを意味します。
つまり、C<$foo> と C<@foo> は 2 つの異なる変数であるということです。
また、C<$foo[1]> は C<@foo> の一部であって、C<$foo> の一部ではありません。
少々奇妙に思えるかもしれませんが、それで良いのです;
奇妙なのですから。
X<namespace>

=begin original

Because variable references always start with '$', '@', or '%', the
"reserved" words aren't in fact reserved with respect to variable
names.  They I<are> reserved with respect to labels and filehandles,
however, which don't have an initial special character.  You can't
have a filehandle named "log", for instance.  Hint: you could say
C<open(LOG,'logfile')> rather than C<open(log,'logfile')>.  Using
uppercase filehandles also improves readability and protects you
from conflict with future reserved words.  Case I<is> significant--"FOO",
"Foo", and "foo" are all different names.  Names that start with a
letter or underscore may also contain digits and underscores.
X<identifier, case sensitivity>
X<case>

=end original

変数の参照は、いつも '$'、'@'、'%' で始まりますから、「予約」語は、
変数名としては、本当の意味で予約されているわけではありません。
しかしながら、先頭に特別な文字を付けない、ラベルやファイルハンドルとしては、
I<予約されている> ことになります。
たとえば、"log" といった名前のファイルハンドルを使うことはできません。
ヒント: C<open(log,'logfile')> などではなく、
C<open(LOG,'logfile')> としてください。
大文字のファイルハンドルを使えば、読みやすくもなりますし、
将来に渡る予約語との衝突も避けられます。
大文字と小文字は B<区別されます> から、"FOO"、"Foo"、"foo" は、
すべて違う名前です。
英字と下線で始まる名前は、名前の一部に数字や下線を
含むことができます。
X<identifier, case sensitivity>
X<case>

=begin original

It is possible to replace such an alphanumeric name with an expression
that returns a reference to the appropriate type.  For a description
of this, see L<perlref>.

=end original

そのような英数字の名前を、適切な型へのリファレンスを返す式で
置き換えることも可能です。
詳しくは、L<perlref> を参照してください。

=begin original

Names that start with a digit may contain only more digits.  Names
that do not start with a letter, underscore, digit or a caret (i.e.
a control character) are limited to one character, e.g.,  C<$%> or
C<$$>.  (Most of these one character names have a predefined
significance to Perl.  For instance, C<$$> is the current process
id.)

=end original

数字で始まる名前には、数字しか含めることができません。
英字、下線、数字、キャレット(制御文字)以外の文字で始まる名前は、
C<$%> や C<$$> のように 1 文字に限定されます(これら 1 文字の名前の多くは、
Perl があらかじめ意味を定めています。
たとえば、C<$$> はカレントプロセスのプロセス ID を示します)。

=head2 Context
X<context> X<scalar context> X<list context>

(コンテキスト)

=begin original

The interpretation of operations and values in Perl sometimes depends
on the requirements of the context around the operation or value.
There are two major contexts: list and scalar.  Certain operations
return list values in contexts wanting a list, and scalar values
otherwise.  If this is true of an operation it will be mentioned in
the documentation for that operation.  In other words, Perl overloads
certain operations based on whether the expected return value is
singular or plural.  Some words in English work this way, like "fish"
and "sheep".

=end original

Perl における演算や値の解釈は、その演算や値の置かれたコンテキストからの
要求に依存する場合があります。
このコンテキストというものには大きく二つあり、リストコンテキストと
スカラコンテキストと呼ばれます。
リストが要求されるコンテキストではリスト値を返し、
そうでなければスカラ値を返すような演算も存在します。
そのような演算については、ドキュメントでその演算に触れるときに
付記しています。
言い方を変えると、Perl では、ある種の演算が一つの値を返して欲しいか、
複数の値を返して欲しいかによって多重定義されているということです。
"fish" や "sheep" といった、単複同形の英単語と似ているかもしれません。

=begin original

In a reciprocal fashion, an operation provides either a scalar or a
list context to each of its arguments.  For example, if you say

=end original

逆に演算子は、その引数がスカラコンテキストかリストコンテキストの
いずれかで解釈されるかを決めてしまいます。
例えば、以下のようにすると:

    int( <STDIN> )

=begin original

the integer operation provides scalar context for the <>
operator, which responds by reading one line from STDIN and passing it
back to the integer operation, which will then find the integer value
of that line and return that.  If, on the other hand, you say

=end original

int 演算子は、自分の引数である <> 演算子がスカラコンテキストで
評価されることを期待するため、STDIN から一行を読み出して
int 演算子に渡します。
int 演算子は、その行から整数値を取り出して返すことになります。
これに対して、以下のようにすると:

    sort( <STDIN> )

=begin original

then the sort operation provides list context for <>, which
will proceed to read every line available up to the end of file, and
pass that list of lines back to the sort routine, which will then
sort those lines and return them as a list to whatever the context
of the sort was.

=end original

sort 演算子は <> 演算子がリストコンテキストで評価されるために 、
<> は STDIN から読める限り最後の行まで読み出して、
そのリストを sort のルーチンに渡します。
sort ルーチンは受け取った行のリストをソートし、その結果のリストが
戻り値となります。

=begin original

Assignment is a little bit special in that it uses its left argument
to determine the context for the right argument.  Assignment to a
scalar evaluates the right-hand side in scalar context, while
assignment to an array or hash evaluates the righthand side in list
context.  Assignment to a list (or slice, which is just a list
anyway) also evaluates the righthand side in list context.

=end original

代入演算は少し特殊です。
代入では、右引数のコンテキストを決めるために左引数が使われます。
スカラへの代入では、右側をスカラコンテキストで評価しますが、
配列やハッシュに対する代入では、右側をリストコンテキストで
評価することになります。
リスト(あるいはスライス; 要するにリストですが)への代入も、
右側をリストコンテキストで評価することになります。

=begin original

When you use the C<use warnings> pragma or Perl's B<-w> command-line 
option, you may see warnings
about useless uses of constants or functions in "void context".
Void context just means the value has been discarded, such as a
statement containing only C<"fred";> or C<getpwuid(0);>.  It still
counts as scalar context for functions that care whether or not
they're being called in list context.

=end original

C<use warnings> プラグマや Perl の B<-w> コマンドラインオプションを使うと、
「無効コンテキスト」での定数や関数の無意味な使用について警告が出ます。
無効コンテキストは、C<"fred";> や C<getpwuid(0);> のみを含む文のように、
単に値が捨てられることを意味します。
リストコンテキストで呼び出されたかどうかを考慮する関数にとっては、
これはやはりスカラコンテキストとして扱われます。

=begin original

User-defined subroutines may choose to care whether they are being
called in a void, scalar, or list context.  Most subroutines do not
need to bother, though.  That's because both scalars and lists are
automatically interpolated into lists.  See L<perlfunc/wantarray>
for how you would dynamically discern your function's calling
context.

=end original

ユーザが定義するサブルーチンは、自分が無効、スカラ、リストのどの
コンテキストで呼ばれたかを意識することができます。
しかし、多くのサブルーチンでは意識する必要もないでしょう。
スカラ値とリストは自動的にリストに展開されるからです。
関数が呼び出されたコンテキストを動的に識別する方法については、
L<perlfunc/wantarray> を参照してください。

=head2 Scalar values
X<scalar> X<number> X<string> X<reference>

(スカラ値)

=begin original

All data in Perl is a scalar, an array of scalars, or a hash of
scalars.  A scalar may contain one single value in any of three
different flavors: a number, a string, or a reference.  In general,
conversion from one form to another is transparent.  Although a
scalar may not directly hold multiple values, it may contain a
reference to an array or hash which in turn contains multiple values.

=end original

Perlにおける全てのデータは、スカラか、スカラの配列か、スカラの
ハッシュとなります。
スカラは、数値、文字列、リファレンスのいずれか一つの値を保持します。
一般的には、ある種類から他の種類への変換は透過的です。
スカラは直接複数の値を保持することはできませんが、複数の値を保持している
配列やハッシュに対するリファレンスを保持することができます。

=begin original

Scalars aren't necessarily one thing or another.  There's no place
to declare a scalar variable to be of type "string", type "number",
type "reference", or anything else.  Because of the automatic
conversion of scalars, operations that return scalars don't need
to care (and in fact, cannot care) whether their caller is looking
for a string, a number, or a reference.  Perl is a contextually
polymorphic language whose scalars can be strings, numbers, or
references (which includes objects).  Although strings and numbers
are considered pretty much the same thing for nearly all purposes,
references are strongly-typed, uncastable pointers with builtin
reference-counting and destructor invocation.

=end original

スカラは何かであることを宣言する必要はありません。
あるスカラ変数が、「文字列」型、「数値」型、「リファレンス」型、
あるいはその他の型であるように宣言する方法はありません。
これは、スカラ、スカラを返す操作の自動変換はその呼び出し元が
文字列、数値、リファレンスのどれを対象にしているのかを気に
する必要がない(実際は、気にすることができない)ためです。
Perl はスカラが文字列、数値、リファレンス (オブジェクトを含みます)を
保持することのできる文脈的多態言語
(contextually polymorphic language) です。
文字列と数値は、ほとんど全ての目的に対して適当であるように思われますが、
リファレンスは組み込みのリファレンスカウントとデストラクタとを
持っている、キャストすることのできない強く型付けされたポインタです。

=begin original

A scalar value is interpreted as TRUE in the Boolean sense if it is not
the null string or the number 0 (or its string equivalent, "0").  The
Boolean context is just a special kind of scalar context where no 
conversion to a string or a number is ever performed.
X<boolean> X<bool> X<true> X<false> X<truth>

=end original

スカラ値は、その値が空文字列か数値の 0 (あるいは同値な文字列 "0")
以外の場合には、真偽値の真として扱われます。
真偽値コンテキストは、単に文字列や数値への変換が行われなかった
特別なスカラコンテキストとして扱われます。
X<boolean> X<bool> X<true> X<false> X<truth>

=begin original

There are actually two varieties of null strings (sometimes referred
to as "empty" strings), a defined one and an undefined one.  The
defined version is just a string of length zero, such as C<"">.
The undefined version is the value that indicates that there is
no real value for something, such as when there was an error, or
at end of file, or when you refer to an uninitialized variable or
element of an array or hash.  Although in early versions of Perl,
an undefined scalar could become defined when first used in a
place expecting a defined value, this no longer happens except for
rare cases of autovivification as explained in L<perlref>.  You can
use the defined() operator to determine whether a scalar value is
defined (this has no meaning on arrays or hashes), and the undef()
operator to produce an undefined value.
X<defined> X<undefined> X<undef> X<null> X<string, null>

=end original

空文字列には、実は定義済みと未定義の 2 種類があります。
定義済みの値は C<""> のような、単に長さ 0 の文字列です。
未定義の空文字列は、エラーがあったときや、ファイルの終わりに達したとき、
初期化していない変数や配列やハッシュの要素を参照したときなど、
何かに対する実際の値が存在しないことを示します。
初期のバージョンの Perl では、未定義のスカラは、最初に定義済みで
あるかのように使ったときに定義済みとなり得ますが、これはもはや、
L<perlref> で説明している自動有効化が起きる稀な場合を除いて、起こりません。
値が定義済みであるかどうかを調べるために defined() 演算子を
使うことができ(これは配列やハッシュに対しては無意味です)、
未定義値を生成するために undef() 演算子を使えます。
X<defined> X<undefined> X<undef> X<null> X<string, null>

=begin original

To find out whether a given string is a valid non-zero number, it's
sometimes enough to test it against both numeric 0 and also lexical
"0" (although this will cause noises if warnings are on).  That's 
because strings that aren't numbers count as 0, just as they do in B<awk>:

=end original

与えられた文字列が正当な非ゼロの数値であるかどうかを確かめるには、
数値の 0 か lexical な "0" に対してテストすれば十分な場合もあります
(もっともこれは警告が有効ならノイズを引き起こします)。
数値ではない文字列は、B<awk> のように 0 とはみなすことはしないからです:

    if ($str == 0 && $str ne "0")  {
	warn "That doesn't look like a number";
    }

=begin original

That method may be best because otherwise you won't treat IEEE
notations like C<NaN> or C<Infinity> properly.  At other times, you
might prefer to determine whether string data can be used numerically
by calling the POSIX::strtod() function or by inspecting your string
with a regular expression (as documented in L<perlre>).

=end original

このメソッドは最良です; なぜなら、さもなければ C<NaN> や
C<Infinity> のような IEEE 記法の 属性を扱えないからです。
その他の場合、データが数値であるかどうかを検査するためには、
POSIX::strtod() 関数を呼び出すか、(L<perlre> に記述されているように)
正規表現を使って文字列を調べるとよいでしょう。

    warn "has nondigits"	if     /\D/;
    warn "not a natural number" unless /^\d+$/;             # rejects -3
    warn "not an integer"       unless /^-?\d+$/;           # rejects +3
    warn "not an integer"       unless /^[+-]?\d+$/;
    warn "not a decimal number" unless /^-?\d+\.?\d*$/;     # rejects .2
    warn "not a decimal number" unless /^-?(?:\d+(?:\.\d*)?|\.\d+)$/;
    warn "not a C float"
	unless /^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/;

=begin original

The length of an array is a scalar value.  You may find the length
of array @days by evaluating C<$#days>, as in B<csh>.  However, this
isn't the length of the array; it's the subscript of the last element,
which is a different value since there is ordinarily a 0th element.
Assigning to C<$#days> actually changes the length of the array.
Shortening an array this way destroys intervening values.  Lengthening
an array that was previously shortened does not recover values
that were in those elements.  (It used to do so in Perl 4, but we
had to break this to make sure destructors were called when expected.)
X<$#> X<array, length>

=end original

配列の大きさはスカラ値です。
配列 @days の大きさは、csh のように $#days を評価するとわかります。
しかし、これは大きさではありません;
最後の要素に対する添え字になり、通常は 0 番目の要素があるので違う値に
なります。
$#days に代入を行なうと実際の配列の大きさも変化します。
この方法で配列を小さくすると、見えなくなった部分の値は破壊されます。
小さくした配列を再び大きくしても、以前存在した要素に対する前の値が
回復することはありません。
(Perl 4 では回復可能でしたが、デストラクタが期待通りの時点で
呼ばれることを保証するために、これを止めました。)
X<$#> X<array, length>

=begin original

You can also gain some minuscule measure of efficiency by pre-extending
an array that is going to get big.  You can also extend an array
by assigning to an element that is off the end of the array.  You
can truncate an array down to nothing by assigning the null list
() to it.  The following are equivalent:

=end original

大きくなるであろう配列をあらかじめ大きくしておくことで、
ほんの少しだけ効率を向上させることもできます。
最後の要素よりも後ろに離れた位置に代入を行なうことでも、
配列を大きくすることができます。
配列に空リスト () を代入すると、何も無い状態にまで切り詰められます。
以下の二つは等価です:

    @whatever = ();
    $#whatever = -1;

=begin original

If you evaluate an array in scalar context, it returns the length
of the array.  (Note that this is not true of lists, which return
the last value, like the C comma operator, nor of built-in functions,
which return whatever they feel like returning.)  The following is
always true:
X<array, length>

=end original

配列をスカラコンテキストで評価すると、配列の大きさが返されます。
(これはリストに対しては成り立たないことに注意してください。
この場合には、C のカンマ演算子と同じように最後の値が返され、
組み込み関数のように値を返すことはしません。)
以下の式は常に真となります:
X<array, length>

    scalar(@whatever) == $#whatever - $[ + 1;

=begin original

Version 5 of Perl changed the semantics of C<$[>: files that don't set
the value of C<$[> no longer need to worry about whether another
file changed its value.  (In other words, use of C<$[> is deprecated.)
So in general you can assume that
X<$[>

=end original

Perl バージョン 5 では C<$[> の意味を変更しました:
C<$[> を設定していないファイルにおいて、他のファイルがこの変数を
変更しているかどうかを心配する必要がなくなりました
(言い換えると、C<$[> は使わないほうが良いと言うことです)。
ですから、普通は以下のようになります。
X<$[>

    scalar(@whatever) == $#whatever + 1;

=begin original

Some programmers choose to use an explicit conversion so as to 
leave nothing to doubt:

=end original

一部のプログラマは、曖昧さをなくすために明示的に変換することを
選ぶでしょう:

    $element_count = scalar(@whatever);

=begin original

If you evaluate a hash in scalar context, it returns false if the
hash is empty.  If there are any key/value pairs, it returns true;
more precisely, the value returned is a string consisting of the
number of used buckets and the number of allocated buckets, separated
by a slash.  This is pretty much useful only to find out whether
Perl's internal hashing algorithm is performing poorly on your data
set.  For example, you stick 10,000 things in a hash, but evaluating
%HASH in scalar context reveals C<"1/16">, which means only one out
of sixteen buckets has been touched, and presumably contains all
10,000 of your items.  This isn't supposed to happen.  If a tied hash
is evaluated in scalar context, a fatal error will result, since this
bucket usage information is currently not available for tied hashes.
X<hash, scalar context> X<hash, bucket> X<bucket>

=end original

ハッシュをスカラコンテキストで評価した場合、ハッシュが空のときにだけ
偽が返されます。
キー/値のペアが登録されていれば、真を返します。
より正確には、返される値は使用しているエントリの数と、
割り付けられているエントリの数を、スラッシュで区切った文字列です。
これは、与えたデータに対して、Perl の内部のハッシュのアルゴリズムが、
うまく動作しないかを確認するときくらいにしか使えませんが。
たとえば、ハッシュに 10,000 個 のものを入れ、%HASH をスカラコンテキストで
評価したときに C<1/16> が得られれば、16 のうち一つのエントリだけが使われ、
おそらくそこに 10,000個 すべてが入っていることを意味します。
これはほとんど起こりそうもないことです。
tie したハッシュがスカラコンテキストで評価されると、この使用バケツ情報は
現在のところ tie したハッシュでは利用できないので、致命的エラーとなります。
X<hash, scalar context> X<hash, bucket> X<bucket>

=begin original

You can preallocate space for a hash by assigning to the keys() function.
This rounds up the allocated buckets to the next power of two:

=end original

keys() 関数に代入をすることによって、ハッシュのためにあらかじめ
スペースを割り当てることができます。
その際に、割り当てる要素の数はその数値以上で最小の 2 のべき乗に
丸められます:

=begin original

    keys(%users) = 1000;		# allocate 1024 buckets

=end original

    keys(%users) = 1000;		# 1024要素割り付ける

=head2 Scalar value constructors
X<scalar, literal> X<scalar, constant>

(スカラ値のコンストラクタ)

=begin original

Numeric literals are specified in any of the following floating point or
integer formats:

=end original

数値リテラルは、以下の浮動小数点数と整数の形式で示されます:

    12345
    12345.67
    .23E-10             # a very small number
    3.14_15_92          # a very important number
    4_294_967_296       # underscore for legibility
    0xff                # hex
    0xdead_beef         # more hex   
    0377                # octal (only numbers, begins with 0)
    0b011011            # binary

=begin original

You are allowed to use underscores (underbars) in numeric literals
between digits for legibility.  You could, for example, group binary
digits by threes (as for a Unix-style mode argument such as 0b110_100_100)
or by fours (to represent nibbles, as in 0b1010_0110) or in other groups.
X<number, literal>

=end original

数値リテラルを読みやすくするために、数字の間に下線を使えます。
例えば、(Unix 式のモード引数のために、0b110_100_100 のように) 2 進数を
3 桁ごとにグループ分けしたり、(ニブルを表現するために、0b1010_0110 のように)
4 桁ごとにグループ分けしたり、あるいはその他の方法でグループ分け出来ます。
X<number, literal>

=begin original

String literals are usually delimited by either single or double
quotes.  They work much like quotes in the standard Unix shells:
double-quoted string literals are subject to backslash and variable
substitution; single-quoted strings are not (except for C<\'> and
C<\\>).  The usual C-style backslash rules apply for making
characters such as newline, tab, etc., as well as some more exotic
forms.  See L<perlop/"Quote and Quote-like Operators"> for a list.
X<string, literal>

=end original

文字列リテラルは、シングルクォートかダブルクォートで区切られます。
これらは、標準 Unix シェルのクォートと同じように扱われます:
ダブルクォートの文字列リテラルでは、バックスラッシュの置換と
変数の置換が行なわれ、シングルクォートの文字列では、
(C<\'> と C<\\>を除いて)これらの置換は行なわれません。
普通の C 形式でのバックスラッシュの置換規則は、改行やタブを始め、ある種の
変わった形式のためにも使われます。
詳しくは L<perlop/"Quote and Quote-like Operators"> を参照してください。
X<string, literal>

=begin original

Hexadecimal, octal, or binary, representations in string literals
(e.g. '0xff') are not automatically converted to their integer
representation.  The hex() and oct() functions make these conversions
for you.  See L<perlfunc/hex> and L<perlfunc/oct> for more details.

=end original

文字列リテラルの中で ('0xff' のように) 16 進、8 進、2 進で
表現されたものは、その値が表すものに自動的に変換されることはありません。
hex() や oct() といった関数がそのための変換を行います。
詳しくは L<perlfunc/hex> と L<perlfunc/oct> を参照してください。

=begin original

You can also embed newlines directly in your strings, i.e., they can end
on a different line than they begin.  This is nice, but if you forget
your trailing quote, the error will not be reported until Perl finds
another line containing the quote character, which may be much further
on in the script.  Variable substitution inside strings is limited to
scalar variables, arrays, and array or hash slices.  (In other words,
names beginning with $ or @, followed by an optional bracketed
expression as a subscript.)  The following code segment prints out "The
price is $Z<>100."
X<interpolation>

=end original

また、文字列に直接、改行を埋め込むこともできます。
つまり、文字列は、開始した行で終了する必要はないと言うことです。
これは素晴らしいのですが、終了のクォートを付け忘れた場合には、
次にクォート文字が見つかるまでの間、Perl はエラーを
見つけることができなくなります。
それは、スクリプト上でずっと先になるかもしれません。
文字列中での変数の置換は、スカラ変数、配列、配列やハッシュのスライスに
限定されています(言い換えると、$ や@ で始まる識別子か、それに
大かっこで括った添え字をつけたものです)。
次のプログラムは "The price is $Z<>100." と印字します。
X<interpolation>

    $Price = '$100';	# not interpolated
    print "The price is $Price.\n";	# interpolated

=begin original

There is no double interpolation in Perl, so the C<$100> is left as is.

=end original

Perl では二重展開は行われないので、C<$100> はそのままになります。

=begin original

By default floating point numbers substituted inside strings use the
dot (".")  as the decimal separator.  If C<use locale> is in effect,
and POSIX::setlocale() has been called, the character used for the
decimal separator is affected by the LC_NUMERIC locale.
See L<perllocale> and L<POSIX>.

=end original

デフォルトでは、文字列に置換された浮動小数点数は小数点としてドット (".") を
使います。
C<use locale> が有効で、POSIX::setlocale() が呼び出されている場合、
小数点として使われる文字は LC_NUMERIC ロケールによって影響を受けます。
L<perllocale> と L<POSIX> を参照してください。

=begin original

As in some shells, you can enclose the variable name in braces to
disambiguate it from following alphanumerics (and underscores).
You must also do
this when interpolating a variable into a string to separate the
variable name from a following double-colon or an apostrophe, since
these would be otherwise treated as a package separator:
X<interpolation>

=end original

いくつかのシェルと同じように、変数名の前後に中かっこを入れて、
つながっている英数字(および下線)から切り離せます。
変数を文字列に展開する時に、後に続くコロン 2 つやシングルクォートと
変数名を分割する場合にもそうしなければなりません;
さもなければパッケージのセパレータとして扱われるからです:

    $who = "Larry";
    print PASSWD "${who}::0:0:Superuser:/:/bin/perl\n";
    print "We use ${who}speak when ${who}'s here.\n";

=begin original

Without the braces, Perl would have looked for a $whospeak, a
C<$who::0>, and a C<$who's> variable.  The last two would be the
$0 and the $s variables in the (presumably) non-existent package
C<who>.

=end original

中かっこなしでは、Perl は変数 $whospeak, C<$who::0>, C<$who's> を探します。
後ろ二つは、(おそらく)存在しないパッケージ C<who> の変数 $0 と $s に
なります。

=begin original

In fact, an identifier within such curlies is forced to be a string,
as is any simple identifier within a hash subscript.  Neither need
quoting.  Our earlier example, C<$days{'Feb'}> can be written as
C<$days{Feb}> and the quotes will be assumed automatically.  But
anything more complicated in the subscript will be interpreted as an
expression.  This means for example that C<$version{2.0}++> is
equivalent to C<$version{2}++>, not to C<$version{'2.0'}++>.

=end original

実際には、そのような中かっこの内側にある識別子は、ハッシュの添え字に
ある識別子と同様、強制的に文字列になります。
どちらもクォートは必要ありません。
先の例にあった、C<$days{'Feb'}> は C<$days{Feb}> のように書くことができ、
自動的にクォートが仮定されます。
しかし、添え字により複雑な何かを使っている場合には式として解釈されます。
これは例えば、C<$version{2.0}++> は C<$version{2}++> と等価であり、
C<$version{'2.0'}++> ではないということを意味します。

=head3 Version Strings
X<version string> X<vstring> X<v-string>

(バージョン文字列)

=begin original

B<Note:> Version Strings (v-strings) have been deprecated.  They will
be removed in some future release after Perl 5.8.1.  The marginal
benefits of v-strings were greatly outweighed by the potential for
Surprise and Confusion.

=end original

B<注意:> バージョン文字列 (v-文字列) は非推奨です。
これは Perl 5.8.1 以降のいつか未来のリリースで削除されます。
v-文字列のわずかな利点より、潜在的な驚きと混乱の方が大きく上回ります。

=begin original

A literal of the form C<v1.20.300.4000> is parsed as a string composed
of characters with the specified ordinals.  This form, known as
v-strings, provides an alternative, more readable way to construct
strings, rather than use the somewhat less readable interpolation form
C<"\x{1}\x{14}\x{12c}\x{fa0}">.  This is useful for representing
Unicode strings, and for comparing version "numbers" using the string
comparison operators, C<cmp>, C<gt>, C<lt> etc.  If there are two or
more dots in the literal, the leading C<v> may be omitted.

=end original

C<v1.20.300.4000> の形のリテラルは、指定された序数を持つ文字からなる
文字列としてパースされます。
この形はv-文字列と呼ばれ、より読みにくい文字変換形式
C<"\x{1}\x{14}\x{12c}\x{fa0}"> よりも読みやすい文字列を構成する方法を
提供します。
これは Unicode 文字列を表現するためや、バージョン「番号」を文字列比較
演算子  C<cmp>, C<gt>, C<lt> などを使って比較するときに便利です。
もしリテラルに 2 つ以上のドットがある場合、先頭の C<v> は省略できます。

    print v9786;              # prints SMILEY, "\x{263a}"
    print v102.111.111;       # prints "foo"
    print 102.111.111;        # same

=begin original

Such literals are accepted by both C<require> and C<use> for
doing a version check.  Note that using the v-strings for IPv4
addresses is not portable unless you also use the
inet_aton()/inet_ntoa() routines of the Socket package.

=end original

このようなリテラルは C<require> と C<use> でバージョンチェックを行う場合に
受け入れられます。
v-文字列を IPv4 アドレスに使うと、Socket パッケージの
inet_aton()/inet_ntoa() ルーチンも使わない限り、移植性がないことに
注意してください。

=begin original

Note that since Perl 5.8.1 the single-number v-strings (like C<v65>)
are not v-strings before the C<< => >> operator (which is usually used
to separate a hash key from a hash value), instead they are interpreted
as literal strings ('v65').  They were v-strings from Perl 5.6.0 to
Perl 5.8.0, but that caused more confusion and breakage than good.
Multi-number v-strings like C<v65.66> and C<65.66.67> continue to
be v-strings always.

=end original

Perl 5.8.1 から、 (C<v65> のような) 単一の数値のv-文字列は C<< => >> 演算子
(ハッシュキーとハッシュの値を分けるために普通使われます) の前では
v-文字列ではなく、リテラル文字列 ('v65') として扱われることに
注意してください。
これは Perl 5.6.0 から Perl 5.8.0 ではv-文字列でしたが、これはよいことよりも
大きな混乱と破壊を招きました。
C<v65.66> や C<65.66.67> のような複数の数値の v-文字列 は常にv-文字列で
あり続けます。

=head3 Special Literals
X<special literal> X<__END__> X<__DATA__> X<END> X<DATA>
X<end> X<data> X<^D> X<^Z>

(特殊なリテラル)

=begin original

The special literals __FILE__, __LINE__, and __PACKAGE__
represent the current filename, line number, and package name at that
point in your program.  They may be used only as separate tokens; they
will not be interpolated into strings.  If there is no current package
(due to an empty C<package;> directive), __PACKAGE__ is the undefined
value.
X<__FILE__> X<__LINE__> X<__PACKAGE__> X<line> X<file> X<package>

=end original

__FILE__, __LINE__, __PACKAGE__ という特殊なリテラルはそれぞれ、
カレントのファイル名、行番号、パッケージ名を表わします。
これらは独立したトークンとしてのみ用いられます;
文字列中に展開されることはありません。
(空の C<package;> 指示子によって)カレントパッケージが存在しない場合、
__PACKAGE__ は未定義値となります。
X<__FILE__> X<__LINE__> X<__PACKAGE__> X<line> X<file> X<package>

=begin original

The two control characters ^D and ^Z, and the tokens __END__ and __DATA__
may be used to indicate the logical end of the script before the actual
end of file.  Any following text is ignored.

=end original

二つの制御文字 ^D と ^Z、およびトークン __END__ と __DATA__ は、
実際のファイルの終端より前にある論理的なスクリプトの終端を示すために
使うことができます。
これらの後にあるテキストは無視されます。

=begin original

Text after __DATA__ but may be read via the filehandle C<PACKNAME::DATA>,
where C<PACKNAME> is the package that was current when the __DATA__
token was encountered.  The filehandle is left open pointing to the
contents after __DATA__.  It is the program's responsibility to
C<close DATA> when it is done reading from it.  For compatibility with
older scripts written before __DATA__ was introduced, __END__ behaves
like __DATA__ in the toplevel script (but not in files loaded with
C<require> or C<do>) and leaves the remaining contents of the
file accessible via C<main::DATA>.

=end original

しかし、__DATA__ 以降のテキストはファイルハンドル C<PACKAGE::DATA> を
通して読み出すことができます; ここで PACKNAME は __DATA__ トークンに
遭遇した時点でのカレントのパッケージ名です。
ファイルハンドルは __DATA__ の後の内容を指して開かれたままです。
ここからデータを読み終わったら C<close DATA> するのはプログラムの責任です。
__DATA__ が導入される前に書かれた古いスクリプトとの互換性のために、
__END__ は、スクリプト(但し C<require> や C<do> で読み込まれたファイルでは
ないもの)のトップレベルでの __DATA__ のように振る舞い、
ファイルの残りの内容は C<main::DATA> でアクセス可能なままになります。

=begin original

See L<SelfLoader> for more description of __DATA__, and
an example of its use.  Note that you cannot read from the DATA
filehandle in a BEGIN block: the BEGIN block is executed as soon
as it is seen (during compilation), at which point the corresponding
__DATA__ (or __END__) token has not yet been seen.

=end original

__DATA__ の詳細とそれをつかった例は L<SelfLoader> を参照してください。
BEGIN ブロックでは、ファイルハンドル DATA から読み出せないことに
注意してください。
BEGIN ブロックはそれが見つかった時点で即実行されるので、
__DATA__(や __END__)トークンがどこにあるのかがわからないのです。

=head3 Barewords
X<bareword>

(裸の単語)

=begin original

A word that has no other interpretation in the grammar will
be treated as if it were a quoted string.  These are known as
"barewords".  As with filehandles and labels, a bareword that consists
entirely of lowercase letters risks conflict with future reserved
words, and if you use the C<use warnings> pragma or the B<-w> switch, 
Perl will warn you about any
such words.  Some people may wish to outlaw barewords entirely.  If you
say

=end original

文法的に別の解釈ができない単語は、クォート文字列であるかのように
扱われます。
これは“裸の単語”(barewords)と呼ばれます。
ファイルハンドルやラベルと同様に、小文字だけからなる裸の単語は将来、
予約語とぶつかる危険があります。
そのような単語があった場合、C<use warnings> プラグマや
B<-w> スイッチをつけることでPerl がそのような単語を指摘してくれます。
裸の単語をなくして欲しいという人もいます。
以下のようにすると:

    use strict 'subs';

=begin original

then any bareword that would NOT be interpreted as a subroutine call
produces a compile-time error instead.  The restriction lasts to the
end of the enclosing block.  An inner block may countermand this
by saying C<no strict 'subs'>.

=end original

サブルーチンコールと解釈できない裸の単語がコンパイル時にエラーとなります。
この制約は囲っているブロックの終わりまで有効です。
内側のブロックで C<no strict 'subs'>と書くことで、この機能を
撤回することもできます。

=head3 Array Joining Delimiter
X<array, interpolation> X<interpolation, array> X<$">

(配列を結合するデリミタ)

=begin original

Arrays and slices are interpolated into double-quoted strings
by joining the elements with the delimiter specified in the C<$">
variable (C<$LIST_SEPARATOR> if "use English;" is specified), 
space by default.  The following are equivalent:

=end original

配列とスライスは、ダブルクォート文字列中で、要素を変数 <$"> 
("use English;" が指定されていれば C<$LIST_SEPARATOR>) 中に
示す区切り文字(デフォルトはスペース) でつなげて展開されます。
以下は等価です:

    $temp = join($", @ARGV);
    system "echo $temp";

    system "echo @ARGV";

=begin original

Within search patterns (which also undergo double-quotish substitution)
there is an unfortunate ambiguity:  Is C</$foo[bar]/> to be interpreted as
C</${foo}[bar]/> (where C<[bar]> is a character class for the regular
expression) or as C</${foo[bar]}/> (where C<[bar]> is the subscript to array
@foo)?  If @foo doesn't otherwise exist, then it's obviously a
character class.  If @foo exists, Perl takes a good guess about C<[bar]>,
and is almost always right.  If it does guess wrong, or if you're just
plain paranoid, you can force the correct interpretation with curly
braces as above.

=end original

検索パターン (ここでも、ダブルクォートのような置換が行なわれます) の中では、
解釈する上で不幸な曖昧さがあります。
C</$foo[bar]/> は、C</${foo}[bar]/> と解釈される
(この場合 C<[bar]>は、正規表現の文字クラス) のでしょうか?
C</${foo[bar]}/> と解釈される (この場合 C<[bar]> は、
配列 @foo の添え字) のでしょうか?
@foo が他に存在しない場合には、明らかに文字クラスとなります。
@foo が存在すれば、Perl が C<[bar]> の意味に見当をつけますが、たいてい
正しい解釈をします。
もし見当があたっていないときや偏執的にこだわりたい時には、上に
書いたように中かっこを付けて強制的に解釈のしかたを決めることができます。

=begin original

If you're looking for the information on how to use here-documents,
which used to be here, that's been moved to
L<perlop/Quote and Quote-like Operators>.

=end original

以前ここにあった、ヒアドキュメントの使い方に関する情報を探しているのなら、
その情報は L<perlop/Quote and Quote-like Operators> に移動しました。

=head2 List value constructors
X<list>

(リスト値のコンストラクター)

=begin original

List values are denoted by separating individual values by commas
(and enclosing the list in parentheses where precedence requires it):

=end original

リスト値は、個々の値をコンマで区切って (必要に応じて括弧で括って)
示されます:

    (LIST)

=begin original

In a context not requiring a list value, the value of what appears
to be a list literal is simply the value of the final element, as
with the C comma operator.  For example,

=end original

リスト値が要求されていないコンテキストでは、リストリテラルのように
みえる値の場合は、C のコンマ演算子の場合のように、単に最後の要素の
値が使われます。
例えば:

    @foo = ('cc', '-E', $bar);

=begin original

assigns the entire list value to array @foo, but

=end original

これはリスト値全体を配列 @foo に代入しますが:

    $foo = ('cc', '-E', $bar);

=begin original

assigns the value of variable $bar to the scalar variable $foo.
Note that the value of an actual array in scalar context is the
length of the array; the following assigns the value 3 to $foo:

=end original

これは変数 $bar の値をスカラ変数 $foo に代入します。
本物の配列がスカラコンテキストで評価されたときの値は、
その配列の大きさとなります。
以下の例では、$foo に 3 という値が代入されます:

    @foo = ('cc', '-E', $bar);
    $foo = @foo;                # $foo gets 3

=begin original

You may have an optional comma before the closing parenthesis of a
list literal, so that you can say:

=end original

リストリテラルの閉じ括弧の前には余分にコンマを置いてかまいませんので、
以下のように書くことができます:

    @foo = (
        1,
        2,
        3,
    );

=begin original

To use a here-document to assign an array, one line per element,
you might use an approach like this:

=end original

配列への代入にヒアドキュメントを使うには、要素毎に 1 行となり、
以下のような手法が使えます:

    @sauces = <<End_Lines =~ m/(\S.*\S)/g;
        normal tomato
        spicy tomato
        green chile
        pesto
        white wine
    End_Lines

=begin original

LISTs do automatic interpolation of sublists.  That is, when a LIST is
evaluated, each element of the list is evaluated in list context, and
the resulting list value is interpolated into LIST just as if each
individual element were a member of LIST.  Thus arrays and hashes lose their
identity in a LIST--the list

=end original

リストの中にリストがある場合には、自動的に展開されてしまいます。
これは、外側のリストが評価されると、リストの個々の要素がリストコンテキストで
評価され、その結果のリスト値の個々の値が、元のリストの要素であるかのように
展開されるのです。
つまり、リストの中では配列もハッシュも、その性質が現れてきません --
以下のリストは

    (@foo,@bar,&SomeSub,%glarch)

=begin original

contains all the elements of @foo followed by all the elements of @bar,
followed by all the elements returned by the subroutine named SomeSub 
called in list context, followed by the key/value pairs of %glarch.
To make a list reference that does I<NOT> interpolate, see L<perlref>.

=end original

@foo のすべての要素の後に @bar のすべての要素を続け、
その後に SomeSub というサブルーチンが返すすべての要素を続け、
最後に %glarch のキー/値のペアを続けたものを要素として持ちます。
展開 B<されない> リストのリファレンスを作るためには、L<perlref> を
参照してください。

=begin original

The null list is represented by ().  Interpolating it in a list
has no effect.  Thus ((),(),()) is equivalent to ().  Similarly,
interpolating an array with no elements is the same as if no
array had been interpolated at that point.

=end original

空リストは () で表わされます。
リスト中で空リストを展開しても何も起こりません。
つまり、 ((),(),()) は () と等価です。
同様に、要素のない配列を展開することは、その場所に何も
展開しなかったのと同じことになります。

=begin original

This interpolation combines with the facts that the opening
and closing parentheses are optional (except when necessary for
precedence) and lists may end with an optional comma to mean that
multiple commas within lists are legal syntax. The list C<1,,3> is a
concatenation of two lists, C<1,> and C<3>, the first of which ends
with that optional comma.  C<1,,3> is C<(1,),(3)> is C<1,3> (And
similarly for C<1,,,3> is C<(1,),(,),3> is C<1,3> and so on.)  Not that
we'd advise you to use this obfuscation.

=end original

この展開は、開きかっこと閉じかっこは(優先順位のための必要性がなければ)
省略可能であるということと、リスト中に複数のカンマがあっても文法的に
有効なので、リストの最後に追加のカンマをつけられるということを
組み合わせたものです。
リスト C<1,,3> は 2 つのリスト C<1,> と C<3> の結合であり、
1 つ目のリストはオプションのカンマで終わっています。
C<1,,3> は C<(1,),(3)> で C<1,3> です (そして同様に C<1,,,3> は
C<(1,),(,),3> で C<1,3> です。以下同様。)
この暗黒面を使うよう勧めているわけではありません。

=begin original

A list value may also be subscripted like a normal array.  You must
put the list in parentheses to avoid ambiguity.  For example:

=end original

リスト値にも通常の配列と同じように、添え字をつけることができます。
リストには、曖昧さをなくすために、括弧を付けなくてはなりません。
例:

    # Stat returns list value.
    $time = (stat($file))[8];

    # SYNTAX ERROR HERE.
    $time = stat($file)[8];  # OOPS, FORGOT PARENTHESES

    # Find a hex digit.
    $hexdigit = ('a','b','c','d','e','f')[$digit-10];

    # A "reverse comma operator".
    return (pop(@foo),pop(@foo))[0];

=begin original

Lists may be assigned to only when each element of the list
is itself legal to assign to:

=end original

リスト自身を構成する個々の要素すべてに代入が許される場合にのみ、
全体のリストに代入を行なうことができます:

    ($a, $b, $c) = (1, 2, 3);

    ($map{'red'}, $map{'blue'}, $map{'green'}) = (0x00f, 0x0f0, 0xf00);

=begin original

An exception to this is that you may assign to C<undef> in a list.
This is useful for throwing away some of the return values of a
function:

=end original

この例外として、リストにC<undef>を代入することもできます。
これは関数の戻り値の一部を捨て去るのに便利です:

    ($dev, $ino, undef, undef, $uid, $gid) = stat($file);

=begin original

List assignment in scalar context returns the number of elements
produced by the expression on the right side of the assignment:

=end original

スカラコンテキスト中のリスト代入は、代入の右辺にある式によって
生成された要素の数を返します:

    $x = (($foo,$bar) = (3,2,1));       # set $x to 3, not 2
    $x = (($foo,$bar) = f());           # set $x to f()'s return count

=begin original

This is handy when you want to do a list assignment in a Boolean
context, because most list functions return a null list when finished,
which when assigned produces a 0, which is interpreted as FALSE.

=end original

これはブールコンテキストでリストの代入をしたいときに便利です。
なぜなら、ほとんどのリスト関数は終了時に空リストを返すからです。
これは代入が 0 を生成したときには、偽と解釈されます。

=begin original

It's also the source of a useful idiom for executing a function or
performing an operation in list context and then counting the number of
return values, by assigning to an empty list and then using that
assignment in scalar context. For example, this code:

=end original

これはまた、関数の実行や操作の処理をリストコンテキストで行い、
それからそれを空リストにからすからコンテキストでの代入を行うことで
返り値の数を数えるための便利な慣用法のもととなります。
例えば、以下のコードは:

    $count = () = $string =~ /\d+/g;

=begin original

will place into $count the number of digit groups found in $string.
This happens because the pattern match is in list context (since it
is being assigned to the empty list), and will therefore return a list
of all matching parts of the string. The list assignment in scalar
context will translate that into the number of elements (here, the
number of times the pattern matched) and assign that to $count. Note
that simply using

=end original

$string の中で見つかった数字のグループの数を $count に設定します。
これは、(値が空リストに代入されているので)パターンマッチングは
リストコンテキストで行われ、従って文字列での全てのマッチした部分の
リストが返されるために起こります。
スカラコンテキストでのリスト代入は要素数(ここでは、マッチしたパターンの
数)に変換され、それが $count に代入されます。
単に以下のようにしても:

    $count = $string =~ /\d+/g;

=begin original

would not have worked, since a pattern match in scalar context will
only return true or false, rather than a count of matches.

=end original

うまく動かないことに注意してください; スカラコンテキストでの
パターンマッチングはマッチした数ではなく、単に真か偽を返すからです。

=begin original

The final element of a list assignment may be an array or a hash:

=end original

リスト代入の最後の要素は、配列やハッシュでもかまいません:

    ($a, $b, @rest) = split;
    my($a, $b, %rest) = @_;

=begin original

You can actually put an array or hash anywhere in the list, but the first one
in the list will soak up all the values, and anything after it will become
undefined.  This may be useful in a my() or local().

=end original

実際は、リストの任意の要素として配列を使うことができますが、
リスト中の最初の配列が、右辺の値をすべて取り込んでしまうため、
それ以降のものは未定義になります。
これは、my() や local() では有用かもしれません。

=begin original

A hash can be initialized using a literal list holding pairs of
items to be interpreted as a key and a value:

=end original

ハッシュはキーと値と解釈される値のペアとなるリストリテラルを使って
初期化されます:

    # same as map assignment above
    %map = ('red',0x00f,'blue',0x0f0,'green',0xf00);

=begin original

While literal lists and named arrays are often interchangeable, that's
not the case for hashes.  Just because you can subscript a list value like
a normal array does not mean that you can subscript a list value as a
hash.  Likewise, hashes included as parts of other lists (including
parameters lists and return lists from functions) always flatten out into
key/value pairs.  That's why it's good to use references sometimes.

=end original

しばしば、リストリテラルと名前付きの配列は互いに交換可能ですが、
ハッシュの場合はそうではありません。
通常の配列がハッシュとしてリスト値で添え字づけできないのと同様に、
リスト値を使って添え字づけすることはできません。
同様に、その一部として別のリストを含むハッシュ(パラメーターリストや
関数の戻り値リストを含みます)は常に平坦なキー/値のペアにされます。
これはリファレンスをきちんと使う理由です。

=begin original

It is often more readable to use the C<< => >> operator between key/value
pairs.  The C<< => >> operator is mostly just a more visually distinctive
synonym for a comma, but it also arranges for its left-hand operand to be
interpreted as a string -- if it's a bareword that would be a legal simple
identifier (C<< => >> doesn't quote compound identifiers, that contain
double colons). This makes it nice for initializing hashes:

=end original

key/value のペアの間に  C<< => >> 演算子を使うと読みやすくなります。
C<< => >> 演算子は実質、見た目に判別しやすいカンマ演算子でありますが、
その左側にあるオペランドが正当な単純な識別子であるような
裸の単語であるときに、それを文字列として解釈するようになっています
(C<< => >> は、2 つのコロンを含むような複合識別子はクォートしません)。
これは、ハッシュの初期化を格好よいものにします:

    %map = (
                 red   => 0x00f,
                 blue  => 0x0f0,
                 green => 0xf00,
   );

=begin original

or for initializing hash references to be used as records:

=end original

あるいは、レコードとして使うハッシュリファレンスを初期化するために
使います:

    $rec = {
                witch => 'Mable the Merciless',
                cat   => 'Fluffy the Ferocious',
                date  => '10/31/1776',
    };

=begin original

or for using call-by-named-parameter to complicated functions:

=end original

複雑な関数のために名前付きパラメータによる呼び出しを使うためにも
使えます:

   $field = $query->radio_group(
               name      => 'group_name',
               values    => ['eenie','meenie','minie'],
               default   => 'meenie',
               linebreak => 'true',
               labels    => \%labels
   );

=begin original

Note that just because a hash is initialized in that order doesn't
mean that it comes out in that order.  See L<perlfunc/sort> for examples
of how to arrange for an output ordering.

=end original

ハッシュでは順番に意味がないので、初期化の順序にも意味はないということに
注意してください。
出力の順序を変える方法の例は、L<perlfunc/sort> を参照してください。

=head2 Subscripts

(添え字)

=begin original

An array is subscripted by specifying a dollar sign (C<$>), then the
name of the array (without the leading C<@>), then the subscript inside
square brackets.  For example:

=end original

配列は、ドル記号 (C<$>)、(先頭の C<@> なしの)配列名、大かっこで囲われた
添え字、の順で指定することで添え字付けされます。
例:

    @myarray = (5, 50, 500, 5000);
    print "Element Number 2 is", $myarray[2], "\n";

=begin original

The array indices start with 0. A negative subscript retrieves its 
value from the end.  In our example, C<$myarray[-1]> would have been 
5000, and C<$myarray[-2]> would have been 500.

=end original

配列の添え字は 0 から始まります。
負数の添え字は後ろから値を取り出します。
前述の例では、C<$myarray[-1]> は 5000 となり、C<$myarray[-2]> は
500 となります。

=begin original

Hash subscripts are similar, only instead of square brackets curly brackets
are used. For example:

=end original

ハッシュの添え字も同様ですが、大かっこの代わりに中かっこを使います。
例:

    %scientists = 
    (
        "Newton" => "Isaac",
        "Einstein" => "Albert",
        "Darwin" => "Charles",
        "Feynman" => "Richard",
    );

    print "Darwin's First Name is ", $scientists{"Darwin"}, "\n";

=head2 Slices
X<slice> X<array, slice> X<hash, slice>

(スライス)

=begin original

A common way to access an array or a hash is one scalar element at a
time.  You can also subscript a list to get a single element from it.

=end original

配列やハッシュにアクセスする一般的な方法は、一度に一つのスカラ要素です。
リストから一つの要素を取り出すためにも、添え字を使えます。

    $whoami = $ENV{"USER"};             # one element from the hash
    $parent = $ISA[0];                  # one element from the array
    $dir    = (getpwnam("daemon"))[7];  # likewise, but with list

=begin original

A slice accesses several elements of a list, an array, or a hash
simultaneously using a list of subscripts.  It's more convenient
than writing out the individual elements as a list of separate
scalar values.

=end original

スライスは、添え字のリストを使ってリスト、配列、ハッシュの複数の要素に
同時にアクセスします。
これはそれぞれの要素を個々のスカラ値のリストとして扱うより便利です。

    ($him, $her)   = @folks[0,-1];              # array slice
    @them          = @folks[0 .. 3];            # array slice
    ($who, $home)  = @ENV{"USER", "HOME"};      # hash slice
    ($uid, $dir)   = (getpwnam("daemon"))[2,7]; # list slice

=begin original

Since you can assign to a list of variables, you can also assign to
an array or hash slice.

=end original

変数のリストに代入できるので、配列やハッシュのスライスにも代入できます。

    @days[3..5]    = qw/Wed Thu Fri/;
    @colors{'red','blue','green'} 
                   = (0xff0000, 0x0000ff, 0x00ff00);
    @folks[0, -1]  = @folks[-1, 0];

=begin original

The previous assignments are exactly equivalent to

=end original

前述の代入は以下と完全に等価です:

    ($days[3], $days[4], $days[5]) = qw/Wed Thu Fri/;
    ($colors{'red'}, $colors{'blue'}, $colors{'green'})
                   = (0xff0000, 0x0000ff, 0x00ff00);
    ($folks[0], $folks[-1]) = ($folks[-1], $folks[0]);

=begin original

Since changing a slice changes the original array or hash that it's
slicing, a C<foreach> construct will alter some--or even all--of the
values of the array or hash.

=end original

スライスを変更すると、スライスした元の配列やハッシュを変更するので、
C<foreach> 構造は配列やハッシュの値の一部 -- あるいは全部 -- を
置き換えます。

    foreach (@array[ 4 .. 10 ]) { s/peter/paul/ } 

    foreach (@hash{qw[key1 key2]}) {
        s/^\s+//;           # trim leading whitespace
        s/\s+$//;           # trim trailing whitespace
        s/(\w+)/\u\L$1/g;   # "titlecase" words
    }

=begin original

A slice of an empty list is still an empty list.  Thus:

=end original

空リストのスライスはやはり空リストです。
従って:

    @a = ()[1,0];           # @a has no elements
    @b = (@a)[0,1];         # @b has no elements
    @c = (0,1)[2,3];        # @c has no elements

=begin original

But:

=end original

しかし:

    @a = (1)[1,0];          # @a has two elements
    @b = (1,undef)[1,0,2];  # @b has three elements

=begin original

This makes it easy to write loops that terminate when a null list
is returned:

=end original

これを使うと、空リストが返ったら終了するループを簡単に書けます:

    while ( ($home, $user) = (getpwent)[7,0]) {
        printf "%-8s %s\n", $user, $home;
    }

=begin original

As noted earlier in this document, the scalar sense of list assignment
is the number of elements on the right-hand side of the assignment.
The null list contains no elements, so when the password file is
exhausted, the result is 0, not 2.

=end original

この文書で前述したように、リスト代入のスカラ評価は、代入の右側の要素の
数です。
空リストは要素を含まないので、パスワードファイルを読み込み終わると、
結果は 2 ではなく 0 になります。

=begin original

If you're confused about why you use an '@' there on a hash slice
instead of a '%', think of it like this.  The type of bracket (square
or curly) governs whether it's an array or a hash being looked at.
On the other hand, the leading symbol ('$' or '@') on the array or
hash indicates whether you are getting back a singular value (a
scalar) or a plural one (a list).

=end original

もし、なぜここでハッシュスライスに '%' ではなく '@' を使うのかについて
混乱するなら、次のように考えてみてください。
かっこの種類(大かっこか中かっこか)は、見ているものが配列かハッシュかを
つかさどっています。
一方、配列やハッシュの先頭の記号('$' か '@') は、返ってくるものが単一の
値(スカラ)か、複数の値(リスト)かを示しています。

=head2 Typeglobs and Filehandles
X<typeglob> X<filehandle> X<*>

(型グロブとファイルハンドル)

=begin original

Perl uses an internal type called a I<typeglob> to hold an entire
symbol table entry.  The type prefix of a typeglob is a C<*>, because
it represents all types.  This used to be the preferred way to
pass arrays and hashes by reference into a function, but now that
we have real references, this is seldom needed.  

=end original

Perl は I<型グロブ> と呼ばれる内部型を、シンボルテーブルエントリ全体を
保持するために使っています。
この型グロブの型接頭辞は C<*> です。
なぜなら、それが型全てを表すからです。
これは関数に対してリファレンスを使って配列やハッシュを渡すために
好んで使われていた方法でした。
しかし、私たちは今では本当のリファレンスを持っていますから、
型グロブを使う必要はほとんどありません。

=begin original

The main use of typeglobs in modern Perl is create symbol table aliases.
This assignment:

=end original

最近の Perl での型グロブの主な用途は、シンボルテーブルのエイリアスを
作るというものです。
具体的には以下のようにします:

    *this = *that;

=begin original

makes $this an alias for $that, @this an alias for @that, %this an alias
for %that, &this an alias for &that, etc.  Much safer is to use a reference.
This:

=end original

これは $this を $that のエイリアスにし、
@this を $that のエイリアスにし、%this を %that のエイリアスに、
&this を &that のエイリアスにし…のようにします。
より安全にするにはリファレンスを使います。

    local *Here::blue = \$There::green;

=begin original

temporarily makes $Here::blue an alias for $There::green, but doesn't
make @Here::blue an alias for @There::green, or %Here::blue an alias for
%There::green, etc.  See L<perlmod/"Symbol Tables"> for more examples
of this.  Strange though this may seem, this is the basis for the whole
module import/export system.

=end original

この例では $Here::blue を一時的に $There::green のエイリアスにしますが、
@Here::blue を $There::blue のエイリアスにはしませんし、
同様に %Here::blue を %There::green のエイリアスにはしません。
これは奇妙に思えるかもしれませんが、これが
モジュールのインポート/エクスポートシステムの基盤となっているのです。

=begin original

Another use for typeglobs is to pass filehandles into a function or
to create new filehandles.  If you need to use a typeglob to save away
a filehandle, do it this way:

=end original

型グロブの別の用途には、関数にファイルハンドルを渡したり、
新たなファイルハンドルを生成するというものがあります。
もしファイルハンドルを保存するために型グロブを使う必要があるのなら、
以下のようにします:

    $fh = *STDOUT;

=begin original

or perhaps as a real reference, like this:

=end original

あるいは、以下のように本当のリファレンスを使います:

    $fh = \*STDOUT;

=begin original

See L<perlsub> for examples of using these as indirect filehandles
in functions.

=end original

関数中で間接的にファイルハンドルを使う例については L<perlsub> を
参照してください。

=begin original

Typeglobs are also a way to create a local filehandle using the local()
operator.  These last until their block is exited, but may be passed back.
For example:

=end original

型グロブは local() 演算子を使ったローカルなファイルハンドルを
作成するのにも使われます。
それによって作成されたものはそれを囲むブロックが存在する間だけ
存在しますが、呼び出し元へ返すことが可能です。
例を挙げましょう:

    sub newopen {
        my $path = shift;
        local  *FH;  # not my!
        open   (FH, $path)          or  return undef;
        return *FH;
    }
    $fh = newopen('/etc/passwd');

=begin original

Now that we have the C<*foo{THING}> notation, typeglobs aren't used as much
for filehandle manipulations, although they're still needed to pass brand
new file and directory handles into or out of functions. That's because
C<*HANDLE{IO}> only works if HANDLE has already been used as a handle.
In other words, C<*FH> must be used to create new symbol table entries;
C<*foo{THING}> cannot.  When in doubt, use C<*FH>.

=end original

今では C<*foo{THING}> 表記がありますから、型グロブはファイルハンドルの
操作のために用いられることはそれほどではありませんが、
ファイルハンドルやディレクトリハンドルを関数に対して渡したり、
関数の外へ返すためにはまだ必要となります。
これは C<*HANDLE{IO}> は HANDLE が既にハンドルとして使われた場合にのみ
動作するからです。
言い換えると、C<*FH> は新しいシンボルテーブルのエントリーを作成するために
使わなければなりませんが、C<*foo{THING}> を使うことはできません。
疑わしい場合は、C<*FH> を使ってください。

=begin original

All functions that are capable of creating filehandles (open(),
opendir(), pipe(), socketpair(), sysopen(), socket(), and accept())
automatically create an anonymous filehandle if the handle passed to
them is an uninitialized scalar variable. This allows the constructs
such as C<open(my $fh, ...)> and C<open(local $fh,...)> to be used to
create filehandles that will conveniently be closed automatically when
the scope ends, provided there are no other references to them. This
largely eliminates the need for typeglobs when opening filehandles
that must be passed around, as in the following example:

=end original

ファイルハンドルを作成できる全ての関数 (open(),
opendir(), pipe(), socketpair(), sysopen(), socket(), and accept()) は、
もし渡されたハンドルが初期化されていないスカラ変数の場合、
無名ファイルハンドルを作成します。
これにより、C<open(my $fh, ...)> や C<open(local $fh,...)> のような
構文によって、他からのリファレンスがなければスコープの終わりに自動的に
閉じられる便利なファイルハンドルを作ることができます。
これは、以下の例のように、他に渡す必要があるファイルハンドルを開く時に
型グロブを使う必要性を大きく減らします:

    sub myopen {
        open my $fh, "@_"
             or die "Can't open '@_': $!";
        return $fh;
    }

    {
        my $f = myopen("</etc/motd");
        print <$f>;
        # $f implicitly closed here
    }

=begin original

Note that if an initialized scalar variable is used instead the
result is different: C<my $fh='zzz'; open($fh, ...)> is equivalent
to C<open( *{'zzz'}, ...)>.
C<use strict 'refs'> forbids such practice.

=end original

代わりに初期化されたスカラ変数が使われると、結果は異なることに
注意してください。
C<my $fh='zzz'; open($fh, ...)> は C<open( *{'zzz'}, ...)> と等価です。
このような動作を禁止するには C<use strict 'refs'> を使ってください。

=begin original

Another way to create anonymous filehandles is with the Symbol
module or with the IO::Handle module and its ilk.  These modules
have the advantage of not hiding different types of the same name
during the local().  See the bottom of L<perlfunc/open()> for an
example.

=end original

無名ファイルハンドルを作るもう一つの方法は Symbol モジュールか
IO::Handle モジュールを使用するというものです。
このモジュールは local() を使ったときのように同じ名前を
隠してしまうようなことがないという利点があります。
これを使った例は L<perlfunc/open()> の末尾を参照してください。

=head1 SEE ALSO

=begin original

See L<perlvar> for a description of Perl's built-in variables and
a discussion of legal variable names.  See L<perlref>, L<perlsub>,
and L<perlmod/"Symbol Tables"> for more discussion on typeglobs and
the C<*foo{THING}> syntax.

=end original

Perl の組み込み変数と、有効な変数名に関する議論に関しては、
L<perlvar> を参照してください。
型グロブに関する議論と *foo{THING} 構文に関することは、L<perlref>, 
L<perlsub>, L<perlmod/"Symbol Tables"> を参照してください。

=begin meta

Created: KIMURA Koichi
Updated: Kentaro Shirakata <argrath@ub32.org> (5.8.8-)

=end meta

