
=encoding euc-jp

=head1 NAME

=begin original

perlfaq4 - Data Manipulation ($Revision: 10394 $)

=end original

perlfaq4 - データ操作 ($Revision: 10394 $)

=head1 DESCRIPTION

=begin original

This section of the FAQ answers questions related to manipulating
numbers, dates, strings, arrays, hashes, and miscellaneous data issues.

=end original

FAQのこのセクションでは、数値、日付、文字列、配列、ハッシュその他の
データの取り扱いに関する質問に回答しています。

=head1 Data: Numbers

(データ: 数)

=head2 Why am I getting long decimals (eg, 19.9499999999999) instead of the numbers I should be getting (eg, 19.95)?

(なぜ 19.95 のような数字ではなく、19.9499999999999 のような長い
数字が出てきたんでしょうか?)

=begin original

Internally, your computer represents floating-point numbers in binary.
Digital (as in powers of two) computers cannot store all numbers
exactly.  Some real numbers lose precision in the process.  This is a
problem with how computers store numbers and affects all computer
languages, not just Perl.

=end original

内部的には、あなたの使っているコンピュータは浮動小数点数を 2 進数を
使って表現しています。
(2 のべき乗のような) デジタルなコンピュータは全ての数値を正確に
保管することはできません。
実数は処理中に精度が落ちることがあります。
これはコンピュータがどのように数値を保管するかの問題で、Perl だけではなく
全てのコンピュータ言語に影響を与えます。

=begin original

L<perlnumber> shows the gory details of number representations and
conversions.

=end original

L<perlnumber> には、数値表現と変換に関する不愉快な詳細が記されています。

=begin original

To limit the number of decimal places in your numbers, you can use the
printf or sprintf function.  See the L<"Floating Point
Arithmetic"|perlop> for more details.

=end original

10 進数の桁数を制限するには、printf や sprintf の関数が使えます。
更なる詳細については L<"Floating Point Arithmetic"|perlop> を参照してください。

	printf "%.2f", 10/3;

	my $number = sprintf "%.2f", 10/3;

=head2 Why is int() broken?

(なぜ int() は壊れているのでしょう?)

=begin original

Your C<int()> is most probably working just fine.  It's the numbers that
aren't quite what you think.

=end original

C<int()> はほぼ確実に正しく動作しています。
これは、数値というものがあなたの考えているものと違うからです。

=begin original

First, see the answer to "Why am I getting long decimals
(eg, 19.9499999999999) instead of the numbers I should be getting
(eg, 19.95)?".

=end original

まず、"Why am I getting long decimals
(eg, 19.9499999999999) instead of the numbers I should be getting
(eg, 19.95)?" に対する答えを参照してください。

=begin original

For example, this

=end original

例えば、これは:

	print int(0.6/0.2-2), "\n";

=begin original

will in most computers print 0, not 1, because even such simple
numbers as 0.6 and 0.2 cannot be presented exactly by floating-point
numbers.  What you think in the above as 'three' is really more like
2.9999999999999995559.

=end original

ほとんどのコンピュータでは 1 ではなく 0 を表示します;
0.6 や 0.2 と言った単純な数値であっても、浮動小数点数で正確に表現できません。
さきほどあなたが "3" と考えたものは、実際には 2.9999999999999995559 と
いったものです。

=head2 Why isn't my octal data interpreted correctly?

(なぜ私の 8 進データは正しく解釈されないのでしょうか?)

=begin original

Perl only understands octal and hex numbers as such when they occur as
literals in your program.  Octal literals in perl must start with a
leading C<0> and hexadecimal literals must start with a leading C<0x>.
If they are read in from somewhere and assigned, no automatic
conversion takes place.  You must explicitly use C<oct()> or C<hex()> if you
want the values converted to decimal.  C<oct()> interprets hexadecimal (C<0x350>),
octal (C<0350> or even without the leading C<0>, like C<377>) and binary
(C<0b1010>) numbers, while C<hex()> only converts hexadecimal ones, with
or without a leading C<0x>, such as C<0x255>, C<3A>, C<ff>, or C<deadbeef>.
The inverse mapping from decimal to octal can be done with either the
<%o> or C<%O> C<sprintf()> formats.

=end original

Perl は、プログラムの中にリテラルとして現れたときにだけ 8 進数や 16 進数を
理解します。
perl での 8 進数リテラルは先頭に C<0> が必要で、16 進数リテラルは
先頭に C<0x> が必要です。
それらのものがそれ以外の場所からとか代入で読み込まれた場合、
変換は実行されません。
10 進数へ変換したいなら、陽に C<oct()> や C<hex()> を使わなければなりません。
C<oct()> は 16 進数(C<0x350>)、8 進数(C<0350> や、C<377> のように
先頭の C<0> がないものでも)、2 進数(C<0b1010>) を解釈するのに対して、
hex() が 16 進数(C<0x255>, C<3A>, C<ff>, C<deadbeef> のように、
先頭に C<0x> がついたりつかなかったりします)のみを変換します。
10 進数から 8 進数への逆変換は C<sprintf()> の <%o> か C<%O> の
フォーマットで行えます。

=begin original

This problem shows up most often when people try using C<chmod()>,
C<mkdir()>, C<umask()>, or C<sysopen()>, which by widespread tradition
typically take permissions in octal.

=end original

この問題は、パーミッションを 8 進数で指定するような広く広まった
伝統のために C<chmod()>, C<mkdir()>, C<umask()>, C<sysopen()> を使おうと
したときによく発生します。

	chmod(644,  $file);   # WRONG
	chmod(0644, $file);   # right

=begin original

Note the mistake in the first line was specifying the decimal literal
C<644>, rather than the intended octal literal C<0644>.  The problem can
be seen with:

=end original

1 行目の間違いは、意図している 8 進数リテラル C<0644> ではなく、
10 進数 リテラル C<644> を指定していることであることに注意してください。
問題点は、以下のようにすることで見られます:

	printf("%#o",644);   # prints 01204

=begin original

Surely you had not intended C<chmod(01204, $file);> - did you?  If you
want to use numeric literals as arguments to chmod() et al. then please
try to express them as octal constants, that is with a leading zero and
with the following digits restricted to the set C<0..7>.

=end original

きっと C<chmod(01204, $file);> は意図してないはずです - ですよね?
chmod() などでの引数として数値リテラルを使いたい場合は、
先頭に 0 をつけ、その後に C<0..7> の数値が続く 8 進定数を使うように
してください。

=head2 Does Perl have a round() function?  What about ceil() and floor()?  Trig functions?

(Perl には丸め関数がありますか? ceil() と floor() とは何ですか? 三角関数は?)

=begin original

Remember that C<int()> merely truncates toward 0.  For rounding to a
certain number of digits, C<sprintf()> or C<printf()> is usually the
easiest route.

=end original

C<int()> は 0 へ向かって丸めを行うことを思い出してください。
特定の桁数で丸めを行うには、C<sprintf()> や C<printf()> を使うことが
通常はもっとも簡単なやり方です。

	printf("%.3f", 3.1415926535);   # prints 3.142

=begin original

The C<POSIX> module (part of the standard Perl distribution)
implements C<ceil()>, C<floor()>, and a number of other mathematical
and trigonometric functions.

=end original

(標準 Perl 配布キットの一部である)C<POSIX> モジュールは C<ceil()>、
C<floor()>、そしてその他の数学的な関数や三角関数の多くを実装しています。

	use POSIX;
	$ceil   = ceil(3.5);   # 4
	$floor  = floor(3.5);  # 3

=begin original

In 5.000 to 5.003 perls, trigonometry was done in the C<Math::Complex>
module.  With 5.004, the C<Math::Trig> module (part of the standard Perl
distribution) implements the trigonometric functions. Internally it
uses the C<Math::Complex> module and some functions can break out from
the real axis into the complex plane, for example the inverse sine of
2.

=end original

perl の 5.000 から 5.003 では、三角関数は C<Math::Complex> モジュールの中で
実行されていました。
5.004 では、C<Math::Trig> モジュール(標準 Perl 配布キットの一部です)が
三角関数を実装しています。
内部的にはこれは C<Math::Complex> を使っていて、一部の関数は実数値を複素数領域へ
変化させることができます。
2 の inverse sine がその一例です。

=begin original

Rounding in financial applications can have serious implications, and
the rounding method used should be specified precisely.  In these
cases, it probably pays not to trust whichever system rounding is
being used by Perl, but to instead implement the rounding function you
need yourself.

=end original

金融に関係するアプリケーションにおいては、丸めはきちんとした実装を
必要とするかもしれません。
そして、丸めの方法は適切に使われるべきものです。
この場合、Perl が使っているシステムによる丸めを信用すべきではなく、
自分自身で丸め関数を実装するようにすべきでしょう。

=begin original

To see why, notice how you'll still have an issue on half-way-point
alternation:

=end original

なぜかを見るために、中間点反復に関する問題があるということに注意しましょう:

	for ($i = 0; $i < 1.01; $i += 0.05) { printf "%.1f ",$i}

	0.0 0.1 0.1 0.2 0.2 0.2 0.3 0.3 0.4 0.4 0.5 0.5 0.6 0.7 0.7
	0.8 0.8 0.9 0.9 1.0 1.0

=begin original

Don't blame Perl.  It's the same as in C.  IEEE says we have to do
this. Perl numbers whose absolute values are integers under 2**31 (on
32 bit machines) will work pretty much like mathematical integers.
Other numbers are not guaranteed.

=end original

Perl を責めないでください。
これはCでも同じことなのです。
IEEE ではこのようにすることを述べています。
Perl での数値は絶対値で 2**31(32 ビットマシンの場合)以下の場合の整数値であれば
数学的な整数と同じように振る舞います。
それ以外の数値は恩恵を受けません。

=head2 How do I convert between numeric representations/bases/radixes?

(数値表現や基底や基数を変換するには?)

=begin original

As always with Perl there is more than one way to do it.  Below are a
few examples of approaches to making common conversions between number
representations.  This is intended to be representational rather than
exhaustive.

=end original

Perl ではいつものことですが、これを行うには複数の方法があります。
以下は、一般的な数値表現の変換を行うための手法のいくつかの例です。
これは完全性よりも説明性を意図しています。

=begin original

Some of the examples later in L<perlfaq4> use the C<Bit::Vector>
module from CPAN. The reason you might choose C<Bit::Vector> over the
perl built in functions is that it works with numbers of ANY size,
that it is optimized for speed on some operations, and for at least
some programmers the notation might be familiar.

=end original

L<perlfaq4> の後の方での例では CPAN にある C<Bit::Vector> を使っています。
perl 組み込みの関数よりも C<Bit::Vector> を選択する理由は、
どんな大きさの数でも動作し、いくつかの操作では速度のために最適化されていて、
少なくともいくらかのプログラマにとっては表記がわかりやすいからです。

=over 4

=item How do I convert hexadecimal into decimal

=begin original

Using perl's built in conversion of C<0x> notation:

=end original

C<0x> 表記による perl の組み込み変換を使って:

	$dec = 0xDEADBEEF;

=begin original

Using the C<hex> function:

=end original

C<hex> 関数を使って:

	$dec = hex("DEADBEEF");

=begin original

Using C<pack>:

=end original

C<pack> を使って:

	$dec = unpack("N", pack("H8", substr("0" x 8 . "DEADBEEF", -8)));

=begin original

Using the CPAN module C<Bit::Vector>:

=end original

CPAN の C<Bit::Vector> モジュールを使って:

	use Bit::Vector;
	$vec = Bit::Vector->new_Hex(32, "DEADBEEF");
	$dec = $vec->to_Dec();

=item How do I convert from decimal to hexadecimal

=begin original

Using C<sprintf>:

=end original

C<sprintf> を使って:

	$hex = sprintf("%X", 3735928559); # upper case A-F
	$hex = sprintf("%x", 3735928559); # lower case a-f

=begin original

Using C<unpack>:

=end original

C<unpack> を使って:

	$hex = unpack("H*", pack("N", 3735928559));

=begin original

Using C<Bit::Vector>:

=end original

C<Bit::Vector> を使って:

	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(32, -559038737);
	$hex = $vec->to_Hex();

=begin original

And C<Bit::Vector> supports odd bit counts:

=end original

そして C<Bit::Vector> は半端なビット数にも対応しています:

	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(33, 3735928559);
	$vec->Resize(32); # suppress leading 0 if unwanted
	$hex = $vec->to_Hex();

=item How do I convert from octal to decimal

=begin original

Using Perl's built in conversion of numbers with leading zeros:

=end original

先頭に 0 を付けることによる Perl 組み込みの変換を使って:

	$dec = 033653337357; # note the leading 0!

=begin original

Using the C<oct> function:

=end original

C<oct> function 関数を使って:

	$dec = oct("33653337357");

=begin original

Using C<Bit::Vector>:

=end original

C<Bit::Vector> を使って:

	use Bit::Vector;
	$vec = Bit::Vector->new(32);
	$vec->Chunk_List_Store(3, split(//, reverse "33653337357"));
	$dec = $vec->to_Dec();

=item How do I convert from decimal to octal

=begin original

Using C<sprintf>:

=end original

C<sprintf> を使って:

	$oct = sprintf("%o", 3735928559);

=begin original

Using C<Bit::Vector>:

=end original

C<Bit::Vector> を使って:

	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(32, -559038737);
	$oct = reverse join('', $vec->Chunk_List_Read(3));

=item How do I convert from binary to decimal

(2 進数から 10 進数に変換するには?)

=begin original

Perl 5.6 lets you write binary numbers directly with
the C<0b> notation:

=end original

Perl 5.6 から、C<0b> 表記を使って直接 2 進数を書くことができます:

	$number = 0b10110110;

=begin original

Using C<oct>:

=end original

C<oct> を使って:

	my $input = "10110110";
	$decimal = oct( "0b$input" );

=begin original

Using C<pack> and C<ord>:

=end original

C<pack> と C<ord> を使って:

	$decimal = ord(pack('B8', '10110110'));

=begin original

Using C<pack> and C<unpack> for larger strings:

=end original

より大きな文字列に対しては、C<pack> と C<unpack> を使って:

	$int = unpack("N", pack("B32",
	substr("0" x 32 . "11110101011011011111011101111", -32)));
	$dec = sprintf("%d", $int);

	# substr() is used to left pad a 32 character string with zeros.

=begin original

Using C<Bit::Vector>:

=end original

C<Bit::Vector> を使って:

	$vec = Bit::Vector->new_Bin(32, "11011110101011011011111011101111");
	$dec = $vec->to_Dec();

=item How do I convert from decimal to binary

=begin original

Using C<sprintf> (perl 5.6+):

=end original

C<sprintf> を使って(perl 5.6 以降):

	$bin = sprintf("%b", 3735928559);

=begin original

Using C<unpack>:

=end original

C<unpack> を使って:

	$bin = unpack("B*", pack("N", 3735928559));

=begin original

Using C<Bit::Vector>:

=end original

C<Bit::Vector> を使って:

	use Bit::Vector;
	$vec = Bit::Vector->new_Dec(32, -559038737);
	$bin = $vec->to_Bin();

=begin original

The remaining transformations (e.g. hex -> oct, bin -> hex, etc.)
are left as an exercise to the inclined reader.

=end original

残りの変換 (16 進 -> 8 進、2 進 -> 16 進、など) は読者への宿題として
残しておきます。

=back

=head2 Why doesn't & work the way I want it to?

(なぜ & は私の思った通りに動作しないのでしょうか?)

=begin original

The behavior of binary arithmetic operators depends on whether they're
used on numbers or strings.  The operators treat a string as a series
of bits and work with that (the string C<"3"> is the bit pattern
C<00110011>).  The operators work with the binary form of a number
(the number C<3> is treated as the bit pattern C<00000011>).

=end original

バイナリ算術演算子の振る舞いはそれが数値に対して使われているのか
文字列に対して使われているかということに依存しています。
その演算子は文字列をビットの並びとして扱います(C<"3"> という文字列は
C<00110011> というビットパターンとなります)。
この演算子はバイナリ形式に対して働きます
(C<3> という数値は C<00000011> というビットパターンとして扱われます)。

=begin original

So, saying C<11 & 3> performs the "and" operation on numbers (yielding
C<3>).  Saying C<"11" & "3"> performs the "and" operation on strings
(yielding C<"1">).

=end original

ですから、C<11 & 3> は数値に対する "and" として働きます(結果は
C<3> です)。
C<"11" & "3">は文字列に対する "and" として働きます(結果は C<"1"> です)。

=begin original

Most problems with C<&> and C<|> arise because the programmer thinks
they have a number but really it's a string.  The rest arise because
the programmer says:

=end original

ありがちな問題は C<&> と C<|> を使ったときに、プログラマは
オペランドが数値と考えているのに実際は文字列であるようなときに
起こります。
例を挙げましょう:

	if ("\020\020" & "\101\101") {
		# ...
		}

=begin original

but a string consisting of two null bytes (the result of C<"\020\020"
& "\101\101">) is not a false value in Perl.  You need:

=end original

この場合の結果は二つのナルバイトを含む文字列となります
(C<"\020\020"> の結果です)が、これは Perl における偽の値では
ありません。
以下のようにする必要があります:

	if ( ("\020\020" & "\101\101") !~ /[^\000]/) {
		# ...
		}

=head2 How do I multiply matrices?

(行列の積を計算するには?)

=begin original

Use the Math::Matrix or Math::MatrixReal modules (available from CPAN)
or the PDL extension (also available from CPAN).

=end original

Math::Matrix モジュールか、Math::MatrixReal モジュール(CPAN で入手できます)か
PDL エクステンション(これも CPAN で入手できます)を使います。

=head2 How do I perform an operation on a series of integers?

(整数値の並びに対してある操作を実行するには?)

=begin original

To call a function on each element in an array, and collect the
results, use:

=end original

配列の各要素に対して関数を呼び出して、結果を集めるにはこうします:

	@results = map { my_func($_) } @array;

=begin original

For example:

=end original

例えば:

	@triple = map { 3 * $_ } @single;

=begin original

To call a function on each element of an array, but ignore the
results:

=end original

配列の各要素に対して関数を呼び出すけれども、結果を無視するという
場合にはこうします:

	foreach $iterator (@array) {
		some_func($iterator);
		}

=begin original

To call a function on each integer in a (small) range, you B<can> use:

=end original

ある(小さな)範囲にある整数に対して関数を呼び出すには、こうも B<できます>:

	@results = map { some_func($_) } (5 .. 25);

=begin original

but you should be aware that the C<..> operator creates an array of
all integers in the range.  This can take a lot of memory for large
ranges.  Instead use:

=end original

ただし、C<..> 演算子がその範囲にあるすべての整数の配列を生成するということに
注意すべきでしょう。
これによって大きな範囲を使った場合に大量のメモリを消費することになります。
代わりにこうします:

	@results = ();
	for ($i=5; $i < 500_005; $i++) {
		push(@results, some_func($i));
		}

=begin original

This situation has been fixed in Perl5.005. Use of C<..> in a C<for>
loop will iterate over the range, without creating the entire range.

=end original

この状況は Perl5.005 で修正されました。
C<for> ループで C<..> を使うことで、
範囲全体を生成することなく特定の範囲の繰り返しを行えます。

	for my $i (5 .. 500_005) {
		push(@results, some_func($i));
		}

=begin original

will not create a list of 500,000 integers.

=end original

このようにしても 500,000 個の整数のリストが生成されたりはしません。

=head2 How can I output Roman numerals?

(ローマ数字を出力するには?)

=begin original

Get the http://www.cpan.org/modules/by-module/Roman module.

=end original

http://www.cpan.org/modules/by-module/Roman モジュールを入手しましょう。

=head2 Why aren't my random numbers random?

(なぜ私の乱数はランダムでないの?)

=begin original

If you're using a version of Perl before 5.004, you must call C<srand>
once at the start of your program to seed the random number generator.

=end original

5.004 より前のバージョンの Perl を使っているなら、C<srand> を
プログラムの開始時点で一度呼び出してやって、乱数生成器の種を
セットしてやらなければなりません。

	 BEGIN { srand() if $] < 5.004 }

=begin original

5.004 and later automatically call C<srand> at the beginning.  Don't
call C<srand> more than once--you make your numbers less random,
rather than more.

=end original

5.004 以降のものでは開始時点で自動的に C<srand> を呼び出します。
二度以上 C<srand> を呼び出してはいけません。
乱数の質を落としてしまいます。

=begin original

Computers are good at being predictable and bad at being random
(despite appearances caused by bugs in your programs :-).  see the
F<random> article in the "Far More Than You Ever Wanted To Know"
collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz , courtesy
of Tom Phoenix, talks more about this.  John von Neumann said, "Anyone
who attempts to generate random numbers by deterministic means is, of
course, living in a state of sin."

=end original

コンピュータは予測できる物事に関しては役に立ちますが、ランダムな
ことに対してはそうではありません(それはあなたのプログラム自身のバグによって
引き起こされることですが:-)
Tom Phoenix がこの問題について語っている、
http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz
の "Far More Than You Ever Wanted To Know" の中の F<random> という記事を
参照してください。
ジョン・フォン・ノイマン曰く、「決定論的手段によって
乱数を作ろうと試みる全ての人はもちろん罪深きものである。」

=begin original

If you want numbers that are more random than C<rand> with C<srand>
provides, you should also check out the C<Math::TrulyRandom> module from
CPAN.  It uses the imperfections in your system's timer to generate
random numbers, but this takes quite a while.  If you want a better
pseudorandom generator than comes with your operating system, look at
"Numerical Recipes in C" at http://www.nr.com/ .

=end original

C<rand> と C<srand> が提供するものよりもよりランダムな数値が必要なら、
CPAN にある C<Math::TrulyRandom> モジュールも
チェックしてみると良いでしょう。
これはあなたの使っているシステムのタイマーを乱数を生成するのに
使っていて不完全な面もありますが、十分なものです。
あなたの使うオペレーティングシステムで使えるものよりも
もっと良質な擬似乱数を必要としているのなら、
http://www.nr.com にある ``Numerical Recipes in C'' を見るとよいでしょう。

=head2 How do I get a random number between X and Y?

(X と Y の間の乱数を得るには?)

=begin original

To get a random number between two values, you can use the C<rand()>
builtin to get a random number between 0 and 1. From there, you shift
that into the range that you want.

=end original

二つの値の間の乱数を得るためには、まず 0 と 1 との間の乱数を得るために
C<rand()> 組み込み関数を使います。
それから、これを必要な範囲にシフトします。

=begin original

C<rand($x)> returns a number such that C<< 0 <= rand($x) < $x >>. Thus
what you want to have perl figure out is a random number in the range
from 0 to the difference between your I<X> and I<Y>.

=end original

C<rand($x)> は C<< 0 <= rand($x) < $x >> という値を返します。
従って、perl に作ってほしいものは、0 から、必要な I<X> と I<Y> との差
までの範囲の乱数です。

=begin original

That is, to get a number between 10 and 15, inclusive, you want a
random number between 0 and 5 that you can then add to 10.

=end original

つまり、10 から 15 の範囲の値(両端を含む) を得るためには、
0 から 5 の範囲の乱数を求めて、それに 10 を加えます。

	my $number = 10 + int rand( 15-10+1 );

=begin original

Hence you derive the following simple function to abstract
that. It selects a random integer between the two given
integers (inclusive), For example: C<random_int_between(50,120)>.

=end original

従って、これを抽象化するために以下のサンプル関数を導き出します。
これは与えられた二つの整数を含む範囲のランダムな整数を選択します。
例えば: C<random_int_between(50,120)>

	sub random_int_between {
		my($min, $max) = @_;
		# Assumes that the two arguments are integers themselves!
		return $min if $min == $max;
		($min, $max) = ($max, $min)  if  $min > $max;
		return $min + int rand(1 + $max - $min);
		}

=head1 Data: Dates

(データ:日付)

=head2 How do I find the day or week of the year?

(その年の何日目であるかを知るには?)

=begin original

The localtime function returns the day of the year.  Without an
argument localtime uses the current time.

=end original

localtime 関数はその年の何日目であるかを返します。
引数なしの localtime は現在時刻を使います。

	$day_of_year = (localtime)[7];

=begin original

The C<POSIX> module can also format a date as the day of the year or
week of the year.

=end original

C<POSIX> モジュールも日付をその年の何日目か、または何週目かに整形します。

	use POSIX qw/strftime/;
	my $day_of_year  = strftime "%j", localtime;
	my $week_of_year = strftime "%W", localtime;

=begin original

To get the day of year for any date, use C<POSIX>'s C<mktime> to get
a time in epoch seconds for the argument to localtime.

=end original

任意の日付に対してその年の何日目かを得るには、localtime の引数から
紀元からの秒数を求めるために、C<POSIX> の C<mktime> を使います。

	use POSIX qw/mktime strftime/;
	my $week_of_year = strftime "%W",
		localtime( mktime( 0, 0, 0, 18, 11, 87 ) );

=begin original

The C<Date::Calc> module provides two functions to calculate these.

=end original

C<Date::Calc> モジュールはこれらを計算する二つの関数を提供します。

	use Date::Calc;
	my $day_of_year  = Day_of_Year(  1987, 12, 18 );
	my $week_of_year = Week_of_Year( 1987, 12, 18 );

=head2 How do I find the current century or millennium?

(現在の世紀や千年紀を知るには?)

=begin original

Use the following simple functions:

=end original

以下の単純な関数を使ってください:

	sub get_century    {
		return int((((localtime(shift || time))[5] + 1999))/100);
		}

	sub get_millennium {
		return 1+int((((localtime(shift || time))[5] + 1899))/1000);
		}

=begin original

On some systems, the C<POSIX> module's C<strftime()> function has been
extended in a non-standard way to use a C<%C> format, which they
sometimes claim is the "century". It isn't, because on most such
systems, this is only the first two digits of the four-digit year, and
thus cannot be used to reliably determine the current century or
millennium.

=end original

システムによっては、C<POSIX> モジュールの C<strftime()> 関数が
非標準の方法で C<%C> フォーマット("century"だと主張されることがあります)を
使うように拡張されているかもしれません。
これは世紀ではありません。
なぜならこのようなシステムのほとんどでは、
これは 4 桁の年の上位 2 桁を示しているだけなので、
現在の世紀や千年紀を決定する信頼できる方法ではありません。

=head2 How can I compare two dates and find the difference?

(二つの日付文字列を比較するには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

You could just store all your dates as a number and then subtract.
Life isn't always that simple though. If you want to work with
formatted dates, the C<Date::Manip>, C<Date::Calc>, or C<DateTime>
modules can help you.

=end original

日付を単に数値として保管して、それから引き算することもできます。
しかし、人生はいつもこんな風に単純とは限りません。
フォーマットされた日付に対して作業したい場合は、
C<Date::Manip>, C<Date::Calc>, C<DateTime> といったモジュールが
助けになるかもしれません。

=head2 How can I take a string and turn it into epoch seconds?

(文字列を受け取って、それを紀元からの経過秒数に変換するには?)

=begin original

If it's a regular enough string that it always has the same format,
you can split it up and pass the parts to C<timelocal> in the standard
C<Time::Local> module.  Otherwise, you should look into the C<Date::Calc>
and C<Date::Manip> modules from CPAN.

=end original

もしそれが常に同じ書式である十分に標準的な文字列であれば、それを分割して、
その部分部分を標準の Time::Local モジュールの C<timelocal> に渡せます。
さもなければ、CPAN にある C<Date::Calc> モジュールと
C<Date::Manip> モジュールを見るべきでしょう。

=head2 How can I find the Julian Day?

(ユリウス日を求めるには?)

=begin original

(contributed by brian d foy and Dave Cross)

=end original

(brian d foy と Dave Cross によって寄贈されました)

=begin original

You can use the C<Time::JulianDay> module available on CPAN.  Ensure
that you really want to find a Julian day, though, as many people have
different ideas about Julian days.  See
http://www.hermetic.ch/cal_stud/jdn.htm for instance.

=end original

CPAN にある C<Time::JulianDay> モジュールが使えます。
しかし、本当にユリウス日がほしいのか確認してください;
多くの人々がユリウス日に関して異なる考え方を持っています。
例としては、http://www.hermetic.ch/cal_stud/jdn.htm を参照してください。

=begin original

You can also try the C<DateTime> module, which can convert a date/time
to a Julian Day.

=end original

日付・時刻をユリウス日に変換できる、C<DateTime> モジュールを試すことも
できます。

	$ perl -MDateTime -le'print DateTime->today->jd'
	2453401.5

=begin original

Or the modified Julian Day

=end original

あるいは準ユリウス日にも変換できます:

	$ perl -MDateTime -le'print DateTime->today->mjd'
	53401

=begin original

Or even the day of the year (which is what some people think of as a
Julian day)

=end original

あるいは年の何日目か(これがユリウス日だと考える人もいます)にも変換できます:

	$ perl -MDateTime -le'print DateTime->today->doy'
	31

=head2 How do I find yesterday's date?

(昨日の日付を得るには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

Use one of the Date modules. The C<DateTime> module makes it simple, and
give you the same time of day, only the day before.

=end original

Date モジュールの一つを使いましょう。
C<DateTime> モジュールは単純で、前日の同じ時刻を返します。

	use DateTime;

	my $yesterday = DateTime->now->subtract( days => 1 );

	print "Yesterday was $yesterday\n";

=begin original

You can also use the C<Date::Calc> module using its C<Today_and_Now>
function.

=end original

C<Date::Calc> モジュールの C<Today_and_Now> 関数を使うこともできます。

	use Date::Calc qw( Today_and_Now Add_Delta_DHMS );

	my @date_time = Add_Delta_DHMS( Today_and_Now(), -1, 0, 0, 0 );

	print "@date_time\n";

=begin original

Most people try to use the time rather than the calendar to figure out
dates, but that assumes that days are twenty-four hours each.  For
most people, there are two days a year when they aren't: the switch to
and from summer time throws this off. Let the modules do the work.

=end original

ほとんどの人は日付を計算するのにカレンダーではなく時刻を使おうとしますが、
これは 1 日が 24 時間であることを仮定しています。
ほとんどの人々にとって、そうではない日が 2 日あります:
夏時間が始まる日と終わる日はこれを狂わせます。
この作業はモジュールにさせましょう。

=head2 Does Perl have a Year 2000 problem? Is Perl Y2K compliant?

(Perl には 2000 年問題があるのですか? Perl は 2000 年対応ですか?)

=begin original

Short answer: No, Perl does not have a Year 2000 problem.  Yes, Perl is
Y2K compliant (whatever that means). The programmers you've hired to
use it, however, probably are not.

=end original

短い答: いいえ、Perl には 2000 年問題はありません。
はい、Perl は(どのような意味でも) 2000 年対応です。
ただし、あなたの雇っているプログラマがそうでないように
使っているなら 2000 年問題はあります。

=begin original

Long answer: The question belies a true understanding of the issue.
Perl is just as Y2K compliant as your pencil--no more, and no less.
Can you use your pencil to write a non-Y2K-compliant memo?  Of course
you can.  Is that the pencil's fault?  Of course it isn't.

=end original

長い答: この質問は物事の理解を誤っています。
Perl はあなたの鉛筆と同じぐらいに Y2K 対応です。
それ以上でもそれ以下でもありません。
あなたの鉛筆を使って Y2K 対応でないメモを書けますか? もちろん書けます。
それは鉛筆のせいですか? もちろん違います。

=begin original

The date and time functions supplied with Perl (gmtime and localtime)
supply adequate information to determine the year well beyond 2000
(2038 is when trouble strikes for 32-bit machines).  The year returned
by these functions when used in a list context is the year minus 1900.
For years between 1910 and 1999 this I<happens> to be a 2-digit decimal
number. To avoid the year 2000 problem simply do not treat the year as
a 2-digit number.  It isn't.

=end original

Perl に組み込みの日付・時刻関数(gmtimeとlocaltime)は
2000 年を越えた年も区別するために必要な情報を提供しています
(32 ビットマシンをトラブルが直撃するのは2038年です)。
これらの関数がリストコンテキストで使われたときに返す年数は
実際の年から 1900 を引いた値です。1910 年から 1999 年は
このやり方では B<たまたま> 二桁の数値となります。
2000 年問題を避けるには、年を二桁で扱わないようにします。

=begin original

When gmtime() and localtime() are used in scalar context they return
a timestamp string that contains a fully-expanded year.  For example,
C<$timestamp = gmtime(1005613200)> sets $timestamp to "Tue Nov 13 01:00:00
2001".  There's no year 2000 problem here.

=end original

gmtime() や localtime() は、スカラコンテキストで呼び出された場合には
完全な年を含んでいるタイムスタンプ文字列を返します。
たとえば、C<$timestamp = gmtime(1005613200)> は
$timestamp に "Tue Nov 13 01:00:00 2001" をセットします。
ここには 2000 年問題はありません。

=begin original

That doesn't mean that Perl can't be used to create non-Y2K compliant
programs.  It can.  But so can your pencil.  It's the fault of the user,
not the language.  At the risk of inflaming the NRA: "Perl doesn't
break Y2K, people do."  See http://www.perl.org/about/y2k.html for
a longer exposition.

=end original

このことは、Perl で 2000 年問題を起こすようなプログラムを作るのに
使えないということではありません。あなたの使う鉛筆も
そうであるように。つまり、言語にまつわるミスではなく、使う人の
間違いであるということです。
NRA を刺激するかもしれませんが、
「Perl は 2000 年問題を打ち破らない。人が打ち破るのだ。」ということです。
詳しい説明は http://www.perl.org/about/y2k.html を参照してください。

=head1 Data: Strings

(データ: 文字列)

=head2 How do I validate input?

(入力を検査するには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

There are many ways to ensure that values are what you expect or
want to accept. Besides the specific examples that we cover in the
perlfaq, you can also look at the modules with "Assert" and "Validate"
in their names, along with other modules such as C<Regexp::Common>.

=end original

値があなたの予測している、または受け入れたいものであることを保証するには
多くの方法があります。
perlfaq でカバーする特定の例の他に、名前に "Assert" や "Validate" がある
モジュールや、C<Regexp::Common> のようなその他のモジュールを
見ることもできます。

=begin original

Some modules have validation for particular types of input, such
as C<Business::ISBN>, C<Business::CreditCard>, C<Email::Valid>,
and C<Data::Validate::IP>.

=end original

C<Business::ISBN>, C<Business::CreditCard>, C<Email::Valid>,
C<Data::Validate::IP> のように、特定の種類の入力を検査するための
モジュールもあります。

=head2 How do I unescape a string?

(文字列のアンエスケープ (unescape)をするには?)

=begin original

It depends just what you mean by "escape".  URL escapes are dealt
with in L<perlfaq9>.  Shell escapes with the backslash (C<\>)
character are removed with

=end original

それはあなたのいう「エスケープ」がなんであるかによります。
URL のエスケープは L<perlfaq9> で扱っています。
バックスラッシュによるシェルエスケープは以下のようにして取り除きます:

	s/\\(.)/$1/g;

=begin original

This won't expand C<"\n"> or C<"\t"> or any other special escapes.

=end original

これは C<\n> だとか C<\t>、あるいはその他の特殊なエスケープを展開しません。

=head2 How do I remove consecutive pairs of characters?

(キャラクタの連続した組を取り除くには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

You can use the substitution operator to find pairs of characters (or
runs of characters) and replace them with a single instance. In this
substitution, we find a character in C<(.)>. The memory parentheses
store the matched character in the back-reference C<\1> and we use
that to require that the same thing immediately follow it. We replace
that part of the string with the character in C<$1>.

=end original

文字の組(または文字の並び)を探して、それを一つの実体に置き換えるには
置換演算子が使えます。
この置換で、C<(.)> で一文字が見付かります。
記憶用のかっこはマッチングした文字を後方参照 C<\1> に保管し、
同じ文字を直後に要求するために使います。
文字列の一部を C<$1> にある文字で置き換えます。

	s/(.)\1/$1/g;

=begin original

We can also use the transliteration operator, C<tr///>. In this
example, the search list side of our C<tr///> contains nothing, but
the C<c> option complements that so it contains everything. The
replacement list also contains nothing, so the transliteration is
almost a no-op since it won't do any replacements (or more exactly,
replace the character with itself). However, the C<s> option squashes
duplicated and consecutive characters in the string so a character
does not show up next to itself

=end original

文字変換演算子 C<tr///> も使えます。
この例では、C<tr///> の検索リスト側は何も入っていませんが、C<c> オプションが
ついているので全てが含まれます。
置き換えリスト側にも何も入っていないので、文字変換はほとんど何もしません
(より厳密には、文字はその文字自身に置き換えられます)。
しかし、C<s> オプションは文字列中の重複していて連続した文字を 1 文字に
短縮するので、次に同じ文字がある文字は表示されません:

	my $str = 'Haarlem';   # in the Netherlands
	$str =~ tr///cs;       # Now Harlem, like in New York

=head2 How do I expand function calls in a string?

(文字列中にある関数呼び出しを展開するには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

This is documented in L<perlref>, and although it's not the easiest
thing to read, it does work. In each of these examples, we call the
function inside the braces used to dereference a reference. If we
have more than one return value, we can construct and dereference an
anonymous array. In this case, we call the function in list context.

=end original

これは L<perlref> に文書化されていて、もっとも読みやすいものでは
ありませんが、動きます。
これらの例のそれぞれにおいて、大かっこの内側の関数はリファレンスを
デリファレンスするために呼び出します。
もし複数の返り値がある場合、無名配列を構築して、デリファレンスします。
この場合、関数をリストコンテキストで呼び出します。

	print "The time values are @{ [localtime] }.\n";

=begin original

If we want to call the function in scalar context, we have to do a bit
more work. We can really have any code we like inside the braces, so
we simply have to end with the scalar reference, although how you do
that is up to you, and you can use code inside the braces. Note that
the use of parens creates a list context, so we need C<scalar> to
force the scalar context on the function:

=end original

スカラコンテキストで関数を呼び出したい場合、もう少し作業が必要です。
実際に置きたいどんなコードでも中かっこの中に置けるので、
(それをどのようにするかはあなた次第で、中かっこのなかのコードを使えますが)
単にスカラリファレンスで終了する必要があります。
かっこはリストコンテキストを作成するので、関数内でスカラコンテキストを
強制するために C<scalar> が必要であることに注意してください:

	print "The time is ${\(scalar localtime)}.\n"

	print "The time is ${ my $x = localtime; \$x }.\n";

=begin original

If your function already returns a reference, you don't need to create
the reference yourself.

=end original

関数がすでにリファレンスを返す場合、自分でリファレンスを作る必要は
ありません。

	sub timestamp { my $t = localtime; \$t }

	print "The time is ${ timestamp() }.\n";

=begin original

The C<Interpolation> module can also do a lot of magic for you. You can
specify a variable name, in this case C<E>, to set up a tied hash that
does the interpolation for you. It has several other methods to do this
as well.

=end original

C<Interpolation> モジュールもまたあなたのために多くの魔法を使います。
展開を行う tie されたハッシュを設定するための変数名(この場合は C<E>)を
指定できます。
同じようにこれを行うその他のいくつかのメソッドを持っています。

	use Interpolation E => 'eval';
	print "The time values are $E{localtime()}.\n";

=begin original

In most cases, it is probably easier to simply use string concatenation,
which also forces scalar context.

=end original

ほとんどの場合、文字列連結を使ってスカラコンテキストに強制するほうが
おそらくより簡単です。

	print "The time is " . localtime() . ".\n";

=head2 How do I find matching/nesting anything?

(何かがマッチしている/ネストしているということを検出するには?)

=begin original

This isn't something that can be done in one regular expression, no
matter how complicated.  To find something between two single
characters, a pattern like C</x([^x]*)x/> will get the intervening
bits in $1. For multiple ones, then something more like
C</alpha(.*?)omega/> would be needed. But none of these deals with
nested patterns.  For balanced expressions using C<(>, C<{>, C<[> or
C<< < >> as delimiters, use the CPAN module Regexp::Common, or see
L<perlre/(??{ code })>.  For other cases, you'll have to write a
parser.

=end original

これは一つの正規表現で解決できないほどの複雑な問題なのです。
単一のキャラクター二つに囲まれた何かを見つけだすには、 
C</x([^x]*)x/> といったパターンを使えば $1 に検査の結果が得られるでしょう。
複数キャラクターに囲まれたものの場合は、
C</alpha(.*?)omega/> のようなパターンが必要となるでしょう。
しかし、ネストしたパターンを扱うようなものはありませんし、できません。
C<(>, C<{>, C<[>, C<< < >> のいずれかのバランス表現をデリミタとして
使っている場合、CPAN にある Regexp::Common モジュールを使うか、
L<perlre/(??{ code })> を参照してください。
その他の場合では、パーサーを書く必要があります。

=begin original

If you are serious about writing a parser, there are a number of
modules or oddities that will make your life a lot easier.  There are
the CPAN modules C<Parse::RecDescent>, C<Parse::Yapp>, and
C<Text::Balanced>; and the C<byacc> program. Starting from perl 5.8
the C<Text::Balanced> is part of the standard distribution.

=end original

もしまじめにパーザを作ろうと考えているのなら、
それを手助けしてくれるようなモジュールやその他のプログラムがあります。
CPAN には C<Parse::RecDescent>, C<Parse::Yapp>, C<Text::Balanced>
がありますし、C<byacc> プログラムもあります。
perl 5.8 から、C<Text::Balanced> は標準配布の一部になりました。

=begin original

One simple destructive, inside-out approach that you might try is to
pull out the smallest nesting parts one at a time:

=end original

単純で破壊的な inside-out アプローチもあります。
これは以下のようにして一度に最小のネスト部分を取り出そうというものです。

	while (s/BEGIN((?:(?!BEGIN)(?!END).)*)END//gs) {
		# do something with $1
		}

=begin original

A more complicated and sneaky approach is to make Perl's regular
expression engine do it for you.  This is courtesy Dean Inada, and
rather has the nature of an Obfuscated Perl Contest entry, but it
really does work:

=end original

より複雑で巧妙なやり方に Perl の正規表現エンジンを使うというものがあります。
これは Dean Inada によるもので Obfuscated Perl コンテストに
エントリされるような代物ですが、正しく働きます:

=begin original

	# $_ contains the string to parse
	# BEGIN and END are the opening and closing markers for the
	# nested text.

=end original

	# $_ には解析対象の文字列があります
	# BEGINとENDはネストしたテキストの開始と終了とを行います。 

	@( = ('(','');
	@) = (')','');
	($re=$_)=~s/((BEGIN)|(END)|.)/$)[!$3]\Q$1\E$([!$2]/gs;
	@$ = (eval{/$re/},$@!~/unmatched/i);
	print join("\n",@$[0..$#$]) if( $$[-1] );

=head2 How do I reverse a string?

(文字列をひっくり返すには?)

=begin original

Use C<reverse()> in scalar context, as documented in
L<perlfunc/reverse>.

=end original

L<perlfunc/reverse> で説明されているように、スカラコンテキストで
C<reverse()> を使います。

	$reversed = reverse $string;

=head2 How do I expand tabs in a string?

(文字列中にあるタブを展開するには?)

=begin original

You can do it yourself:

=end original

以下のようにしてできます:

	1 while $string =~ s/\t+/' ' x (length($&) * 8 - length($`) % 8)/e;

=begin original

Or you can just use the C<Text::Tabs> module (part of the standard Perl
distribution).

=end original

あるいは、ただ単に C<Text::Tabs> モジュール(標準 Perl 配布キットの一部です)を
使ってもできます。

	use Text::Tabs;
	@expanded_lines = expand(@lines_with_tabs);

=head2 How do I reformat a paragraph?

(段落を整形するには?)

=begin original

Use C<Text::Wrap> (part of the standard Perl distribution):

=end original

C<Text::Wrap> (標準 Perl 配布キットの一部です)を使います。

	use Text::Wrap;
	print wrap("\t", '  ', @paragraphs);

=begin original

The paragraphs you give to C<Text::Wrap> should not contain embedded
newlines.  C<Text::Wrap> doesn't justify the lines (flush-right).

=end original

C<Text::Wrap> に与える段落には埋め込みの改行があってはいけません。
C<Text::Wrap> は行を均等割り付けしません(左寄せします)。

=begin original

Or use the CPAN module C<Text::Autoformat>.  Formatting files can be
easily done by making a shell alias, like so:

=end original

または CPAN の C<Text::Autoformat> モジュールを使ってください。
ファイルの整形は以下のようにシェルエイリアスを作ることによって
簡単に実現できます:

	alias fmt="perl -i -MText::Autoformat -n0777 \
		-e 'print autoformat $_, {all=>1}' $*"

=begin original

See the documentation for C<Text::Autoformat> to appreciate its many
capabilities.

=end original

その多くの能力を評価するために、C<Text::Autoformat> の文書を
参照してください。

=head2 How can I access or change N characters of a string?

(文字列の最初の N 文字にアクセスしたり、それを変更するには?)

=begin original

You can access the first characters of a string with substr().
To get the first character, for example, start at position 0
and grab the string of length 1.

=end original

文字列の先頭の文字へは substr() でアクセスできます。
例えば、最初の文字を得るには、位置 0 から始めて、長さ 1 の文字列を
取得します。

	$string = "Just another Perl Hacker";
	$first_char = substr( $string, 0, 1 );  #  'J'

=begin original

To change part of a string, you can use the optional fourth
argument which is the replacement string.

=end original

文字列の一部を変換するために、省略可能な 4 番目の引数として置き換える
文字列を指定できます。

	substr( $string, 13, 4, "Perl 5.8.0" );

=begin original

You can also use substr() as an lvalue.

=end original

substr() を左辺値として使うこともできます。

	substr( $string, 13, 4 ) =  "Perl 5.8.0";

=head2 How do I change the Nth occurrence of something?

(何かの N 番目のものを変更するには?)

=begin original

You have to keep track of N yourself.  For example, let's say you want
to change the fifth occurrence of C<"whoever"> or C<"whomever"> into
C<"whosoever"> or C<"whomsoever">, case insensitively.  These
all assume that $_ contains the string to be altered.

=end original

自分で N 番目の記録を取る必要があります。
例えば、(大小文字の違いを無視して) 5 番目に現れた
C<"whoever"> か C<"whomever"> を C<"whosoever"> か
C<"whomsoever"> に変更したいと考えているとしましょう。
以下は全て $_ に変更したい文字列が入っているものとします。

	$count = 0;
	s{((whom?)ever)}{
	++$count == 5       # is it the 5th?
	    ? "${2}soever"  # yes, swap
	    : $1            # renege and leave it there
		}ige;

=begin original

In the more general case, you can use the C</g> modifier in a C<while>
loop, keeping count of matches.

=end original

もっと一般的なケースでは、C<while> ループの中で
C</g> 修飾子を使ってマッチの数を数えることもできます。

	$WANT = 3;
	$count = 0;
	$_ = "One fish two fish red fish blue fish";
	while (/(\w+)\s+fish\b/gi) {
		if (++$count == $WANT) {
			print "The third fish is a $1 one.\n";
			}
		}

=begin original

That prints out: C<"The third fish is a red one.">  You can also use a
repetition count and repeated pattern like this:

=end original

これは C<"The third fish is a red one."> のように出力します。
以下のようにパターンの繰り返し回数を指定するやり方もあります:

	/(?:\w+\s+fish\s+){2}(\w+)\s+fish/i;

=head2 How can I count the number of occurrences of a substring within a string?

(ある文字列の中に存在する部分文字列が何個あるのかを数えるには?)

=begin original

There are a number of ways, with varying efficiency.  If you want a
count of a certain single character (X) within a string, you can use the
C<tr///> function like so:

=end original

様々な効率を持った、いろいろなやり方があります。
文字列中に存在しているある単一キャラクター (X) の数を数えたいのであれば、
C<tr///> 関数を使って次のようにできます:

	$string = "ThisXlineXhasXsomeXx'sXinXit";
	$count = ($string =~ tr/X//);
	print "There are $count X characters in the string";

=begin original

This is fine if you are just looking for a single character.  However,
if you are trying to count multiple character substrings within a
larger string, C<tr///> won't work.  What you can do is wrap a while()
loop around a global pattern match.  For example, let's count negative
integers:

=end original

これは単一キャラクターを対象にするのであればちょうどいいものですが、
大きな文字列中の、複数キャラクターから構成される部分文字列の数を
数えようとしても、C<tr///> はうまく動作しません。
ここで可能なのは、グローバルなパターンマッチを while() で囲んでしまうという
ものです。たとえば、負の数を数えるのならこうします:

	$string = "-9 55 48 -2 23 -76 4 14 -44";
	while ($string =~ /-\d+/g) { $count++ }
	print "There are $count negative numbers in the string";

=begin original

Another version uses a global match in list context, then assigns the
result to a scalar, producing a count of the number of matches.

=end original

もう一つのバージョンでは、リストコンテキストでグローバルマッチングを
使って、その結果をスカラに代入することで、マッチングした数を数えます。

	$count = () = $string =~ /-\d+/g;

=head2 How do I capitalize all the words on one line?

(一行にあるすべての単語をキャピタライズするには?)

=begin original

To make the first letter of each word upper case:

=end original

各単語の最初の文字を大文字にするにはこうします:

	$line =~ s/\b(\w)/\U$1/g;

=begin original

This has the strange effect of turning "C<don't do it>" into "C<Don'T
Do It>".  Sometimes you might want this.  Other times you might need a
more thorough solution (Suggested by brian d foy):

=end original

これには、"C<don't do it>" を "C<Don'T Do It>" にしてしまうような
妙な効果があります。
あなたがしたいのはこれでいいのかもしれません。
そうでないときには、以下のようにする必要があります
(Brian d Foy の提案によります):

	$string =~ s/ (
				 (^\w)    #at the beginning of the line
				   |      # or
				 (\s\w)   #preceded by whitespace
				   )
				/\U$1/xg;

	$string =~ s/([\w']+)/\u\L$1/g;

=begin original

To make the whole line upper case:

=end original

行全体を大文字にするにはこうします:

	$line = uc($line);

=begin original

To force each word to be lower case, with the first letter upper case:

=end original

全ての語を小文字にし、それぞれの語の最初の文字を大文字にするには
こうします:

	$line =~ s/(\w+)/\u\L$1/g;

=begin original

You can (and probably should) enable locale awareness of those
characters by placing a C<use locale> pragma in your program.
See L<perllocale> for endless details on locales.

=end original

プログラムの中に C<use locale> を置くことによって、
これらのキャラクターがロカールを意識するようにできます
(また、そうすべきです)。
ロカールに関する詳細は L<perllocale> を参照してください。

=begin original

This is sometimes referred to as putting something into "title
case", but that's not quite accurate.  Consider the proper
capitalization of the movie I<Dr. Strangelove or: How I Learned to
Stop Worrying and Love the Bomb>, for example.

=end original

これは“title case”として扱われることがありますが、
それは正確なものではありません。
例えば映画のタイトルである
I<Dr. Strangelove or: How I Learned to Stop Worrying and Love the Bomb>
(邦題「博士の異常な愛情 または私は如何にして心配するのを止めて
水爆を愛するようになったか」)
を考えてみましょう。

=begin original

Damian Conway's L<Text::Autoformat> module provides some smart
case transformations:

=end original

Damian Conway による L<Text::Autoformat> モジュールは、いくつかの
賢い大文字小文字変換を提供します:

	use Text::Autoformat;
	my $x = "Dr. Strangelove or: How I Learned to Stop ".
	  "Worrying and Love the Bomb";

	print $x, "\n";
	for my $style (qw( sentence title highlight )) {
		print autoformat($x, { case => $style }), "\n";
		}

=head2 How can I split a [character] delimited string except when inside [character]?

((とある文字)の内側にある時を除き、(とある文字)で終端されている文字列を
分割するには?)

=begin original

Several modules can handle this sort of parsing--C<Text::Balanced>,
C<Text::CSV>, C<Text::CSV_XS>, and C<Text::ParseWords>, among others.

=end original

いくつかのモジュールがこのようなパースを扱います-- C<Text::Balanced>,
C<Text::CSV>, C<Text::CSV_XS>, C<Text::ParseWords> などです。

=begin original

Take the example case of trying to split a string that is
comma-separated into its different fields. You can't use C<split(/,/)>
because you shouldn't split if the comma is inside quotes.  For
example, take a data line like this:

=end original

カンマで分割された文字列を別々のフィールドに置くような例を
考えてみましょう。
ここで C<split(/,/)> を使うことはできません。
なぜなら、クォートの内側にあるカンマで分割すべきではないからです。
例えば以下のようなデータを考えてみましょう。

	SAR001,"","Cimetrix, Inc","Bob Smith","CAM",N,8,1,0,7,"Error, Core Dumped"

=begin original

Due to the restriction of the quotes, this is a fairly complex
problem.  Thankfully, we have Jeffrey Friedl, author of
I<Mastering Regular Expressions>, to handle these for us.  He
suggests (assuming your string is contained in C<$text>):

=end original

クォートの制約のためにこれは実に複雑な問題です。
ありがたいことに、私たちには I<Mastering Regular Expressions> の著者でもあり、
この問題を私たちのために扱ってくれる Jeffrey Friedl がいます。
彼の提案はこうです(文字列が C<$text> にあると仮定しています):

	 @new = ();
	 push(@new, $+) while $text =~ m{
		 "([^\"\\]*(?:\\.[^\"\\]*)*)",?  # groups the phrase inside the quotes
		| ([^,]+),?
		| ,
		}gx;
	 push(@new, undef) if substr($text,-1,1) eq ',';

=begin original

If you want to represent quotation marks inside a
quotation-mark-delimited field, escape them with backslashes (eg,
C<"like \"this\"">.

=end original

クォーテーションマークで終端されたフィールドの中で
クォーテーションマークを表現したいのならば、
それをバックスラッシュで(C<"like \"this\""> のように)エスケープしてください。

=begin original

Alternatively, the C<Text::ParseWords> module (part of the standard
Perl distribution) lets you say:

=end original

あるいは、C<Text::PaserWords> モジュール(標準 Perl 配布の一部です)を
使ってこうします:

	use Text::ParseWords;
	@new = quotewords(",", 0, $text);

=head2 How do I strip blank space from the beginning/end of a string?

(文字列の先頭や末尾にある空白を剥ぎ取るには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

A substitution can do this for you. For a single line, you want to
replace all the leading or trailing whitespace with nothing. You
can do that with a pair of substitutions.

=end original

置換を使うことで行えます。
1 行では、先頭か末尾のどちらかの空白全てを削除します。
2 つの置換でこれが行えます。

	s/^\s+//;
	s/\s+$//;

=begin original

You can also write that as a single substitution, although it turns
out the combined statement is slower than the separate ones. That
might not matter to you, though.

=end original

これを 1 回の置換で書くこともできますが、組み合わせた文は分かれている
文よりも遅くなります。
しかし、それはあなたには問題がないかもしれません。

	s/^\s+|\s+$//g;

=begin original

In this regular expression, the alternation matches either at the
beginning or the end of the string since the anchors have a lower
precedence than the alternation. With the C</g> flag, the substitution
makes all possible matches, so it gets both. Remember, the trailing
newline matches the C<\s+>, and  the C<$> anchor can match to the
physical end of the string, so the newline disappears too. Just add
the newline to the output, which has the added benefit of preserving
"blank" (consisting entirely of whitespace) lines which the C<^\s+>
would remove all by itself.

=end original

この正規表現において、アンカーは the alternation より低い優先順位を
持つので、the alternation は文字列の先頭か末尾にマッチングします。
C</g> フラグが付いていることにより、可能な全てのマッチングについて置換が
行われるので、先頭と末尾の両方で行われます。
引き続く改行は C<\s+> にマッチングし、C<$> アンカーは文字列の物理的な
末尾にマッチングするので、改行も消えることを忘れないでください。
単に出力に改行を追加することで、C<^\s+> がすべて削除してしまう「空の」
(空白だけからなる)行を保存する利点が追加されます。

	while( <> )
		{
		s/^\s+|\s+$//g;
		print "$_\n";
		}

=begin original

For a multi-line string, you can apply the regular expression
to each logical line in the string by adding the C</m> flag (for
"multi-line"). With the C</m> flag, the C<$> matches I<before> an
embedded newline, so it doesn't remove it. It still removes the
newline at the end of the string.

=end original

複数行の文字列に対しては、C</m> ("multi-line") フラグを追加することにより、
文字列中の論理行毎に正規表現を適用できます。
C</m> フラグをつけると、C<$> 組み込まれた改行の I<前に> マッチングするので、
これを取り除けません。
文字列の末尾の改行は取り除けます。

	$string =~ s/^\s+|\s+$//gm;

=begin original

Remember that lines consisting entirely of whitespace will disappear,
since the first part of the alternation can match the entire string
and replace it with nothing. If need to keep embedded blank lines,
you have to do a little more work. Instead of matching any whitespace
(since that includes a newline), just match the other whitespace.

=end original

空白だけからなる文字列は、置換の最初の部分が文字列全体にマッチングして、
それを空文字列に置き換えてしまうので、消えてしまうことに注意してください。
もし組み込まれている空行を保存したいなら、さらにもう少し作業をする必要が
あります。
全ての空白(改行を含みます)にマッチングさせる代わりに、単にその他の
空白にマッチングさせます。

	$string =~ s/^[\t\f ]+|[\t\f ]+$//mg;

=head2 How do I pad a string with blanks or pad a number with zeroes?

(文字列に空白をパッディングしたり、数値にゼロをパッディングしたりするには?)

=begin original

In the following examples, C<$pad_len> is the length to which you wish
to pad the string, C<$text> or C<$num> contains the string to be padded,
and C<$pad_char> contains the padding character. You can use a single
character string constant instead of the C<$pad_char> variable if you
know what it is in advance. And in the same way you can use an integer in
place of C<$pad_len> if you know the pad length in advance.

=end original

以下に挙げる例で、C<$pad_len> はパッディングしたい文字列の長さです。
C<$text> や C<$num> は文字列にパッディングの対象となる内容を保持していて、
C<$pad_char> がパッディングに使いたいキャラクターを保持しています。
やっていることがわかっているのなら、C<$pad_char> という変数の代わりに一
文字のキャラクター文字列を使うこともできます。
そして同様に、パッディングしたい長さが予め分かっているなら、
C<$pad_len> に整数値を指定することも出来ます。

=begin original

The simplest method uses the C<sprintf> function. It can pad on the left
or right with blanks and on the left with zeroes and it will not
truncate the result. The C<pack> function can only pad strings on the
right with blanks and it will truncate the result to a maximum length of
C<$pad_len>.

=end original

最も単純なやり方は C<sprintf> 関数を使うというものです。
この関数は文字列の左や右にパッディングを行ったり、0 を左に置いたりする
ことができます。
C<pack> 関数は文字列の右側に空白でパッディングすることと、
結果の最大長を C<$pad_len> に切り詰めることだけができます。

	# Left padding a string with blanks (no truncation):
	$padded = sprintf("%${pad_len}s", $text);
	$padded = sprintf("%*s", $pad_len, $text);  # same thing

	# Right padding a string with blanks (no truncation):
	$padded = sprintf("%-${pad_len}s", $text);
	$padded = sprintf("%-*s", $pad_len, $text); # same thing

	# Left padding a number with 0 (no truncation):
	$padded = sprintf("%0${pad_len}d", $num);
	$padded = sprintf("%0*d", $pad_len, $num); # same thing

	# Right padding a string with blanks using pack (will truncate):
	$padded = pack("A$pad_len",$text);

=begin original

If you need to pad with a character other than blank or zero you can use
one of the following methods.  They all generate a pad string with the
C<x> operator and combine that with C<$text>. These methods do
not truncate C<$text>.

=end original

空白やゼロ以外のキャラクターでパッディングを行いたいのであれば、
以下に挙げるやり方を使うことができます。これらは全て
パッディング文字列を C<x> 修飾子で生成して C<$text> と結合します。
これらのメソッドは C<$text> を切り詰めません。

=begin original

Left and right padding with any character, creating a new string:

=end original

任意のキャラクターによる左詰めと右詰めを行い、新しい文字列を作ります:

	$padded = $pad_char x ( $pad_len - length( $text ) ) . $text;
	$padded = $text . $pad_char x ( $pad_len - length( $text ) );

=begin original

Left and right padding with any character, modifying C<$text> directly:

=end original

任意のキャラクターによる左詰めと右詰めを行い、C<$text> を直接変更します:

	substr( $text, 0, 0 ) = $pad_char x ( $pad_len - length( $text ) );
	$text .= $pad_char x ( $pad_len - length( $text ) );

=head2 How do I extract selected columns from a string?

(文字列から選択されたカラムを取り出すには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

If you know where the columns that contain the data, you can
use C<substr> to extract a single column.

=end original

データが含まれている桁が分かっているなら、単一の桁を展開するために
C<substr> が使えます。

	my $column = substr( $line, $start_column, $length );

=begin original

You can use C<split> if the columns are separated by whitespace or
some other delimiter, as long as whitespace or the delimiter cannot
appear as part of the data.

=end original

桁が空白やその他のデリミタで分けられていて、データの一部としては
空白やデリミタが現れないなら、C<split> が使えます。

	my $line    = ' fred barney   betty   ';
	my @columns = split /\s+/, $line;
		# ( '', 'fred', 'barney', 'betty' );

	my $line    = 'fred||barney||betty';
	my @columns = split /\|/, $line;
		# ( 'fred', '', 'barney', '', 'betty' );

=begin original

If you want to work with comma-separated values, don't do this since
that format is a bit more complicated. Use one of the modules that
handle that fornat, such as C<Text::CSV>, C<Text::CSV_XS>, or
C<Text::CSV_PP>.

=end original

カンマ区切りの値(CSV)を扱いたい場合は、フォーマットが少し複雑なので
これはしないで下さい。
C<Text::CSV>, C<Text::CSV_XS>, C<Text::CSV_PP> のような、この
フォーマットを扱うためのモジュールの一つを使ってください。

=begin original

If you want to break apart an entire line of fixed columns, you can use
C<unpack> with the A (ASCII) format. by using a number after the format
specifier, you can denote the column width. See the C<pack> and C<unpack>
entries in L<perlfunc> for more details.

=end original

固定桁の行全体を分解したいなら、C<unpack> の A (ASCII) フォーマットが
使えます。
フォーマット指定子の後に数値をつけることで、桁数を指定できます。
更なる詳細については L<perlfunc> の C<pack> と C<unpack> の項目を
参照してください。

	my @fields = unpack( $line, "A8 A8 A8 A16 A4" );

=begin original

Note that spaces in the format argument to C<unpack> do not denote literal
spaces. If you have space separated data, you may want C<split> instead.

=end original

C<unpack> のフォーマット引数での空白はリテラルな空白を意味しないことに
注意してください。
もし空白で区切られたデータがあるなら、代わりに C<split> を使ったほうが
いいかもしれません。

=head2 How do I find the soundex value of a string?

(文字列の soundex 値を見つけるには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

You can use the Text::Soundex module. If you want to do fuzzy or close
matching, you might also try the C<String::Approx>, and
C<Text::Metaphone>, and C<Text::DoubleMetaphone> modules.

=end original

Text::Soundex モジュールが使えます。
あいまいマッチングや近傍マッチングを行いたいなら、
C<String::Approx>, C<Text::Metaphone>, C<Text::DoubleMetaphone> といった
モジュールを試すのも良いでしょう。

=head2 How can I expand variables in text strings?

(テキスト文字列の中にある変数を展開するには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

If you can avoid it, don't, or if you can use a templating system,
such as C<Text::Template> or C<Template> Toolkit, do that instead. You
might even be able to get the job done with C<sprintf> or C<printf>:

=end original

もし避けることが可能なら、してはいけません;
あるいは、C<Text::Template> や C<Template> ツールキットのような
テンプレートシステムが使えるなら、これらを代わりに使ってください。
C<sprintf> や C<printf> を使って作業をこなすことすらできます:

	my $string = sprintf 'Say hello to %s and %s', $foo, $bar;

=begin original

However, for the one-off simple case where I don't want to pull out a
full templating system, I'll use a string that has two Perl scalar
variables in it. In this example, I want to expand C<$foo> and C<$bar>
to their variable's values:

=end original

しかし、完全なテンプレートシステムを引っ張り出したくないような一度限りの
簡単な場合には、内部に二つの Perl スカラ変数を持つ文字列を使います。
この例では、C<$foo> と C<$bar> をその変数の値に展開したいとします:

	my $foo = 'Fred';
	my $bar = 'Barney';
	$string = 'Say hello to $foo and $bar';

=begin original

One way I can do this involves the substitution operator and a double
C</e> flag.  The first C</e> evaluates C<$1> on the replacement side and
turns it into C<$foo>. The second /e starts with C<$foo> and replaces
it with its value. C<$foo>, then, turns into 'Fred', and that's finally
what's left in the string:

=end original

これを行う一つの方法は、置換演算子と二つの C</e> フラグを使うものです。
一つ目の C</e> は置き換え側の C<$1> を評価して C<$foo> に変えます。
二つ目の C</e> は C<$foo> をその値に変えます。
従って、C<$foo> は 'Fred' に変わって、それが結局最終的に文字列に
残されるものになります:

	$string =~ s/(\$\w+)/$1/eeg; # 'Say hello to Fred and Barney'

=begin original

The C</e> will also silently ignore violations of strict, replacing
undefined variable names with the empty string. Since I'm using the
C</e> flag (twice even!), I have all of the same security problems I 
have with C<eval> in its string form. If there's something odd in
C<$foo>, perhaps something like C<@{[ system "rm -rf /" ]}>, then
I could get myself in trouble.

=end original

C</e> は暗黙のうちに struct 違反を無視するので、未定義の変数名を
空文字列に置き換えます。
C</e> フラグを (2 回も!) 使っているので、C<eval> を文字列の形で使うのと
同じセキュリティ問題を全て抱えています。
もし C<$foo> に(おそらく C<@{[ system "rm -rf /" ]}> のような)変なものが
入っていたら、トラブルに出会うことになります。

=begin original

To get around the security problem, I could also pull the values from
a hash instead of evaluating variable names. Using a single C</e>, I
can check the hash to ensure the value exists, and if it doesn't, I
can replace the missing value with a marker, in this case C<???> to
signal that I missed something:

=end original

セキュリティ問題を避けるために、変数名を評価するのではなくハッシュから
値を取ってくることもできます。
C</e> を一つ使って、ハッシュに値があることを確認し、もしなければ、
値をマーカーに置き換えます; この場合は、C<???> が何かがおかしいことの
印です;

	my $string = 'This has $foo and $bar';
	
	my %Replacements = (
		foo  => 'Fred',
		);

	# $string =~ s/\$(\w+)/$Replacements{$1}/g;
	$string =~ s/\$(\w+)/
		exists $Replacements{$1} ? $Replacements{$1} : '???'
		/eg;

	print $string;

=head2 What's wrong with always quoting "$vars"?

(常にクォーティング "$vars" することの何が悪いの?)

=begin original

The problem is that those double-quotes force
stringification--coercing numbers and references into strings--even
when you don't want them to be strings.  Think of it this way:
sdouble-quote expansion is used to produce new strings.  If you already
have a string, why do you need more?

=end original

そういったダブルクォートが、強制的に文字列化(stringification)するのが問題で、
たとえそれを望んでいなくても数値やリファレンスが強制的に
文字列に変換されてしまうのです。
このように考えましょう:
ダブルクォートは新しい文字列を生成するのに使われる。
もしあなたがすでに文字列を持っているのであれば、使う必要が
あるでしょうか?

=begin original

If you get used to writing odd things like these:

=end original

以下の例のような変な書き方をすると:

	print "$var";   	# BAD
	$new = "$old";   	# BAD
	somefunc("$var");	# BAD

=begin original

You'll be in trouble.  Those should (in 99.8% of the cases) be
the simpler and more direct:

=end original

あなたはトラブルに巻き込まれることになるでしょう。
これらは(99.8% は)、より単純、かつより直接的に書くべきなのです。

	print $var;
	$new = $old;
	somefunc($var);

=begin original

Otherwise, besides slowing you down, you're going to break code when
the thing in the scalar is actually neither a string nor a number, but
a reference:

=end original

さもなければ、プログラムを遅くなることのほかにも、スカラが実際には文字列でも
数値でもなくリファレンスであるようなときにあなたのプログラムが
おかしくなることになります。

	func(\@array);
	sub func {
		my $aref = shift;
		my $oref = "$aref";  # WRONG
		}

=begin original

You can also get into subtle problems on those few operations in Perl
that actually do care about the difference between a string and a
number, such as the magical C<++> autoincrement operator or the
syscall() function.

=end original

マジカル C<++> オートインクリメント演算子や syscall() 関数のような、
文字列と数値の間の違いを実際に気にするような Perl の幾つかの操作において、
微妙な問題に直面するかもしれません。

=begin original

Stringification also destroys arrays.

=end original

文字列化(stringfication)も配列を壊します。

	@lines = `command`;
	print "@lines";     # WRONG - extra blanks
	print @lines;       # right

=head2 Why don't my E<lt>E<lt>HERE documents work?

(なぜ私の E<lt>E<lt>HERE ドキュメントがうまく動かないのでしょう?)

=begin original

Check for these three things:

=end original

以下の三つの点を確認してください。

=over 4

=begin original

=item There must be no space after the E<lt>E<lt> part.

=item There (probably) should be a semicolon at the end.

=item You can't (easily) have any space in front of the tag.

=end original

=item E<lt>E<lt> パートの後ろに空白があってはいけません。

=item 終端にセミコロンが置かれているかもしれません。

=item タグの前に任意のスペースを置くことはできません。

=back

=begin original

If you want to indent the text in the here document, you
can do this:

=end original

ヒアドキュメントのテキストでインデントを使いたいのであれば、
以下のようにしてできます:

    # all in one
    ($VAR = <<HERE_TARGET) =~ s/^\s+//gm;
        your text
        goes here
    HERE_TARGET

=begin original

But the HERE_TARGET must still be flush against the margin.
If you want that indented also, you'll have to quote
in the indentation.

=end original

しかしこの場合も HERE_TARGET は先頭に置かなければなりません。
もしこれもインデントしたいのなら、インデントをクォートする必要があるでしょう。

    ($quote = <<'    FINIS') =~ s/^\s+//gm;
            ...we will have peace, when you and all your works have
            perished--and the works of your dark master to whom you
            would deliver us. You are a liar, Saruman, and a corrupter
            of men's hearts.  --Theoden in /usr/src/perl/taint.c
        FINIS
    $quote =~ s/\s+--/\n--/;

=begin original

A nice general-purpose fixer-upper function for indented here documents
follows.  It expects to be called with a here document as its argument.
It looks to see whether each line begins with a common substring, and
if so, strips that substring off.  Otherwise, it takes the amount of leading
whitespace found on the first line and removes that much off each
subsequent line.

=end original

以下はインデントされたヒアドキュメントのための汎用 fixer-upper 関数です。
この関数は引数にヒアドキュメントを渡されることを期待しています。
これは共通の部分文字列で始まる各行について、
その部分文字列を剥ぎ取るということを行います。
あるいは、最初の行の先頭にある空白を取り、
続く行に対しても同じ様に削除を行います。

    sub fix {
        local $_ = shift;
        my ($white, $leader);  # common whitespace and common leading string
        if (/^\s*(?:([^\w\s]+)(\s*).*\n)(?:\s*\1\2?.*\n)+$/) {
            ($white, $leader) = ($2, quotemeta($1));
        } else {
            ($white, $leader) = (/^(\s+)/, '');
        }
        s/^\s*?$leader(?:$white)?//gm;
        return $_;
    }

=begin original

This works with leading special strings, dynamically determined:

=end original

この関数は先頭にある特別な、動的に決められる文字列に対しても使えます:

	$remember_the_main = fix<<'    MAIN_INTERPRETER_LOOP';
	@@@ int
	@@@ runops() {
	@@@     SAVEI32(runlevel);
	@@@     runlevel++;
	@@@     while ( op = (*op->op_ppaddr)() );
	@@@     TAINT_NOT;
	@@@     return 0;
	@@@ }
	MAIN_INTERPRETER_LOOP

=begin original

Or with a fixed amount of leading whitespace, with remaining
indentation correctly preserved:

=end original

また、先頭にある特定の個数の空白を取り除いて、インデントを
正しく残すようなこともできます:

	$poem = fix<<EVER_ON_AND_ON;
       Now far ahead the Road has gone,
	  And I must follow, if I can,
       Pursuing it with eager feet,
	  Until it joins some larger way
       Where many paths and errands meet.
	  And whither then? I cannot say.
		--Bilbo in /usr/src/perl/pp_ctl.c
	EVER_ON_AND_ON

=head1 Data: Arrays

(データ: 配列)

=head2 What is the difference between a list and an array?

(リストと配列の差とはなんですか?)

=begin original

An array has a changeable length.  A list does not.  An array is
something you can push or pop, while a list is a set of values.  Some
people make the distinction that a list is a value while an array is a
variable. Subroutines are passed and return lists, you put things into
list context, you initialize arrays with lists, and you C<foreach()>
across a list.  C<@> variables are arrays, anonymous arrays are
arrays, arrays in scalar context behave like the number of elements in
them, subroutines access their arguments through the array C<@_>, and
C<push>/C<pop>/C<shift> only work on arrays.

=end original

配列は長さを変えることができます。リストはできません。
ある配列に対して push や pop ができますが、
リストに対しては値のセットしかできません。
一部には配列が変数であるのに対してリストは値であると
区別して考えている人達もいます。
リストを受け取ったり返したりするサブルーチンはリストコンテキストに
あなたを導き、リストで配列を初期化したり、C<foreach()> でリストを辿ったりできます。
C<@>変数は配列であり、無名配列も配列です。スカラコンテキストの配列は
その要素数のように振る舞います。
サブルーチンはその引数を C<@_> という配列を通してアクセスし、
C<push>/C<pop>/C<shift> は配列に対してのみ働きます。

=begin original

As a side note, there's no such thing as a list in scalar context.
When you say

=end original

スカラコンテキストでリストとして振る舞うものはないということに
注意してください。
以下のようにすると:

	$scalar = (2, 5, 7, 9);

=begin original

you're using the comma operator in scalar context, so it uses the scalar
comma operator.  There never was a list there at all! This causes the
last value to be returned: 9.

=end original

スカラコンテキストでカンマ演算子を使ったものであり、
スカラカンマ演算子を使います。
これはリストでもなんでもありません!
この結果は最後の値である 9 となります。

=head2 What is the difference between $array[1] and @array[1]?

($array[1] と @array[1] との間の違いはなんですか?)

=begin original

The former is a scalar value; the latter an array slice, making
it a list with one (scalar) value.  You should use $ when you want a
scalar value (most of the time) and @ when you want a list with one
scalar value in it (very, very rarely; nearly never, in fact).

=end original

前者はスカラ値であり、後者は一つのスカラ値を持ったリストを構成する
配列のスライスです。スカラ値を必要とするならば(ほとんど
の場合がこうでしょう)$を使うべきで、@ は一つのスカラ値を持った
リストを必要とするとき(実際のところ、この状況は非常に希でしょう)
に使うべきものです。

=begin original

Sometimes it doesn't make a difference, but sometimes it does.
For example, compare:

=end original

これらはあるときには違いがありませんが、違いがでる場合もあります。
例えば以下のものを:

	$good[0] = `some program that outputs several lines`;

=begin original

with

=end original

次のものと比較する場合です:

	@bad[0]  = `same program that outputs several lines`;

=begin original

The C<use warnings> pragma and the B<-w> flag will warn you about these
matters.

=end original

C<use warnings> プラグマと B<-w> フラグはこのことに関する警告を行います。

=head2 How can I remove duplicate elements from a list or array?

(配列やリストにある重複した要素を削除するには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

Use a hash. When you think the words "unique" or "duplicated", think
"hash keys".

=end original

ハッシュを使ってください。
「ユニーク」や「重複」といった単語を考えたときには、
「ハッシュキー」を考えてください。

=begin original

If you don't care about the order of the elements, you could just
create the hash then extract the keys. It's not important how you
create that hash: just that you use C<keys> to get the unique
elements.

=end original

要素の順番を気にしないなら、単にハッシュを作ってキーを取り出してください。
どのようにハッシュを作るかは重要ではありません:
単にユニークな要素を取り出すために C<keys> を使うためです。

	my %hash   = map { $_, 1 } @array;
	# or a hash slice: @hash{ @array } = ();
	# or a foreach: $hash{$_} = 1 foreach ( @array );

	my @unique = keys %hash;

=begin original

If you want to use a module, try the C<uniq> function from
C<List::MoreUtils>. In list context it returns the unique elements,
preserving their order in the list. In scalar context, it returns the
number of unique elements.

=end original

モジュールを使いたいなら、C<List::MoreUtils> の C<uniq> 関数を
試してみてください。
リストコンテキストでは、リストの順序を保存した形でユニークな要素を返します。
スカラコンテキストでは、ユニークな要素の数を返します。

	use List::MoreUtils qw(uniq);

	my @unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 1,2,3,4,5,6,7
	my $unique = uniq( 1, 2, 3, 4, 4, 5, 6, 5, 7 ); # 7

=begin original

You can also go through each element and skip the ones you've seen
before. Use a hash to keep track. The first time the loop sees an
element, that element has no key in C<%Seen>. The C<next> statement
creates the key and immediately uses its value, which is C<undef>, so
the loop continues to the C<push> and increments the value for that
key. The next time the loop sees that same element, its key exists in
the hash I<and> the value for that key is true (since it's not 0 or
C<undef>), so the next skips that iteration and the loop goes to the
next element.

=end original

各要素を調べて、一度見つけたものをスキップすることもできます。
記録をつけるためにハッシュを使います。
ループが最初に要素を見つけると、この要素は C<%Seen> にキーがありません。
C<next> 文はキーを作り、直ちにその値(C<undef>)を使うので、
ループは C<push> を続行し、このキーの値をインクリメントします。
次回にループが同じ要素を見つけると、ハッシュにはそのキーが存在し、
I<かつ> そのキーの値が(0 でも C<undef> でもないので)真なので、
next は反復をスキップし、ループは次の要素に進みます。

	my @unique = ();
	my %seen   = ();

	foreach my $elem ( @array )
		{
		next if $seen{ $elem }++;
		push @unique, $elem;
		}

=begin original

You can write this more briefly using a grep, which does the
same thing.

=end original

grep を使うことでより簡単に書くこともでき、これは同じことになります。

	my %seen = ();
	my @unique = grep { ! $seen{ $_ }++ } @array;

=head2 How can I tell whether a certain element is contained in a list or array?

(リストや配列の内容にある特定の要素があるかどうかを確かめるには?)

=begin original

(portions of this answer contributed by Anno Siegel)

=end original

(この回答の一部は Anno Siegel によって寄贈されました)

=begin original

Hearing the word "in" is an I<in>dication that you probably should have
used a hash, not a list or array, to store your data.  Hashes are
designed to answer this question quickly and efficiently.  Arrays aren't.

=end original

ハッシュはこの質問に対する速くて効率の良い解答のために
デザインされています。
配列はそうではありません。

=begin original

That being said, there are several ways to approach this.  If you
are going to make this query many times over arbitrary string values,
the fastest way is probably to invert the original array and maintain a
hash whose keys are the first array's values.

=end original

幾つかのやり方がありますが、この問い合わせを多くのアイテムに対して
行いたいとか、値が任意の文字列である場合には最も速いやり方は元の
配列の逆のものを作って元の配列の値をキーとするようなハッシュを
管理するというものです。

	@blues = qw/azure cerulean teal turquoise lapis-lazuli/;
	%is_blue = ();
	for (@blues) { $is_blue{$_} = 1 }

=begin original

Now you can check whether C<$is_blue{$some_color}>.  It might have
been a good idea to keep the blues all in a hash in the first place.

=end original

こうすれば、C<$is_blue{$some_color}> がどうであるかでチェックすることができます。
最初の場所で bules にハッシュのすべてを保持させるのはよい考えでしょう。

=begin original

If the values are all small integers, you could use a simple indexed
array.  This kind of an array will take up less space:

=end original

値のすべてが小さな整数であれば、単純な添え字付き配列を使うことができます。
この種の配列はより少ない場所しか使いません。

	@primes = (2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31);
	@is_tiny_prime = ();
	for (@primes) { $is_tiny_prime[$_] = 1 }
	# or simply  @istiny_prime[@primes] = (1) x @primes;

=begin original

Now you check whether $is_tiny_prime[$some_number].

=end original

これで $is_tiny_prime[$some_number] の内容がどうであるかで
チェックすることができます。

=begin original

If the values in question are integers instead of strings, you can save
quite a lot of space by using bit strings instead:

=end original

問い合わせる値が文字列ではなく整数であるのならば、ビットストリングを
使うことによって大幅に空間を節約することができます。

	@articles = ( 1..10, 150..2000, 2017 );
	undef $read;
	for (@articles) { vec($read,$_,1) = 1 }

=begin original

Now check whether C<vec($read,$n,1)> is true for some C<$n>.

=end original

これで C<vec($read,$n,1)> が真かどうかで C<$n> の検査ができます。

=begin original

These methods guarantee fast individual tests but require a re-organization
of the original list or array.  They only pay off if you have to test
multiple values against the same array.

=end original

これらのメソッドは個々のテストの速さが保証されていますが、
元のリストや配列の再構成が必要です。
同じ配列に対して複数の値をテストする必要がある場合にのみ元が取れます。

=begin original

If you are testing only once, the standard module C<List::Util> exports
the function C<first> for this purpose.  It works by stopping once it
finds the element. It's written in C for speed, and its Perl equivalent
looks like this subroutine:

=end original

一度だけテストする場合、標準モジュール C<List::Util> がこの目的のために
C<first> 関数をエクスポートしています。
これは要素を見つけると停止することで動作します。
速度のために C で書かれていて、これの Perl の等価な処理は、次のサブルーチンの
ようになります:

	sub first (&@) {
		my $code = shift;
		foreach (@_) {
			return $_ if &{$code}();
		}
		undef;
	}

=begin original

If speed is of little concern, the common idiom uses grep in scalar context
(which returns the number of items that passed its condition) to traverse the
entire list. This does have the benefit of telling you how many matches it
found, though.

=end original

速度が問題ではないなら、一般的な方法は、リスト全体をトラバースするために
grep をスカラコンテキストで使う(これで条件をパスしたアイテムの数を返します)
ことです。
しかし、これには何回マッチングしたのかを知らせるという利点があります。

	my $is_there = grep $_ eq $whatever, @array;

=begin original

If you want to actually extract the matching elements, simply use grep in
list context.

=end original

実際にマッチングした要素を展開したい場合は、単にリストコンテキストで
grep を使ってください。

	my @matches = grep $_ eq $whatever, @array;

=head2 How do I compute the difference of two arrays?  How do I compute the intersection of two arrays?

(二つの配列の差(difference)を求めるには?
二つの配列の共通要素(inter section)を求めるには?)

=begin original

Use a hash.  Here's code to do both and more.  It assumes that each
element is unique in a given array:

=end original

ハッシュを使います。
以下のプログラム片は質問の両方を行います。
与えられた配列の要素には重複がないと仮定しています。

	@union = @intersection = @difference = ();
	%count = ();
	foreach $element (@array1, @array2) { $count{$element}++ }
	foreach $element (keys %count) {
		push @union, $element;
		push @{ $count{$element} > 1 ? \@intersection : \@difference }, $element;
		}

=begin original

Note that this is the I<symmetric difference>, that is, all elements
in either A or in B but not in both.  Think of it as an xor operation.

=end original

これは I<対称的差分>、つまり、A か B のどちらかにあって、
両方にあることはない全ての要素である、ということに注意してください。
これは xor 操作のようなものと考えてください。

=head2 How do I test whether two arrays or hashes are equal?

(二つの配列や二つのハッシュが等しいかどうかを検査するには?)

=begin original

The following code works for single-level arrays.  It uses a
stringwise comparison, and does not distinguish defined versus
undefined empty strings.  Modify if you have other needs.

=end original

以下に挙げる例は一レベルの配列に対して有効です。
これは文字列としての比較を使い、定義済みと未定義の空文字列を区別しません。
必要に応じて修正してください。

	$are_equal = compare_arrays(\@frogs, \@toads);

	sub compare_arrays {
		my ($first, $second) = @_;
		no warnings;  # silence spurious -w undef complaints
		return 0 unless @$first == @$second;
		for (my $i = 0; $i < @$first; $i++) {
			return 0 if $first->[$i] ne $second->[$i];
			}
		return 1;
		}

=begin original

For multilevel structures, you may wish to use an approach more
like this one.  It uses the CPAN module C<FreezeThaw>:

=end original

多重レベル構造に対応するために、あなたは以下のような手段を使いたいと
考えるかもしれません。
ここでは CPAN モジュールの C<FreezeThaw> を使っています:

	use FreezeThaw qw(cmpStr);
	@a = @b = ( "this", "that", [ "more", "stuff" ] );

	printf "a and b contain %s arrays\n",
		cmpStr(\@a, \@b) == 0
		? "the same"
		: "different";

=begin original

This approach also works for comparing hashes.  Here we'll demonstrate
two different answers:

=end original

このアプローチはハッシュの比較にも使えます。
以下に二種類の回答をお見せしましょう:

	use FreezeThaw qw(cmpStr cmpStrHard);

	%a = %b = ( "this" => "that", "extra" => [ "more", "stuff" ] );
	$a{EXTRA} = \%b;
	$b{EXTRA} = \%a;

	printf "a and b contain %s hashes\n",
	cmpStr(\%a, \%b) == 0 ? "the same" : "different";

	printf "a and b contain %s hashes\n",
	cmpStrHard(\%a, \%b) == 0 ? "the same" : "different";


=begin original

The first reports that both those the hashes contain the same data,
while the second reports that they do not.  Which you prefer is left as
an exercise to the reader.

=end original

最初のものは二つのハッシュが同じ内容であると報告しますが、二番目の
ものは違うと報告します。

=head2 How do I find the first array element for which a condition is true?

(ある条件が真となる最初の配列要素を見つけだすには?)

=begin original

To find the first array element which satisfies a condition, you can
use the C<first()> function in the C<List::Util> module, which comes
with Perl 5.8. This example finds the first element that contains
"Perl".

=end original

条件を満たす最初の配列要素を探すためには、Perl 5.8 から同梱されている
C<List::Util> モジュールの C<first()> 関数が使えます。
この例は "Perl" を含む最初の要素を探します。

	use List::Util qw(first);

	my $element = first { /Perl/ } @array;

=begin original

If you cannot use C<List::Util>, you can make your own loop to do the
same thing.  Once you find the element, you stop the loop with last.

=end original

C<List::Util> が使えない場合は、同じことをするために自分でループを書きます。
要素が見つかったら、last を使ってループを停止します。

	my $found;
	foreach ( @array ) {
		if( /Perl/ ) { $found = $_; last }
		}

=begin original

If you want the array index, you can iterate through the indices
and check the array element at each index until you find one
that satisfies the condition.

=end original

配列の添え字がほしい場合は、添え字に順番に変えていって、
それぞれの添え字の配列要素をチェックして、条件を満たすものが
見つかるまで繰り返します。

	my( $found, $index ) = ( undef, -1 );
	for( $i = 0; $i < @array; $i++ ) {
		if( $array[$i] =~ /Perl/ ) {
			$found = $array[$i];
			$index = $i;
			last;
			}
		}

=head2 How do I handle linked lists?

(リンク付きリストを扱うには?)

=begin original

In general, you usually don't need a linked list in Perl, since with
regular arrays, you can push and pop or shift and unshift at either
end, or you can use splice to add and/or remove arbitrary number of
elements at arbitrary points.  Both pop and shift are O(1)
operations on Perl's dynamic arrays.  In the absence of shifts and
pops, push in general needs to reallocate on the order every log(N)
times, and unshift will need to copy pointers each time.

=end original

一般的には、Perl ではリンク付きリストを扱う必要はありません。
なぜなら、通常の配列を使って push や pop、shift や unsift を使って両端で
操作できたり、splice を使って任意の場所にある任意個の要素を加えたり
削除したりすることができるからです。
pop と shift は両方ともが、Perl の動的配列に対する O(1) の操作です。
shift や pop がなかった場合、push は一般的には log(N) 回毎のオーダーで
再割り当てが必要になります。
そして unshift は呼ばれる毎にポインターのコピーが必要になるでしょう。

=begin original

If you really, really wanted, you could use structures as described in
L<perldsc> or L<perltoot> and do just what the algorithm book tells
you to do.  For example, imagine a list node like this:

=end original

もし、本当に、本当にリンク付きリストを使いたいのなら、L<perldsc> や
L<perltoot> で説明されているようなデータ構造を使うことができ、
アルゴリズムの教科書にあるようなことができます。
例えば以下のようなリストノードをを考えてみましょう:

	$node = {
		VALUE => 42,
		LINK  => undef,
		};

=begin original

You could walk the list this way:

=end original

リストを渡り歩くには以下のようにします:

	print "List: ";
	for ($node = $head;  $node; $node = $node->{LINK}) {
		print $node->{VALUE}, " ";
		}
	print "\n";

=begin original

You could add to the list this way:

=end original

以下のやり方でリストに追加できます:

	my ($head, $tail);
	$tail = append($head, 1);       # grow a new head
	for $value ( 2 .. 10 ) {
		$tail = append($tail, $value);
		}

	sub append {
		my($list, $value) = @_;
		my $node = { VALUE => $value };
		if ($list) {
			$node->{LINK} = $list->{LINK};
			$list->{LINK} = $node;
			}
		else {
			$_[0] = $node;      # replace caller's version
			}
		return $node;
		}

=begin original

But again, Perl's built-in are virtually always good enough.

=end original

しかし繰り返しますが、Perl の組み込み型は事実上常に充分なものなのです。

=head2 How do I handle circular lists?

(循環リスト(circular list)を扱うには?)

=begin original

Circular lists could be handled in the traditional fashion with linked
lists, or you could just do something like this with an array:

=end original

循環リストはリンク付きリストを使って伝統的なやり方で扱うことができます。
あるいは以下のように配列を使って行うこともできます:

	unshift(@array, pop(@array));  # the last shall be first
	push(@array, shift(@array));   # and vice versa

=begin original

You can also use C<Tie::Cycle>:

=end original

C<Tie::Cycle> を使うこともできます:

	use Tie::Cycle;

	tie my $cycle, 'Tie::Cycle', [ qw( FFFFFF 000000 FFFF00 ) ];

	print $cycle; # FFFFFF
	print $cycle; # 000000
	print $cycle; # FFFF00

=head2 How do I shuffle an array randomly?

(配列をランダムにかき混ぜるには?)

=begin original

If you either have Perl 5.8.0 or later installed, or if you have
Scalar-List-Utils 1.03 or later installed, you can say:

=end original

Perl 5.8.0 以降がインストールされているか、Scalar-List-Utils 1.03 以降が
インストールされているなら、以下のように出来ます:

	use List::Util 'shuffle';

	@shuffled = shuffle(@list);

=begin original

If not, you can use a Fisher-Yates shuffle.

=end original

そうでないなら、Fisher-Yates 法が使えます。

	sub fisher_yates_shuffle {
		my $deck = shift;  # $deck is a reference to an array
		my $i = @$deck;
		while (--$i) {
			my $j = int rand ($i+1);
			@$deck[$i,$j] = @$deck[$j,$i];
			}
	}

	# shuffle my mpeg collection
	#
	my @mpeg = <audio/*/*.mp3>;
	fisher_yates_shuffle( \@mpeg );    # randomize @mpeg in place
	print @mpeg;

=begin original

Note that the above implementation shuffles an array in place,
unlike the C<List::Util::shuffle()> which takes a list and returns
a new shuffled list.

=end original

C<List::Util::shuffle()> はリストを受け取って、混ぜられた新しいリストを
返しますが、上記の実装は配列そのものを混ぜることに注意してください。

=begin original

You've probably seen shuffling algorithms that work using splice,
randomly picking another element to swap the current element with

=end original

splice を使ったシャッフルアルゴリズムを見たことがあるかもしれません。
カレントの要素をランダムに取り出した別の要素と交換します:

	srand;
	@new = ();
	@old = 1 .. 10;  # just a demo
	while (@old) {
		push(@new, splice(@old, rand @old, 1));
		}

=begin original

This is bad because splice is already O(N), and since you do it N
times, you just invented a quadratic algorithm; that is, O(N**2).
This does not scale, although Perl is so efficient that you probably
won't notice this until you have rather largish arrays.

=end original

これは splice が O(N) であり、さらにそれを N 回呼んでいるのですから
良くありません。
つまりこれは O(N**2) のアルゴリズムです。
これは大きな配列に使わなければあなたはその効率の悪さに気がつかないでしょう。

=head2 How do I process/modify each element of an array?

(配列の各要素に対する処理や、変更を行うには?)

=begin original

Use C<for>/C<foreach>:

=end original

C<for>/C<foreach> を使います:

	for (@lines) {
		s/foo/bar/;	# change that word
		tr/XZ/ZX/;	# swap those letters
		}

=begin original

Here's another; let's compute spherical volumes:

=end original

別の方法です; 球の体積を求めます:

	for (@volumes = @radii) {   # @volumes has changed parts
		$_ **= 3;
		$_ *= (4/3) * 3.14159;  # this will be constant folded
		}

=begin original

which can also be done with C<map()> which is made to transform
one list into another:

=end original

リストを他のリストに変換する C<map()> を使っても行えます:

	@volumes = map {$_ ** 3 * (4/3) * 3.14159} @radii;

=begin original

If you want to do the same thing to modify the values of the
hash, you can use the C<values> function.  As of Perl 5.6
the values are not copied, so if you modify $orbit (in this
case), you modify the value.

=end original

同じことをハッシュの値に対して行いたいのであれば、C<values> は使えません。
Perl 5.6 以降では値はコピーされないので、(この場合では) $orbit を変更すると、
値を変更することになります。

	for $orbit ( values %orbits ) {
		($orbit **= 3) *= (4/3) * 3.14159;
		}

=begin original

Prior to perl 5.6 C<values> returned copies of the values,
so older perl code often contains constructions such as
C<@orbits{keys %orbits}> instead of C<values %orbits> where
the hash is to be modified.

=end original

perl 5.6 以前では、C<values> は値のコピーを返すので、古い perl の
コードでは、ハッシュを修正しているところで  C<values %orbits> ではなく
C<@orbits{keys %orbits}> と書いていることがよくあります。

=head2 How do I select a random element from an array?

(ある配列からランダムに要素を選択するには?)

=begin original

Use the C<rand()> function (see L<perlfunc/rand>):

=end original

C<rand()> 関数を使います(L<perlfunc/rand> を参照):

	$index   = rand @array;
	$element = $array[$index];

=begin original

Or, simply:

=end original

あるいは、単純に:

	my $element = $array[ rand @array ];

=head2 How do I permute N elements of a list?
X<List::Permuter> X<permute> X<Algorithm::Loops> X<Knuth>
X<The Art of Computer Programming> X<Fischer-Krause>

(N 要素を持つリストの順列(permute)を求めるには?)

=begin original

Use the C<List::Permutor> module on CPAN. If the list is actually an
array, try the C<Algorithm::Permute> module (also on CPAN). It's
written in XS code and is very efficient:

=end original

CPAN にある C<List::Permutor> モジュールを使ってください。
リストが実際には配列なら、C<Algorithm::Permute> モジュール(これも CPAN に
あります)を試してください。
これは XS コードで書かれていて、とても効率的です:

	use Algorithm::Permute;

	my @array = 'a'..'d';
	my $p_iterator = Algorithm::Permute->new ( \@array );

	while (my @perm = $p_iterator->next) {
	   print "next permutation: (@perm)\n";
		}

=begin original

For even faster execution, you could do:

=end original

より速い実行のために、以下のようにも出来ます:

	use Algorithm::Permute;

	my @array = 'a'..'d';

	Algorithm::Permute::permute {
		print "next permutation: (@array)\n";
		} @array;

=begin original

Here's a little program that generates all permutations of all the
words on each line of input. The algorithm embodied in the
C<permute()> function is discussed in Volume 4 (still unpublished) of
Knuth's I<The Art of Computer Programming> and will work on any list:

=end original

以下の小さなプログラムは入力された行にある各単語の順列をすべて生成します。
関数 permute() で使われているアルゴリズムは
Knuth の I<The Art of Computer Programming> の Volume 4 (未発行) で
議論されていて、任意のリストで動作するはずです:

	#!/usr/bin/perl -n
	# Fischer-Krause ordered permutation generator

	sub permute (&@) {
		my $code = shift;
		my @idx = 0..$#_;
		while ( $code->(@_[@idx]) ) {
			my $p = $#idx;
			--$p while $idx[$p-1] > $idx[$p];
			my $q = $p or return;
			push @idx, reverse splice @idx, $p;
			++$q while $idx[$p-1] > $idx[$q];
			@idx[$p-1,$q]=@idx[$q,$p-1];
		}
	}

	permute { print "@_\n" } split;

=begin original

The C<Algorithm::Loops> module also provides the C<NextPermute> and
C<NextPermuteNum> functions which efficiently find all unique permutations
of an array, even if it contains duplicate values, modifying it in-place:
if its elements are in reverse-sorted order then the array is reversed,
making it sorted, and it returns false; otherwise the next
permutation is returned.

=end original

C<Algorithm::Loops> モジュールも the C<NextPermute> と C<NextPermuteNum> の
関数を提供していて、重複した値が含まれていても、その場で変更して、配列の
全てのユニークな順列を探します:
もしその要素が逆順にソートされているなら、配列を反転させて、ソートを
行い、偽を返します; さもなければ次の順列を返します。

=begin original

C<NextPermute> uses string order and C<NextPermuteNum> numeric order, so
you can enumerate all the permutations of C<0..9> like this:

=end original

C<NextPermute> は文字列順を使い、C<NextPermuteNum> は数値順を使うので、
C<0..9> の全ての順番を数え上げるには以下のようにします:

	use Algorithm::Loops qw(NextPermuteNum);
	
    my @list= 0..9;
    do { print "@list\n" } while NextPermuteNum @list;

=head2 How do I sort an array by (anything)?

((なにか)で配列をソートするには?)

=begin original

Supply a comparison function to sort() (described in L<perlfunc/sort>):

=end original

sort() (L<perlfunc/sort> に説明があります)のための比較関数を作ります:

	@list = sort { $a <=> $b } @list;

=begin original

The default sort function is cmp, string comparison, which would
sort C<(1, 2, 10)> into C<(1, 10, 2)>.  C<< <=> >>, used above, is
the numerical comparison operator.

=end original

デフォルトのソート関数は文字列比較である cmp で、C<(1, 2, 10)> を 
C<(1, 10, 2)> に並び変えます。
上の例では、数値比較演算子である C<< <=> >> を使っています。

=begin original

If you have a complicated function needed to pull out the part you
want to sort on, then don't do it inside the sort function.  Pull it
out first, because the sort BLOCK can be called many times for the
same element.  Here's an example of how to pull out the first word
after the first number on each item, and then sort those words
case-insensitively.

=end original

ソートするものの一部を取り出す必要があるような複雑な関数を使うのなら、
ソート関数の内側でそれを使ってはいけません。
最初にその関数で使う部分を取り出します。
なぜなら、sort BLOCK は同じ要素に対して何度も何度も呼び出される
可能性があるからです。
以下の例は、各アイテムの最初の番号の後にある最初の単語を取り出し、
その後でそれらの単語を大小文字を無視してソートします。

	@idx = ();
	for (@data) {
		($item) = /\d+\s*(\S+)/;
		push @idx, uc($item);
	    }
	@sorted = @data[ sort { $idx[$a] cmp $idx[$b] } 0 .. $#idx ];

=begin original

which could also be written this way, using a trick
that's come to be known as the Schwartzian Transform:

=end original

これはシュワルツ変換と呼ばれるトリックを使って以下のように
書くこともできます:

	@sorted = map  { $_->[0] }
		sort { $a->[1] cmp $b->[1] }
		map  { [ $_, uc( (/\d+\s*(\S+)/)[0]) ] } @data;

=begin original

If you need to sort on several fields, the following paradigm is useful.

=end original

幾つかのフィールドを使ってソートする必要があるのなら、
以下のやり方が便利でしょう。

	@sorted = sort {
		field1($a) <=> field1($b) ||
		field2($a) cmp field2($b) ||
		field3($a) cmp field3($b)
		} @data;

=begin original

This can be conveniently combined with precalculation of keys as given
above.

=end original

これは先の例にあったキーの precalculation と組み合わせることも
できます。

=begin original

See the F<sort> article in the "Far More Than You Ever Wanted
To Know" collection in http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz for
more about this approach.

=end original

この手法に関する更なる情報については
http://www.cpan.org/misc/olddoc/FMTEYEWTK.tgz にある
"Far More Than You Ever Wanted To Know" コレクションの F<sort> という記事を
参照してください。

=begin original

See also the question later in L<perlfaq4> on sorting hashes.

=end original

L<perlfaq4> で後述する、ハッシュのソートに関する質問も参照してください。

=head2 How do I manipulate arrays of bits?

(ビット配列を扱うには?)

=begin original

Use C<pack()> and C<unpack()>, or else C<vec()> and the bitwise
operations.

=end original

C<pack()> と C<unpack()> か、C<vec()> とビット演算を使います。

=begin original

For example, this sets C<$vec> to have bit N set if C<$ints[N]> was
set:

=end original

以下の例は、C<$ints[N]> がセットされていれば C<$vec> の bit N をセットします。

	$vec = '';
	foreach(@ints) { vec($vec,$_,1) = 1 }

=begin original

Here's how, given a vector in C<$vec>, you can get those bits into your
C<@ints> array:

=end original

次に挙げる例は、C<$vec> で与えられるベクターのビットを配列 C<@ints> に
取り出すものです:

	sub bitvec_to_list {
		my $vec = shift;
		my @ints;
		# Find null-byte density then select best algorithm
		if ($vec =~ tr/\0// / length $vec > 0.95) {
			use integer;
			my $i;

			# This method is faster with mostly null-bytes
			while($vec =~ /[^\0]/g ) {
				$i = -9 + 8 * pos $vec;
				push @ints, $i if vec($vec, ++$i, 1);
				push @ints, $i if vec($vec, ++$i, 1);
				push @ints, $i if vec($vec, ++$i, 1);
				push @ints, $i if vec($vec, ++$i, 1);
				push @ints, $i if vec($vec, ++$i, 1);
				push @ints, $i if vec($vec, ++$i, 1);
				push @ints, $i if vec($vec, ++$i, 1);
				push @ints, $i if vec($vec, ++$i, 1);
				}
			}
		else {
			# This method is a fast general algorithm
			use integer;
			my $bits = unpack "b*", $vec;
			push @ints, 0 if $bits =~ s/^(\d)// && $1;
			push @ints, pos $bits while($bits =~ /1/g);
			}

		return \@ints;
		}

=begin original

This method gets faster the more sparse the bit vector is.
(Courtesy of Tim Bunce and Winfried Koenig.)

=end original

この方法はビットベクターが疎であるときにさらに高速になります
(Tim Bunce と Winfried Koenig によるものです)。

=begin original

You can make the while loop a lot shorter with this suggestion
from Benjamin Goldberg:

=end original

Benjamin Goldberg の提案を使って、while ループをはるかに
短くすることもできます:

	while($vec =~ /[^\0]+/g ) {
		push @ints, grep vec($vec, $_, 1), $-[0] * 8 .. $+[0] * 8;
		}

=begin original

Or use the CPAN module C<Bit::Vector>:

=end original

または CPAN の C<Bit::Vector> モジュールを使います:

	$vector = Bit::Vector->new($num_of_bits);
	$vector->Index_List_Store(@ints);
	@ints = $vector->Index_List_Read();

=begin original

C<Bit::Vector> provides efficient methods for bit vector, sets of
small integers and "big int" math.

=end original

C<Bit::Vector> は、ビットベクタ、小さい整数の就業、「大きな整数」の
計算に関する効果的なメソッドを提供します。

=begin original

Here's a more extensive illustration using vec():

=end original

以下は、vec() を使った広範囲な説明です:

	# vec demo
	$vector = "\xff\x0f\xef\xfe";
	print "Ilya's string \\xff\\x0f\\xef\\xfe represents the number ",
	unpack("N", $vector), "\n";
	$is_set = vec($vector, 23, 1);
	print "Its 23rd bit is ", $is_set ? "set" : "clear", ".\n";
	pvec($vector);

	set_vec(1,1,1);
	set_vec(3,1,1);
	set_vec(23,1,1);

	set_vec(3,1,3);
	set_vec(3,2,3);
	set_vec(3,4,3);
	set_vec(3,4,7);
	set_vec(3,8,3);
	set_vec(3,8,7);

	set_vec(0,32,17);
	set_vec(1,32,17);

	sub set_vec {
		my ($offset, $width, $value) = @_;
		my $vector = '';
		vec($vector, $offset, $width) = $value;
		print "offset=$offset width=$width value=$value\n";
		pvec($vector);
		}

	sub pvec {
		my $vector = shift;
		my $bits = unpack("b*", $vector);
		my $i = 0;
		my $BASE = 8;

		print "vector length in bytes: ", length($vector), "\n";
		@bytes = unpack("A8" x length($vector), $bits);
		print "bits are: @bytes\n\n";
		}

=head2 Why does defined() return true on empty arrays and hashes?

(なぜ空の配列やハッシュに defined() を使ったときに真が返ってくるのでしょう?)

=begin original

The short story is that you should probably only use defined on scalars or
functions, not on aggregates (arrays and hashes).  See L<perlfunc/defined>
in the 5.004 release or later of Perl for more detail.

=end original

簡単にいえば、スカラや関数に対してのみ defined を使うべきで、
集成体(aggregates, 配列やハッシュ)に対して使うべきではないのです。
詳しくは 5.004 以降の L<perlfunc/defined> を参照してください。

=head1 Data: Hashes (Associative Arrays)

(データ: ハッシュ(連想配列))

=head2 How do I process an entire hash?

(ハッシュ全体を処理するには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

There are a couple of ways that you can process an entire hash. You
can get a list of keys, then go through each key, or grab a one
key-value pair at a time.

=end original

ハッシュ全体を処理するには二つの方法があります。
キーのリストを取得してからキー毎に処理するか、一度に一つのキー-値の
ペアを取得するかです。

=begin original

To go through all of the keys, use the C<keys> function. This extracts
all of the keys of the hash and gives them back to you as a list. You
can then get the value through the particular key you're processing:

=end original

全てのキーを得るには、C<keys> 関数を使います。
ハッシュの全てのキーを展開してリストの形で返します。
それから処理したい特定のキーの値を取得します。

	foreach my $key ( keys %hash ) {
		my $value = $hash{$key}
		...
		}

=begin original

Once you have the list of keys, you can process that list before you
process the hashh elements. For instance, you can sort the keys so you
can process them in lexical order:

=end original

キーのリストを取得したら、ハッシュ要素を処理する前にリストを処理できます。
例えば、キーをソートしてレキシカルな順序で処理できます:

	foreach my $key ( sort keys %hash ) {
		my $value = $hash{$key}
		...
		}

=begin original

Or, you might want to only process some of the items. If you only want
to deal with the keys that start with C<text:>, you can select just
those using C<grep>:

=end original

あるいは、アイテムの一部に対してのみ処理したいかもしれません。
キーが C<text:> で始まるキーのみ扱いたいなら、単に C<grep> を使って
選択できます:

	foreach my $key ( grep /^text:/, keys %hash ) {
		my $value = $hash{$key}
		...
		}

=begin original

If the hash is very large, you might not want to create a long list of
keys. To save some memory, you can grab on key-value pair at a time using
C<each()>, which returns a pair you haven't seen yet:

=end original

ハッシュがとても大きい場合、キーの長いリストを作りたくないかもしれません。
メモリを節約するために、まだ取得していないキー-値の組を返す C<each()> を
使って組を取得できます:

	while( my( $key, $value ) = each( %hash ) ) {
		...
		}

=begin original

The C<each> operator returns the pairs in apparently random order, so if
ordering matters to you, you'll have to stick with the C<keys> method.

=end original

C<each> 演算子は組を一見ランダムな順序で返すので、順序が問題になる場合は、
C<keys> メソッドを使う必要があります。

=begin original

The C<each()> operator can be a bit tricky though. You can't add or
delete keys of the hash while you're using it without possibly
skipping or re-processing some pairs after Perl internally rehashes
all of the elements. Additionally, a hash has only one iterator, so if
you use C<keys>, C<values>, or C<each> on the same hash, you can reset
the iterator and mess up your processing. See the C<each> entry in
L<perlfunc> for more details.

=end original

しかし、C<each()> 演算子は少しトリッキーです。
Perl が内部的に全ての要素を再ハッシュした後にいくつかの組をスキップしたり
再処理したりすることなく、ハッシュの使用中にハッシュのキーを追加したり
削除したりすることは出来ません。
さらに、一つのハッシュは一つのイテレータしか持っていないので、もし同じ
ハッシュに対して C<keys>, C<values>, C<each> を使うと、イテレータを
リセットしてしまって処理が無茶苦茶になってしまいます。
さらなる詳細については L<perlfunc> の C<each> エントリを参照してください。

=head2 What happens if I add or remove keys from a hash while iterating over it?

(ハッシュに対して反復操作を行っているときにキーの追加や
削除をすると何が起きますか?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

The easy answer is "Don't do that!"

=end original

簡単な答えは:「そんなことをするな！」

=begin original

If you iterate through the hash with each(), you can delete the key
most recently returned without worrying about it.  If you delete or add
other keys, the iterator may skip or double up on them since perl
may rearrange the hash table.  See the
entry for C<each()> in L<perlfunc>.

=end original

If you iterate through the hash with each(), you can delete the key
most recently returned without worrying about it.  If you delete or add
other keys, the iterator may skip or double up on them since perl
may rearrange the hash table.
L<perlfunc> の C<each()> のエントリを参照してください。

=head2 How do I look up a hash element by value?

(ハッシュの要素をその値で検索するには?)

=begin original

Create a reverse hash:

=end original

リバースハッシュを作成します:

	%by_value = reverse %by_key;
	$key = $by_value{$value};

=begin original

That's not particularly efficient.  It would be more space-efficient
to use:

=end original

これは特に効率がよいものではありません。
空間を効率よく使うにはこうします:

	while (($key, $value) = each %by_key) {
		$by_value{$value} = $key;
	    }

=begin original

If your hash could have repeated values, the methods above will only find
one of the associated keys.   This may or may not worry you.  If it does
worry you, you can always reverse the hash into a hash of arrays instead:

=end original

ハッシュに同じ値がある場合には、このメソッドは最初に見つかったキーだけを
見つけだします。
あなたはこれを気にするかも知れませんし、気にしないかもしれません。
もし気にするのなら、いつでもハッシュの代わりに配列のハッシュを
使うことができます:

	while (($key, $value) = each %by_key) {
		 push @{$key_list_by_value{$value}}, $key;
		}

=head2 How can I know how many entries are in a hash?

(ハッシュにどれくらいの要素があるのを知るには?)

=begin original

If you mean how many keys, then all you have to do is
use the keys() function in a scalar context:

=end original

どのくらいのキーがあるのかという事なら、keys()関数をスカラコンテキストで
使います:

    $num_keys = keys %hash;

=begin original

The keys() function also resets the iterator, which means that you may
see strange results if you use this between uses of other hash operators
such as each().

=end original

keys() 関数も反復動作を初期化するので、
which means that you may
see strange results if you use this between uses of other hash operators
such as each().

=head2 How do I sort a hash (optionally by value instead of key)?

(ハッシュを(キーではなく値で)ソートするには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

To sort a hash, start with the keys. In this example, we give the list of
keys to the sort function which then compares them ASCIIbetically (which
might be affected by your locale settings). The output list has the keys
in ASCIIbetical order. Once we have the keys, we can go through them to
create a report which lists the keys in ASCIIbetical order.

=end original

ハッシュをソートするために、キーから始めます。
この例では、キーのリストをソート関数に渡して、それから ASCII 順で比較します
(ロケール設定の影響を受けるかもしれません)。
出力リストは ASCII 順のキーのリストです。
キーを得たら、ASCII 順にキーを並べたレポートを作成します。

	my @keys = sort { $a cmp $b } keys %hash;

	foreach my $key ( @keys )
		{
		printf "%-20s %6d\n", $key, $hash{$value};
		}

=begin original

We could get more fancy in the C<sort()> block though. Instead of
comparing the keys, we can compute a value with them and use that
value as the comparison.

=end original

しかし、C<sort()> ブロックでもっと面白いことができます。
キーを比較する代わりに、これらの値を計算してその値を比較に使います。

=begin original

For instance, to make our report order case-insensitive, we use
the C<\L> sequence in a double-quoted string to make everything
lowercase. The C<sort()> block then compares the lowercased
values to determine in which order to put the keys.

=end original

例えば、大文字小文字を無視した順序のレポートを作るには、全てを小文字に
するためにダブルクォートされた文字列の中で C<\L> シーケンスが使えます。
それから C<sort()> ブロックがキーを出力する順番を決定するために小文字化された
値を比較します。

	my @keys = sort { "\L$a" cmp "\L$b" } keys %hash;

=begin original

Note: if the computation is expensive or the hash has many elements,
you may want to look at the Schwartzian Transform to cache the
computation results.

=end original

注意: 計算が高くつくものであったり、ハッシュがたくさんの要素を持っている
場合、計算結果をキャッシュするためにシュワルツ変換を使いたいかもしれません。

=begin original

If we want to sort by the hash value instead, we use the hash key
to look it up. We still get out a list of keys, but this time they
are ordered by their value.

=end original

もし代わりにハッシュの値でソートしたいなら、それを探すためにハッシュキーを
使います。
やはりキーのリストを使いますが、今度はその値でソートします。

	my @keys = sort { $hash{$a} <=> $hash{$b} } keys %hash;

=begin original

From there we can get more complex. If the hash values are the same,
we can provide a secondary sort on the hash key.

=end original

ここから、より複雑なものにできます。
ハッシュ値が同じ場合は、ハッシュキーによる第二段階のソートを提供できます。

	my @keys = sort {
		$hash{$a} <=> $hash{$b}
			or
		"\L$a" cmp "\L$b"
		} keys %hash;

=head2 How can I always keep my hash sorted?
X<hash tie sort DB_File Tie::IxHash>

(私のハッシュを常にソートされた状態にしておくには?)

=begin original

You can look into using the C<DB_File> module and C<tie()> using the
C<$DB_BTREE> hash bindings as documented in L<DB_File/"In Memory
Databases">. The C<Tie::IxHash> module from CPAN might also be
instructive. Although this does keep your hash sorted, you might not
like the slow down you suffer from the tie interface. Are you sure you
need to do this? :)

=end original

L<DB_File/"In Memory Databases"> にあるように、C<DB_File> モジュールと
C<tie()> を使った、$DB_BTREE ハッシュ束縛を使うことができます。
CPAN の C<Tie::IxHash> モジュールも有益かもしれません。
これによりハッシュはソートされた状態のままになりますが、tie
インターフェースによって被る速度低下を気に入らないかもしれません。
あなたは本当にこれが必要ですか? :)

=head2 What's the difference between "delete" and "undef" with hashes?

(ハッシュに対する "delete" と "undef"との間の違いは?)

=begin original

Hashes contain pairs of scalars: the first is the key, the
second is the value.  The key will be coerced to a string,
although the value can be any kind of scalar: string,
number, or reference.  If a key C<$key> is present in
%hash, C<exists($hash{$key})> will return true.  The value
for a given key can be C<undef>, in which case
C<$hash{$key}> will be C<undef> while C<exists $hash{$key}>
will return true.  This corresponds to (C<$key>, C<undef>)
being in the hash.

=end original

ハッシュはスカラのペアからなります: 最初のスカラがキーで、
二番目のスカラが値です。
キーは文字列、数値、リファレンスのいずれの種類のスカラであっても
強制的に文字列にされます。
%hash の中に C<$key> というキーが既にあれば、C<exists($hash{$key})> は
真を返します。
与えられたキーに対する値は C<undef> とすることができます。
これは C<$hash{$key}> を C<undef> にして、C<exists $hash{$key}> が真を
返すという状態です。
これは (C<$key>, C<undef>)がハッシュに存在しているということを示しています。

=begin original

Pictures help...  here's the C<%hash> table:

=end original

図が助けになるでしょう。
以下は C<%hash> のテーブルです:

	  keys  values
	+------+------+
	|  a   |  3   |
	|  x   |  7   |
	|  d   |  0   |
	|  e   |  2   |
	+------+------+

=begin original

And these conditions hold

=end original

そしてこれらが保持している状態はこうです:

	$hash{'a'}                       is true
	$hash{'d'}                       is false
	defined $hash{'d'}               is true
	defined $hash{'a'}               is true
	exists $hash{'a'}                is true (Perl 5 only)
	grep ($_ eq 'a', keys %hash)     is true

=begin original

If you now say

=end original

ここで

	undef $hash{'a'}

=begin original

your table now reads:

=end original

とすると、テーブルはこうなります:

	  keys  values
	+------+------+
	|  a   | undef|
	|  x   |  7   |
	|  d   |  0   |
	|  e   |  2   |
	+------+------+

=begin original

and these conditions now hold; changes in caps:

=end original

そしてその状態は以下のようになります。
大文字になっているのが変わった場所です:

	$hash{'a'}                       is FALSE
	$hash{'d'}                       is false
	defined $hash{'d'}               is true
	defined $hash{'a'}               is FALSE
	exists $hash{'a'}                is true (Perl 5 only)
	grep ($_ eq 'a', keys %hash)     is true

=begin original

Notice the last two: you have an undef value, but a defined key!

=end original

最後の二つに注目してください: あなたは undef 値を保持していますが、
キーは define されているのです!

=begin original

Now, consider this:

=end original

さて、こんどは以下の例を考えてみましょう:

	delete $hash{'a'}

=begin original

your table now reads:

=end original

テーブルはこうなります:

	  keys  values
	+------+------+
	|  x   |  7   |
	|  d   |  0   |
	|  e   |  2   |
	+------+------+

=begin original

and these conditions now hold; changes in caps:

=end original

そしてその状態はこうです。大文字の部分が変わったところです:

	$hash{'a'}                       is false
	$hash{'d'}                       is false
	defined $hash{'d'}               is true
	defined $hash{'a'}               is false
	exists $hash{'a'}                is FALSE (Perl 5 only)
	grep ($_ eq 'a', keys %hash)     is FALSE

=begin original

See, the whole entry is gone!

=end original

ほら、エントリが丸ごとなくなっていまいました!

=head2 Why don't my tied hashes make the defined/exists distinction?

(なぜわたしの tie されたハッシュは defined と exists を区別しないのでしょうか?)

=begin original

This depends on the tied hash's implementation of EXISTS().
For example, there isn't the concept of undef with hashes
that are tied to DBM* files. It also means that exists() and
defined() do the same thing with a DBM* file, and what they
end up doing is not what they do with ordinary hashes.

=end original

これは tie されたハッシュの EXISTS() の実装に依存します。
たとえば、DBM* ファイルに tie されたハッシュには undef という考え方はありません。
これはまた DBM* ファイルにとっては exists() と defined() とは同じことであり、
そういったものに対して行っていることは
通常のハッシュに対して行っていることとは違うのだということなのです。

=head2 How do I reset an each() operation part-way through?

(each() 操作の途中でリセットしてしまうには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

You can use the C<keys> or C<values> functions to reset C<each>. To
simply reset the iterator used by C<each> without doing anything else,
use one of them in void context:

=end original

C<each> をリセットするために C<keys> 関数か C<values> 関数が使えます。
他に何もせずに単に C<each> で使われているイテレータをリセットするには、
これらの一つを無効コンテキストで使います:

	keys %hash; # resets iterator, nothing else.
	values %hash; # resets iterator, nothing else.

=begin original

See the documentation for C<each> in L<perlfunc>.

=end original

L<perlfunc> にある C<each> の説明を参照してください。

=head2 How can I get the unique keys from two hashes?

(二つのハッシュからユニークなキーを取りだすには?)

=begin original

First you extract the keys from the hashes into lists, then solve
the "removing duplicates" problem described above.  For example:

=end original

まず最初にハッシュからキーを取りだして、それをリストに格納します。
そして、先に説明した「重複の削除」問題の解決を行います。例:

	%seen = ();
	for $element (keys(%foo), keys(%bar)) {
		$seen{$element}++;
		}
	@uniq = keys %seen;

=begin original

Or more succinctly:

=end original

あるいはもっと簡潔に:

	@uniq = keys %{{%foo,%bar}};

=begin original

Or if you really want to save space:

=end original

もし本当にメモリ空間を節約したいのなら:

	%seen = ();
	while (defined ($key = each %foo)) {
		$seen{$key}++;
	}
	while (defined ($key = each %bar)) {
		$seen{$key}++;
	}
	@uniq = keys %seen;

=head2 How can I store a multidimensional array in a DBM file?

(DBM ファイルに多次元配列を格納するには?)

=begin original

Either stringify the structure yourself (no fun), or else
get the MLDBM (which uses Data::Dumper) module from CPAN and layer
it on top of either DB_File or GDBM_File.

=end original

自分自身で構造を文字列化する(うれしくないですね)か、MLDBM モジュール
(Data::Dumper を使います)を
CPAN から取ってきて、DB_File か GDBM_File のいずれかのトップレイヤーにします。

=head2 How can I make my hash remember the order I put elements into it?

(わたしのハッシュが格納した順番を覚えておくようにするには?)

=begin original

Use the C<Tie::IxHash> from CPAN.

=end original

CPAN にある C<Tie::IxHash> を使います。

	use Tie::IxHash;

	tie my %myhash, 'Tie::IxHash';

	for (my $i=0; $i<20; $i++) {
		$myhash{$i} = 2*$i;
		}

	my @keys = keys %myhash;
	# @keys = (0,1,2,3,...)

=head2 Why does passing a subroutine an undefined element in a hash create it?

(なぜあるハッシュの未定義要素をサブルーチンに渡すとそれを作成するのでしょうか?)

=begin original

If you say something like:

=end original

以下のようなことをしようとすると:

	somefunc($hash{"nonesuch key here"});

=begin original

Then that element "autovivifies"; that is, it springs into existence
whether you store something there or not.  That's because functions
get scalars passed in by reference.  If somefunc() modifies C<$_[0]>,
it has to be ready to write it back into the caller's version.

=end original

この要素は新たに生みだされます("autovivifies");
これはつまり、あなたがそこに何かを格納するため(実際に格納することがなくても)に
作り出されるのです。
これは関数が渡されたスカラをリファレンスで受け取るからです。
somefunc() が C<$_[0]> を変更するのなら、
呼び出し元にそれを反映させるために書き込みができるように
なっていなければなりません。

=begin original

This has been fixed as of Perl5.004.

=end original

これは Perl5.004 で修正されました。

=begin original

Normally, merely accessing a key's value for a nonexistent key does
I<not> cause that key to be forever there.  This is different than
awk's behavior.

=end original

通常は、存在していないキーに対するアクセスは、そのキーを生成する
ようなことは B<ありません>。
これは awk の振る舞いとは異なります．

=head2 How can I make the Perl equivalent of a C structure/C++ class/hash or array of hashes or arrays?

(C の構造体/C++ のクラスのハッシュ、配列のハッシュ、配列と
等価なものを Perl で作成するには?)

=begin original

Usually a hash ref, perhaps like this:

=end original

通常はハッシュのリファレンスを使います。
多分以下のようになるでしょう:

	$record = {
		NAME   => "Jason",
		EMPNO  => 132,
		TITLE  => "deputy peon",
		AGE    => 23,
		SALARY => 37_000,
		PALS   => [ "Norbert", "Rhys", "Phineas"],
	};

=begin original

References are documented in L<perlref> and the upcoming L<perlreftut>.
Examples of complex data structures are given in L<perldsc> and
L<perllol>.  Examples of structures and object-oriented classes are
in L<perltoot>.

=end original

リファレンスは L<perlref> と L<perlreftut> に説明があります。
複雑なデータ構造の例が L<perldesc> と L<perllol> にあります。
構造体とオブジェクト指向クラスの例が L<perltoot> にあります。

=head2 How can I use a reference as a hash key?

(ハッシュのキーとしてリファレンスを使うには?)

=begin original

(contributed by brian d foy)

=end original

(brian d foy によって寄贈されました)

=begin original

Hash keys are strings, so you can't really use a reference as the key.
When you try to do that, perl turns the reference into its stringified
form (for instance, C<HASH(0xDEADBEEF)>). From there you can't get
back the reference from the stringified form, at least without doing
some extra work on your own. Also remember that hash keys must be
unique, but two different variables can store the same reference (and
those variables can change later).

=end original

ハッシュキーは文字列なので、実際にリファレンスをキーとして使うことは
できません。
もしそうしようとすると、perl はリファレンスを(例えば C<HASH(0xDEADBEEF)> の
形に)文字列化 します。
少なくとも自分自身で追加の作業をしない限り、文字列化された形から
リファレンスを得ることはできません。
ハッシュキーはユニークでなければなりませんが、二つの異なる変数が
同じリファレンスを保管できる(そしてこれらの変数は後で変更できる)ことも
忘れないでください。

=begin original

The C<Tie::RefHash> module, which is distributed with perl, might be
what you want. It handles that extra work.

=end original

perl と共に配布されている C<Tie::RefHash> モジュールが、あなたの求めている
ものかもしれません。
これは追加の作業を扱います。

=head1 Data: Misc

(データ:その他)

=head2 How do I handle binary data correctly?

(バイナリデータを正しく扱うには?)

=begin original

Perl is binary clean, so it can handle binary data just fine.
On Windows or DOS, however, you have to use C<binmode> for binary
files to avoid conversions for line endings. In general, you should
use C<binmode> any time you want to work with binary data.

=end original

Perl はバイナリクリーンですから、バイナリデータをうまく扱えます。
しかし、 Windows や DOS では、バイナリファイルに対して行末の変換を避けるために、
C<binmode> を使う必要があります。
一般的には、バイナリデータを扱いたいときはいつでも C<binmode> を
使うべきです。

=begin original

Also see L<perlfunc/"binmode"> or L<perlopentut>.

=end original

L<perlfunc/"binmode"> と L<perlopentut> も参照してください。

=begin original

If you're concerned about 8-bit textual data then see L<perllocale>.
If you want to deal with multibyte characters, however, there are
some gotchas.  See the section on Regular Expressions.

=end original

もし 8 ビットテキストデータについて考えているのであれば、L<perllocale> を
参照してください。
ただしマルチバイトキャラクターを扱いたいと考えているなら、幾つかの
罠(gotchas)があります。
正規表現のセクションを参照してください。

=head2 How do I determine whether a scalar is a number/whole/integer/float?

(あるスカラ値が数値/整数/浮動小数点数かどうかを決定するには?)

=begin original

Assuming that you don't care about IEEE notations like "NaN" or
"Infinity", you probably just want to use a regular expression.

=end original

"NaN" や "Infinity" のような IEEE 表記については気にしないと仮定すると、
正規表現を使って行うことができます。

	if (/\D/)            { print "has nondigits\n" }
	if (/^\d+$/)         { print "is a whole number\n" }
	if (/^-?\d+$/)       { print "is an integer\n" }
	if (/^[+-]?\d+$/)    { print "is a +/- integer\n" }
	if (/^-?\d+\.?\d*$/) { print "is a real number\n" }
	if (/^-?(?:\d+(?:\.\d*)?|\.\d+)$/) { print "is a decimal number\n" }
	if (/^([+-]?)(?=\d|\.\d)\d*(\.\d*)?([Ee]([+-]?\d+))?$/)
			{ print "a C float\n" }

=begin original

There are also some commonly used modules for the task.
L<Scalar::Util> (distributed with 5.8) provides access to perl's
internal function C<looks_like_number> for determining whether a
variable looks like a number.  L<Data::Types> exports functions that
validate data types using both the above and other regular
expressions. Thirdly, there is C<Regexp::Common> which has regular
expressions to match various types of numbers. Those three modules are
available from the CPAN.

=end original

この作業のためによく使われるいくつかのモジュールがあります。
L<Scalar::Util> (5.8 と共に配布されています) は、変数が数値に見えるか
どうかを決定するために perl の内部関数 C<looks_like_number> へのアクセスを
提供します。
L<Data::Types> は上記のものとその他の正規表現の両方を使ってデータ型の
バリデートを行う関数をエクスポートします。
3 つめとして、C<Regexp::Common> には様々な種類の数値にマッチングする
正規表現があります。
これら 3 つのモジュールは CPAN にあります。

=begin original

If you're on a POSIX system, Perl supports the C<POSIX::strtod>
function.  Its semantics are somewhat cumbersome, so here's a
C<getnum> wrapper function for more convenient access.  This function
takes a string and returns the number it found, or C<undef> for input
that isn't a C float.  The C<is_numeric> function is a front end to
C<getnum> if you just want to say, "Is this a float?"

=end original

POSIXシステムを使っているのなら、Perlは C<POSIX::strtod>
関数をサポートしています。
そのセマンティックは扱いにくいもので、もっと便利にアクセスするための
C<getnum> 関数を以下に例示します。
この関数は文字列を引数に取り、その文字列中で見つかった数字列に対応する
数値を返し、入力がCの小数点表記にあわないものであれば C<undef> を返します。
C<is_numeric> 関数は“これは数値か?”ということを知りたい場合に
C<getnum> のフロントエンドとなります。

	sub getnum {
		use POSIX qw(strtod);
		my $str = shift;
		$str =~ s/^\s+//;
		$str =~ s/\s+$//;
		$! = 0;
		my($num, $unparsed) = strtod($str);
		if (($str eq '') || ($unparsed != 0) || $!) {
				return undef;
			}
		else {
			return $num;
			}
		}

	sub is_numeric { defined getnum($_[0]) }

=begin original

Or you could check out the L<String::Scanf> module on the CPAN
instead. The C<POSIX> module (part of the standard Perl distribution)
provides the C<strtod> and C<strtol> for converting strings to double
and longs, respectively.

=end original

あるいは、CPAN にある L<String::Scanf> モジュールをチェックしてみてください。
C<POSIX> モジュール(標準 Perl 配布キットの一部です)は文字列から
倍精度浮動小数点数や長整数への変換を適切に行う C<strtod> と C<strtol> を
提供しています。

=head2 How do I keep persistent data across program calls?

(プログラムの呼び出しの間に、データ構造を永続的に保持するには?)

=begin original

For some specific applications, you can use one of the DBM modules.
See L<AnyDBM_File>.  More generically, you should consult the C<FreezeThaw>
or C<Storable> modules from CPAN.  Starting from Perl 5.8 C<Storable> is part
of the standard distribution.  Here's one example using C<Storable>'s C<store>
and C<retrieve> functions:

=end original

一部の特定のアプリケーションでは、DBM モジュールの一つを使うことができます。
L<AnyDBM_File> を参照してください。
より一般的には、CPAN にある C<FreezeThaw>, C<Storable> といった
モジュールをあたってみるべきでしょう。
Perl 5.8 から、C<Storable> は標準配布の一部となりました。
以下に C<Storable> の C<store> と C<retrieve> を使った例を挙げます:

	use Storable;
	store(\%hash, "filename");

	# later on...
	$href = retrieve("filename");        # by ref
	%hash = %{ retrieve("filename") };   # direct to hash

=head2 How do I print out or copy a recursive data structure?

(再帰的なデータ構造を出力したりコピーするには?)

=begin original

The C<Data::Dumper> module on CPAN (or the 5.005 release of Perl) is great
for printing out data structures.  The C<Storable> module on CPAN (or the
5.8 release of Perl), provides a function called C<dclone> that recursively
copies its argument.

=end original

CPAN にある C<Data::Dumper> モジュール(5.005 以降では Perl のリリースに
含まれています)はデータ構造を出力するのに向いています。
CPAN にある C<Storable> モジュール(5.8 以降では Perl のリリースに
含まれています)はその引数を再帰的にコピーする
C<dclone> という関数を提供しています。

	use Storable qw(dclone);
	$r2 = dclone($r1);

=begin original

Where C<$r1> can be a reference to any kind of data structure you'd like.
It will be deeply copied.  Because C<dclone> takes and returns references,
you'd have to add extra punctuation if you had a hash of arrays that
you wanted to copy.

=end original

ここで C<$r1> にはあなたの望むデータ構造のリファレンスを置くことができます。
これは深くコピー(deeply copied)されます。
C<dclone> はリファレンスを取り
リファレンスを返すので、コピーしたいものが配列のハッシュであったりした
場合には余計なpunctuationが必要となるでしょう。

	%newhash = %{ dclone(\%oldhash) };

=head2 How do I define methods for every class/object?

(すべてのクラス/オブジェクトのためのメソッドを定義するには?)

=begin original

Use the C<UNIVERSAL> class (see L<UNIVERSAL>).

=end original

C<UNIVERSAL> クラス (L<UNIVERSAL>) を参照)を使います。

=head2 How do I verify a credit card checksum?

(クレジットカードのチェックサムを検査するには?)

=begin original

Get the C<Business::CreditCard> module from CPAN.

=end original

CPAN から C<Business::CreditCard> モジュールを入手してください。

=head2 How do I pack arrays of doubles or floats for XS code?

(XSプログラムのために倍精度実数や単精度実数の配列を pack するには?)

=begin original

The kgbpack.c code in the C<PGPLOT> module on CPAN does just this.
If you're doing a lot of float or double processing, consider using
the C<PDL> module from CPAN instead--it makes number-crunching easy.

=end original

CPAN にある C<PGPLOT> モジュールにある kgbpack.c というものがそれをします。
倍精度実数や単精度実数を大量に扱うのであれば、CPAN にある
C<PDL> モジュールを使うことを考えてみるとよいでしょう。
これは number-crunching を簡単にしてくれます。

=head1 REVISION

Revision: $Revision: 10394 $

Date: $Date: 2007-12-09 18:47:15 +0100 (Sun, 09 Dec 2007) $

See L<perlfaq> for source control details and availability.

=head1 AUTHOR AND COPYRIGHT

Copyright (c) 1997-2007 Tom Christiansen, Nathan Torkington, and
other authors as noted. All rights reserved.

This documentation is free; you can redistribute it and/or modify it
under the same terms as Perl itself.

Irrespective of its distribution, all code examples in this file
are hereby placed into the public domain.  You are permitted and
encouraged to use this code in your own programs for fun
or for profit as you see fit.  A simple comment in the code giving
credit would be courteous but is not required.
